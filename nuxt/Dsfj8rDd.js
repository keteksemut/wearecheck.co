function __vite__mapDeps(indexes) {
  if (!__vite__mapDeps.viteFileDeps) {
      __vite__mapDeps.viteFileDeps = ["./Cgt08vL4.js", "./DoIEqydL.js", "./DVefFu0y.js", "./CzmNwk7v.js", "./about.DYdA2QdE.css", "./cbUdJWfL.js", "./-ltxHi4D.js", "./D4gSWyDD.js", "./BP_obRgz.js", "./careers.8dQRTyp_.css", "./BzBQ7ZwS.js", "./VeJ1dDW1.js", "./contact.4hqApv5O.css", "./DoZHCXTn.js", "./BHO9ful0.js", "./Project.oac8V0_7.css", "./B_1QFVYe.js", "./index.Cb1ctRml.css", "./BvtywrCf.js", "./services.Csi6QayS.css", "./Cye3HFxU.js", "./B8mh8V4i.js", "./zmcq017j.js", "./ContentLoader.CEL3A0Ie.css", "./DeCdf9Kn.js", "./_slug_.k5CEm6k_.css", "./C1iqj4lt.js", "./index.Dbun9GLX.css", "./DmtyMaM0.js", "./_slug_.DPJ5sddA.css", "./DLIuzo_Q.js", "./CZp8jUjT.js", "./HKGoNIjM.js", "./D_jCLv_g.js", "./default.rLUMahh4.css"]
  }
  return indexes.map((i)=>__vite__mapDeps.viteFileDeps[i])
}
var gt = Object.defineProperty;
var _t = (e,t,r)=>t in e ? gt(e, t, {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: r
}) : e[t] = r;
var pt = (e,t,r)=>(_t(e, typeof t != "symbol" ? t + "" : t, r),
r);
/**
* @vue/shared v3.4.21
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function makeMap(e, t) {
  const r = new Set(e.split(","));
  return t ? a=>r.has(a.toLowerCase()) : a=>r.has(a)
}
const EMPTY_OBJ = {}
, EMPTY_ARR = []
, NOOP = ()=>{}
, NO = ()=>!1
, isOn = e=>e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && (e.charCodeAt(2) > 122 || e.charCodeAt(2) < 97)
, isModelListener = e=>e.startsWith("onUpdate:")
, extend = Object.assign
, remove = (e,t)=>{
  const r = e.indexOf(t);
  r > -1 && e.splice(r, 1)
}
, hasOwnProperty$1 = Object.prototype.hasOwnProperty
, hasOwn = (e,t)=>hasOwnProperty$1.call(e, t)
, isArray$1 = Array.isArray
, isMap = e=>toTypeString(e) === "[object Map]"
, isSet = e=>toTypeString(e) === "[object Set]"
, isDate = e=>toTypeString(e) === "[object Date]"
, isRegExp = e=>toTypeString(e) === "[object RegExp]"
, isFunction = e=>typeof e == "function"
, isString = e=>typeof e == "string"
, isSymbol = e=>typeof e == "symbol"
, isObject = e=>e !== null && typeof e == "object"
, isPromise = e=>(isObject(e) || isFunction(e)) && isFunction(e.then) && isFunction(e.catch)
, objectToString = Object.prototype.toString
, toTypeString = e=>objectToString.call(e)
, toRawType = e=>toTypeString(e).slice(8, -1)
, isPlainObject$1 = e=>toTypeString(e) === "[object Object]"
, isIntegerKey = e=>isString(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e
, isReservedProp = makeMap(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted")
, cacheStringFunction = e=>{
  const t = Object.create(null);
  return r=>t[r] || (t[r] = e(r))
}
, camelizeRE = /-(\w)/g
, camelize = cacheStringFunction(e=>e.replace(camelizeRE, (t,r)=>r ? r.toUpperCase() : ""))
, hyphenateRE = /\B([A-Z])/g
, hyphenate = cacheStringFunction(e=>e.replace(hyphenateRE, "-$1").toLowerCase())
, capitalize = cacheStringFunction(e=>e.charAt(0).toUpperCase() + e.slice(1))
, toHandlerKey = cacheStringFunction(e=>e ? `on${capitalize(e)}` : "")
, hasChanged = (e,t)=>!Object.is(e, t)
, invokeArrayFns = (e,t)=>{
  for (let r = 0; r < e.length; r++)
      e[r](t)
}
, def = (e,t,r)=>{
  Object.defineProperty(e, t, {
      configurable: !0,
      enumerable: !1,
      value: r
  })
}
, looseToNumber = e=>{
  const t = parseFloat(e);
  return isNaN(t) ? e : t
}
, toNumber = e=>{
  const t = isString(e) ? Number(e) : NaN;
  return isNaN(t) ? e : t
}
;
let _globalThis$2;
const getGlobalThis = ()=>_globalThis$2 || (_globalThis$2 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
function normalizeStyle(e) {
  if (isArray$1(e)) {
      const t = {};
      for (let r = 0; r < e.length; r++) {
          const a = e[r]
            , o = isString(a) ? parseStringStyle(a) : normalizeStyle(a);
          if (o)
              for (const l in o)
                  t[l] = o[l]
      }
      return t
  } else if (isString(e) || isObject(e))
      return e
}
const listDelimiterRE = /;(?![^(]*\))/g
, propertyDelimiterRE = /:([^]+)/
, styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(e) {
  const t = {};
  return e.replace(styleCommentRE, "").split(listDelimiterRE).forEach(r=>{
      if (r) {
          const a = r.split(propertyDelimiterRE);
          a.length > 1 && (t[a[0].trim()] = a[1].trim())
      }
  }
  ),
  t
}
function normalizeClass(e) {
  let t = "";
  if (isString(e))
      t = e;
  else if (isArray$1(e))
      for (let r = 0; r < e.length; r++) {
          const a = normalizeClass(e[r]);
          a && (t += a + " ")
      }
  else if (isObject(e))
      for (const r in e)
          e[r] && (t += r + " ");
  return t.trim()
}
const specialBooleanAttrs = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly"
, isSpecialBooleanAttr = makeMap(specialBooleanAttrs);
function includeBooleanAttr(e) {
  return !!e || e === ""
}
function looseCompareArrays(e, t) {
  if (e.length !== t.length)
      return !1;
  let r = !0;
  for (let a = 0; r && a < e.length; a++)
      r = looseEqual(e[a], t[a]);
  return r
}
function looseEqual(e, t) {
  if (e === t)
      return !0;
  let r = isDate(e)
    , a = isDate(t);
  if (r || a)
      return r && a ? e.getTime() === t.getTime() : !1;
  if (r = isSymbol(e),
  a = isSymbol(t),
  r || a)
      return e === t;
  if (r = isArray$1(e),
  a = isArray$1(t),
  r || a)
      return r && a ? looseCompareArrays(e, t) : !1;
  if (r = isObject(e),
  a = isObject(t),
  r || a) {
      if (!r || !a)
          return !1;
      const o = Object.keys(e).length
        , l = Object.keys(t).length;
      if (o !== l)
          return !1;
      for (const f in e) {
          const d = e.hasOwnProperty(f)
            , g = t.hasOwnProperty(f);
          if (d && !g || !d && g || !looseEqual(e[f], t[f]))
              return !1
      }
  }
  return String(e) === String(t)
}
function looseIndexOf(e, t) {
  return e.findIndex(r=>looseEqual(r, t))
}
const toDisplayString = e=>isString(e) ? e : e == null ? "" : isArray$1(e) || isObject(e) && (e.toString === objectToString || !isFunction(e.toString)) ? JSON.stringify(e, replacer, 2) : String(e)
, replacer = (e,t)=>t && t.__v_isRef ? replacer(e, t.value) : isMap(t) ? {
  [`Map(${t.size})`]: [...t.entries()].reduce((r,[a,o],l)=>(r[stringifySymbol(a, l) + " =>"] = o,
  r), {})
} : isSet(t) ? {
  [`Set(${t.size})`]: [...t.values()].map(r=>stringifySymbol(r))
} : isSymbol(t) ? stringifySymbol(t) : isObject(t) && !isArray$1(t) && !isPlainObject$1(t) ? String(t) : t
, stringifySymbol = (e,t="")=>{
  var r;
  return isSymbol(e) ? `Symbol(${(r = e.description) != null ? r : t})` : e
}
;
/**
* @vue/reactivity v3.4.21
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let activeEffectScope;
class EffectScope {
  constructor(t=!1) {
      this.detached = t,
      this._active = !0,
      this.effects = [],
      this.cleanups = [],
      this.parent = activeEffectScope,
      !t && activeEffectScope && (this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1)
  }
  get active() {
      return this._active
  }
  run(t) {
      if (this._active) {
          const r = activeEffectScope;
          try {
              return activeEffectScope = this,
              t()
          } finally {
              activeEffectScope = r
          }
      }
  }
  on() {
      activeEffectScope = this
  }
  off() {
      activeEffectScope = this.parent
  }
  stop(t) {
      if (this._active) {
          let r, a;
          for (r = 0,
          a = this.effects.length; r < a; r++)
              this.effects[r].stop();
          for (r = 0,
          a = this.cleanups.length; r < a; r++)
              this.cleanups[r]();
          if (this.scopes)
              for (r = 0,
              a = this.scopes.length; r < a; r++)
                  this.scopes[r].stop(!0);
          if (!this.detached && this.parent && !t) {
              const o = this.parent.scopes.pop();
              o && o !== this && (this.parent.scopes[this.index] = o,
              o.index = this.index)
          }
          this.parent = void 0,
          this._active = !1
      }
  }
}
function effectScope(e) {
  return new EffectScope(e)
}
function recordEffectScope(e, t=activeEffectScope) {
  t && t.active && t.effects.push(e)
}
function getCurrentScope() {
  return activeEffectScope
}
function onScopeDispose(e) {
  activeEffectScope && activeEffectScope.cleanups.push(e)
}
let activeEffect;
class ReactiveEffect {
  constructor(t, r, a, o) {
      this.fn = t,
      this.trigger = r,
      this.scheduler = a,
      this.active = !0,
      this.deps = [],
      this._dirtyLevel = 4,
      this._trackId = 0,
      this._runnings = 0,
      this._shouldSchedule = !1,
      this._depsLength = 0,
      recordEffectScope(this, o)
  }
  get dirty() {
      if (this._dirtyLevel === 2 || this._dirtyLevel === 3) {
          this._dirtyLevel = 1,
          pauseTracking();
          for (let t = 0; t < this._depsLength; t++) {
              const r = this.deps[t];
              if (r.computed && (triggerComputed(r.computed),
              this._dirtyLevel >= 4))
                  break
          }
          this._dirtyLevel === 1 && (this._dirtyLevel = 0),
          resetTracking()
      }
      return this._dirtyLevel >= 4
  }
  set dirty(t) {
      this._dirtyLevel = t ? 4 : 0
  }
  run() {
      if (this._dirtyLevel = 0,
      !this.active)
          return this.fn();
      let t = shouldTrack
        , r = activeEffect;
      try {
          return shouldTrack = !0,
          activeEffect = this,
          this._runnings++,
          preCleanupEffect(this),
          this.fn()
      } finally {
          postCleanupEffect(this),
          this._runnings--,
          activeEffect = r,
          shouldTrack = t
      }
  }
  stop() {
      var t;
      this.active && (preCleanupEffect(this),
      postCleanupEffect(this),
      (t = this.onStop) == null || t.call(this),
      this.active = !1)
  }
}
function triggerComputed(e) {
  return e.value
}
function preCleanupEffect(e) {
  e._trackId++,
  e._depsLength = 0
}
function postCleanupEffect(e) {
  if (e.deps.length > e._depsLength) {
      for (let t = e._depsLength; t < e.deps.length; t++)
          cleanupDepEffect(e.deps[t], e);
      e.deps.length = e._depsLength
  }
}
function cleanupDepEffect(e, t) {
  const r = e.get(t);
  r !== void 0 && t._trackId !== r && (e.delete(t),
  e.size === 0 && e.cleanup())
}
let shouldTrack = !0
, pauseScheduleStack = 0;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack),
  shouldTrack = !1
}
function resetTracking() {
  const e = trackStack.pop();
  shouldTrack = e === void 0 ? !0 : e
}
function pauseScheduling() {
  pauseScheduleStack++
}
function resetScheduling() {
  for (pauseScheduleStack--; !pauseScheduleStack && queueEffectSchedulers.length; )
      queueEffectSchedulers.shift()()
}
function trackEffect(e, t, r) {
  if (t.get(e) !== e._trackId) {
      t.set(e, e._trackId);
      const a = e.deps[e._depsLength];
      a !== t ? (a && cleanupDepEffect(a, e),
      e.deps[e._depsLength++] = t) : e._depsLength++
  }
}
const queueEffectSchedulers = [];
function triggerEffects(e, t, r) {
  pauseScheduling();
  for (const a of e.keys()) {
      let o;
      a._dirtyLevel < t && (o ?? (o = e.get(a) === a._trackId)) && (a._shouldSchedule || (a._shouldSchedule = a._dirtyLevel === 0),
      a._dirtyLevel = t),
      a._shouldSchedule && (o ?? (o = e.get(a) === a._trackId)) && (a.trigger(),
      (!a._runnings || a.allowRecurse) && a._dirtyLevel !== 2 && (a._shouldSchedule = !1,
      a.scheduler && queueEffectSchedulers.push(a.scheduler)))
  }
  resetScheduling()
}
const createDep = (e,t)=>{
  const r = new Map;
  return r.cleanup = e,
  r.computed = t,
  r
}
, targetMap = new WeakMap
, ITERATE_KEY = Symbol("")
, MAP_KEY_ITERATE_KEY = Symbol("");
function track(e, t, r) {
  if (shouldTrack && activeEffect) {
      let a = targetMap.get(e);
      a || targetMap.set(e, a = new Map);
      let o = a.get(r);
      o || a.set(r, o = createDep(()=>a.delete(r))),
      trackEffect(activeEffect, o)
  }
}
function trigger(e, t, r, a, o, l) {
  const f = targetMap.get(e);
  if (!f)
      return;
  let d = [];
  if (t === "clear")
      d = [...f.values()];
  else if (r === "length" && isArray$1(e)) {
      const g = Number(a);
      f.forEach((_,v)=>{
          (v === "length" || !isSymbol(v) && v >= g) && d.push(_)
      }
      )
  } else
      switch (r !== void 0 && d.push(f.get(r)),
      t) {
      case "add":
          isArray$1(e) ? isIntegerKey(r) && d.push(f.get("length")) : (d.push(f.get(ITERATE_KEY)),
          isMap(e) && d.push(f.get(MAP_KEY_ITERATE_KEY)));
          break;
      case "delete":
          isArray$1(e) || (d.push(f.get(ITERATE_KEY)),
          isMap(e) && d.push(f.get(MAP_KEY_ITERATE_KEY)));
          break;
      case "set":
          isMap(e) && d.push(f.get(ITERATE_KEY));
          break
      }
  pauseScheduling();
  for (const g of d)
      g && triggerEffects(g, 4);
  resetScheduling()
}
function getDepFromReactive(e, t) {
  var r;
  return (r = targetMap.get(e)) == null ? void 0 : r.get(t)
}
const isNonTrackableKeys = makeMap("__proto__,__v_isRef,__isVue")
, builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol).filter(e=>e !== "arguments" && e !== "caller").map(e=>Symbol[e]).filter(isSymbol))
, arrayInstrumentations = createArrayInstrumentations();
function createArrayInstrumentations() {
  const e = {};
  return ["includes", "indexOf", "lastIndexOf"].forEach(t=>{
      e[t] = function(...r) {
          const a = toRaw(this);
          for (let l = 0, f = this.length; l < f; l++)
              track(a, "get", l + "");
          const o = a[t](...r);
          return o === -1 || o === !1 ? a[t](...r.map(toRaw)) : o
      }
  }
  ),
  ["push", "pop", "shift", "unshift", "splice"].forEach(t=>{
      e[t] = function(...r) {
          pauseTracking(),
          pauseScheduling();
          const a = toRaw(this)[t].apply(this, r);
          return resetScheduling(),
          resetTracking(),
          a
      }
  }
  ),
  e
}
function hasOwnProperty(e) {
  const t = toRaw(this);
  return track(t, "has", e),
  t.hasOwnProperty(e)
}
class BaseReactiveHandler {
  constructor(t=!1, r=!1) {
      this._isReadonly = t,
      this._isShallow = r
  }
  get(t, r, a) {
      const o = this._isReadonly
        , l = this._isShallow;
      if (r === "__v_isReactive")
          return !o;
      if (r === "__v_isReadonly")
          return o;
      if (r === "__v_isShallow")
          return l;
      if (r === "__v_raw")
          return a === (o ? l ? shallowReadonlyMap : readonlyMap : l ? shallowReactiveMap : reactiveMap).get(t) || Object.getPrototypeOf(t) === Object.getPrototypeOf(a) ? t : void 0;
      const f = isArray$1(t);
      if (!o) {
          if (f && hasOwn(arrayInstrumentations, r))
              return Reflect.get(arrayInstrumentations, r, a);
          if (r === "hasOwnProperty")
              return hasOwnProperty
      }
      const d = Reflect.get(t, r, a);
      return (isSymbol(r) ? builtInSymbols.has(r) : isNonTrackableKeys(r)) || (o || track(t, "get", r),
      l) ? d : isRef(d) ? f && isIntegerKey(r) ? d : d.value : isObject(d) ? o ? readonly(d) : reactive(d) : d
  }
}
class MutableReactiveHandler extends BaseReactiveHandler {
  constructor(t=!1) {
      super(!1, t)
  }
  set(t, r, a, o) {
      let l = t[r];
      if (!this._isShallow) {
          const g = isReadonly(l);
          if (!isShallow(a) && !isReadonly(a) && (l = toRaw(l),
          a = toRaw(a)),
          !isArray$1(t) && isRef(l) && !isRef(a))
              return g ? !1 : (l.value = a,
              !0)
      }
      const f = isArray$1(t) && isIntegerKey(r) ? Number(r) < t.length : hasOwn(t, r)
        , d = Reflect.set(t, r, a, o);
      return t === toRaw(o) && (f ? hasChanged(a, l) && trigger(t, "set", r, a) : trigger(t, "add", r, a)),
      d
  }
  deleteProperty(t, r) {
      const a = hasOwn(t, r);
      t[r];
      const o = Reflect.deleteProperty(t, r);
      return o && a && trigger(t, "delete", r, void 0),
      o
  }
  has(t, r) {
      const a = Reflect.has(t, r);
      return (!isSymbol(r) || !builtInSymbols.has(r)) && track(t, "has", r),
      a
  }
  ownKeys(t) {
      return track(t, "iterate", isArray$1(t) ? "length" : ITERATE_KEY),
      Reflect.ownKeys(t)
  }
}
class ReadonlyReactiveHandler extends BaseReactiveHandler {
  constructor(t=!1) {
      super(!0, t)
  }
  set(t, r) {
      return !0
  }
  deleteProperty(t, r) {
      return !0
  }
}
const mutableHandlers = new MutableReactiveHandler
, readonlyHandlers = new ReadonlyReactiveHandler
, shallowReactiveHandlers = new MutableReactiveHandler(!0)
, toShallow = e=>e
, getProto = e=>Reflect.getPrototypeOf(e);
function get(e, t, r=!1, a=!1) {
  e = e.__v_raw;
  const o = toRaw(e)
    , l = toRaw(t);
  r || (hasChanged(t, l) && track(o, "get", t),
  track(o, "get", l));
  const {has: f} = getProto(o)
    , d = a ? toShallow : r ? toReadonly : toReactive;
  if (f.call(o, t))
      return d(e.get(t));
  if (f.call(o, l))
      return d(e.get(l));
  e !== o && e.get(t)
}
function has(e, t=!1) {
  const r = this.__v_raw
    , a = toRaw(r)
    , o = toRaw(e);
  return t || (hasChanged(e, o) && track(a, "has", e),
  track(a, "has", o)),
  e === o ? r.has(e) : r.has(e) || r.has(o)
}
function size(e, t=!1) {
  return e = e.__v_raw,
  !t && track(toRaw(e), "iterate", ITERATE_KEY),
  Reflect.get(e, "size", e)
}
function add(e) {
  e = toRaw(e);
  const t = toRaw(this);
  return getProto(t).has.call(t, e) || (t.add(e),
  trigger(t, "add", e, e)),
  this
}
function set(e, t) {
  t = toRaw(t);
  const r = toRaw(this)
    , {has: a, get: o} = getProto(r);
  let l = a.call(r, e);
  l || (e = toRaw(e),
  l = a.call(r, e));
  const f = o.call(r, e);
  return r.set(e, t),
  l ? hasChanged(t, f) && trigger(r, "set", e, t) : trigger(r, "add", e, t),
  this
}
function deleteEntry(e) {
  const t = toRaw(this)
    , {has: r, get: a} = getProto(t);
  let o = r.call(t, e);
  o || (e = toRaw(e),
  o = r.call(t, e)),
  a && a.call(t, e);
  const l = t.delete(e);
  return o && trigger(t, "delete", e, void 0),
  l
}
function clear() {
  const e = toRaw(this)
    , t = e.size !== 0
    , r = e.clear();
  return t && trigger(e, "clear", void 0, void 0),
  r
}
function createForEach(e, t) {
  return function(a, o) {
      const l = this
        , f = l.__v_raw
        , d = toRaw(f)
        , g = t ? toShallow : e ? toReadonly : toReactive;
      return !e && track(d, "iterate", ITERATE_KEY),
      f.forEach((_,v)=>a.call(o, g(_), g(v), l))
  }
}
function createIterableMethod(e, t, r) {
  return function(...a) {
      const o = this.__v_raw
        , l = toRaw(o)
        , f = isMap(l)
        , d = e === "entries" || e === Symbol.iterator && f
        , g = e === "keys" && f
        , _ = o[e](...a)
        , v = r ? toShallow : t ? toReadonly : toReactive;
      return !t && track(l, "iterate", g ? MAP_KEY_ITERATE_KEY : ITERATE_KEY),
      {
          next() {
              const {value: S, done: b} = _.next();
              return b ? {
                  value: S,
                  done: b
              } : {
                  value: d ? [v(S[0]), v(S[1])] : v(S),
                  done: b
              }
          },
          [Symbol.iterator]() {
              return this
          }
      }
  }
}
function createReadonlyMethod(e) {
  return function(...t) {
      return e === "delete" ? !1 : e === "clear" ? void 0 : this
  }
}
function createInstrumentations() {
  const e = {
      get(l) {
          return get(this, l)
      },
      get size() {
          return size(this)
      },
      has,
      add,
      set,
      delete: deleteEntry,
      clear,
      forEach: createForEach(!1, !1)
  }
    , t = {
      get(l) {
          return get(this, l, !1, !0)
      },
      get size() {
          return size(this)
      },
      has,
      add,
      set,
      delete: deleteEntry,
      clear,
      forEach: createForEach(!1, !0)
  }
    , r = {
      get(l) {
          return get(this, l, !0)
      },
      get size() {
          return size(this, !0)
      },
      has(l) {
          return has.call(this, l, !0)
      },
      add: createReadonlyMethod("add"),
      set: createReadonlyMethod("set"),
      delete: createReadonlyMethod("delete"),
      clear: createReadonlyMethod("clear"),
      forEach: createForEach(!0, !1)
  }
    , a = {
      get(l) {
          return get(this, l, !0, !0)
      },
      get size() {
          return size(this, !0)
      },
      has(l) {
          return has.call(this, l, !0)
      },
      add: createReadonlyMethod("add"),
      set: createReadonlyMethod("set"),
      delete: createReadonlyMethod("delete"),
      clear: createReadonlyMethod("clear"),
      forEach: createForEach(!0, !0)
  };
  return ["keys", "values", "entries", Symbol.iterator].forEach(l=>{
      e[l] = createIterableMethod(l, !1, !1),
      r[l] = createIterableMethod(l, !0, !1),
      t[l] = createIterableMethod(l, !1, !0),
      a[l] = createIterableMethod(l, !0, !0)
  }
  ),
  [e, r, t, a]
}
const [mutableInstrumentations,readonlyInstrumentations,shallowInstrumentations,shallowReadonlyInstrumentations] = createInstrumentations();
function createInstrumentationGetter(e, t) {
  const r = t ? e ? shallowReadonlyInstrumentations : shallowInstrumentations : e ? readonlyInstrumentations : mutableInstrumentations;
  return (a,o,l)=>o === "__v_isReactive" ? !e : o === "__v_isReadonly" ? e : o === "__v_raw" ? a : Reflect.get(hasOwn(r, o) && o in a ? r : a, o, l)
}
const mutableCollectionHandlers = {
  get: createInstrumentationGetter(!1, !1)
}
, shallowCollectionHandlers = {
  get: createInstrumentationGetter(!1, !0)
}
, readonlyCollectionHandlers = {
  get: createInstrumentationGetter(!0, !1)
}
, reactiveMap = new WeakMap
, shallowReactiveMap = new WeakMap
, readonlyMap = new WeakMap
, shallowReadonlyMap = new WeakMap;
function targetTypeMap(e) {
  switch (e) {
  case "Object":
  case "Array":
      return 1;
  case "Map":
  case "Set":
  case "WeakMap":
  case "WeakSet":
      return 2;
  default:
      return 0
  }
}
function getTargetType(e) {
  return e.__v_skip || !Object.isExtensible(e) ? 0 : targetTypeMap(toRawType(e))
}
function reactive(e) {
  return isReadonly(e) ? e : createReactiveObject(e, !1, mutableHandlers, mutableCollectionHandlers, reactiveMap)
}
function shallowReactive(e) {
  return createReactiveObject(e, !1, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap)
}
function readonly(e) {
  return createReactiveObject(e, !0, readonlyHandlers, readonlyCollectionHandlers, readonlyMap)
}
function createReactiveObject(e, t, r, a, o) {
  if (!isObject(e) || e.__v_raw && !(t && e.__v_isReactive))
      return e;
  const l = o.get(e);
  if (l)
      return l;
  const f = getTargetType(e);
  if (f === 0)
      return e;
  const d = new Proxy(e,f === 2 ? a : r);
  return o.set(e, d),
  d
}
function isReactive(e) {
  return isReadonly(e) ? isReactive(e.__v_raw) : !!(e && e.__v_isReactive)
}
function isReadonly(e) {
  return !!(e && e.__v_isReadonly)
}
function isShallow(e) {
  return !!(e && e.__v_isShallow)
}
function isProxy(e) {
  return isReactive(e) || isReadonly(e)
}
function toRaw(e) {
  const t = e && e.__v_raw;
  return t ? toRaw(t) : e
}
function markRaw(e) {
  return Object.isExtensible(e) && def(e, "__v_skip", !0),
  e
}
const toReactive = e=>isObject(e) ? reactive(e) : e
, toReadonly = e=>isObject(e) ? readonly(e) : e;
class ComputedRefImpl {
  constructor(t, r, a, o) {
      this.getter = t,
      this._setter = r,
      this.dep = void 0,
      this.__v_isRef = !0,
      this.__v_isReadonly = !1,
      this.effect = new ReactiveEffect(()=>t(this._value),()=>triggerRefValue(this, this.effect._dirtyLevel === 2 ? 2 : 3)),
      this.effect.computed = this,
      this.effect.active = this._cacheable = !o,
      this.__v_isReadonly = a
  }
  get value() {
      const t = toRaw(this);
      return (!t._cacheable || t.effect.dirty) && hasChanged(t._value, t._value = t.effect.run()) && triggerRefValue(t, 4),
      trackRefValue(t),
      t.effect._dirtyLevel >= 2 && triggerRefValue(t, 2),
      t._value
  }
  set value(t) {
      this._setter(t)
  }
  get _dirty() {
      return this.effect.dirty
  }
  set _dirty(t) {
      this.effect.dirty = t
  }
}
function computed$1(e, t, r=!1) {
  let a, o;
  const l = isFunction(e);
  return l ? (a = e,
  o = NOOP) : (a = e.get,
  o = e.set),
  new ComputedRefImpl(a,o,l || !o,r)
}
function trackRefValue(e) {
  var t;
  shouldTrack && activeEffect && (e = toRaw(e),
  trackEffect(activeEffect, (t = e.dep) != null ? t : e.dep = createDep(()=>e.dep = void 0, e instanceof ComputedRefImpl ? e : void 0)))
}
function triggerRefValue(e, t=4, r) {
  e = toRaw(e);
  const a = e.dep;
  a && triggerEffects(a, t)
}
function isRef(e) {
  return !!(e && e.__v_isRef === !0)
}
function ref(e) {
  return createRef(e, !1)
}
function shallowRef(e) {
  return createRef(e, !0)
}
function createRef(e, t) {
  return isRef(e) ? e : new RefImpl(e,t)
}
class RefImpl {
  constructor(t, r) {
      this.__v_isShallow = r,
      this.dep = void 0,
      this.__v_isRef = !0,
      this._rawValue = r ? t : toRaw(t),
      this._value = r ? t : toReactive(t)
  }
  get value() {
      return trackRefValue(this),
      this._value
  }
  set value(t) {
      const r = this.__v_isShallow || isShallow(t) || isReadonly(t);
      t = r ? t : toRaw(t),
      hasChanged(t, this._rawValue) && (this._rawValue = t,
      this._value = r ? t : toReactive(t),
      triggerRefValue(this, 4))
  }
}
function unref(e) {
  return isRef(e) ? e.value : e
}
function toValue(e) {
  return isFunction(e) ? e() : unref(e)
}
const shallowUnwrapHandlers = {
  get: (e,t,r)=>unref(Reflect.get(e, t, r)),
  set: (e,t,r,a)=>{
      const o = e[t];
      return isRef(o) && !isRef(r) ? (o.value = r,
      !0) : Reflect.set(e, t, r, a)
  }
};
function proxyRefs(e) {
  return isReactive(e) ? e : new Proxy(e,shallowUnwrapHandlers)
}
class CustomRefImpl {
  constructor(t) {
      this.dep = void 0,
      this.__v_isRef = !0;
      const {get: r, set: a} = t(()=>trackRefValue(this), ()=>triggerRefValue(this));
      this._get = r,
      this._set = a
  }
  get value() {
      return this._get()
  }
  set value(t) {
      this._set(t)
  }
}
function customRef(e) {
  return new CustomRefImpl(e)
}
class ObjectRefImpl {
  constructor(t, r, a) {
      this._object = t,
      this._key = r,
      this._defaultValue = a,
      this.__v_isRef = !0
  }
  get value() {
      const t = this._object[this._key];
      return t === void 0 ? this._defaultValue : t
  }
  set value(t) {
      this._object[this._key] = t
  }
  get dep() {
      return getDepFromReactive(toRaw(this._object), this._key)
  }
}
class GetterRefImpl {
  constructor(t) {
      this._getter = t,
      this.__v_isRef = !0,
      this.__v_isReadonly = !0
  }
  get value() {
      return this._getter()
  }
}
function toRef(e, t, r) {
  return isRef(e) ? e : isFunction(e) ? new GetterRefImpl(e) : isObject(e) && arguments.length > 1 ? propertyToRef(e, t, r) : ref(e)
}
function propertyToRef(e, t, r) {
  const a = e[t];
  return isRef(a) ? a : new ObjectRefImpl(e,t,r)
}
/**
* @vue/runtime-core v3.4.21
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const stack = [];
function warn$1(e, ...t) {
  pauseTracking();
  const r = stack.length ? stack[stack.length - 1].component : null
    , a = r && r.appContext.config.warnHandler
    , o = getComponentTrace();
  if (a)
      callWithErrorHandling(a, r, 11, [e + t.map(l=>{
          var f, d;
          return (d = (f = l.toString) == null ? void 0 : f.call(l)) != null ? d : JSON.stringify(l)
      }
      ).join(""), r && r.proxy, o.map(({vnode: l})=>`at <${formatComponentName(r, l.type)}>`).join(`
`), o]);
  else {
      const l = [`[Vue warn]: ${e}`, ...t];
      o.length && l.push(`
`, ...formatTrace(o)),
      console.warn(...l)
  }
  resetTracking()
}
function getComponentTrace() {
  let e = stack[stack.length - 1];
  if (!e)
      return [];
  const t = [];
  for (; e; ) {
      const r = t[0];
      r && r.vnode === e ? r.recurseCount++ : t.push({
          vnode: e,
          recurseCount: 0
      });
      const a = e.component && e.component.parent;
      e = a && a.vnode
  }
  return t
}
function formatTrace(e) {
  const t = [];
  return e.forEach((r,a)=>{
      t.push(...a === 0 ? [] : [`
`], ...formatTraceEntry(r))
  }
  ),
  t
}
function formatTraceEntry({vnode: e, recurseCount: t}) {
  const r = t > 0 ? `... (${t} recursive calls)` : ""
    , a = e.component ? e.component.parent == null : !1
    , o = ` at <${formatComponentName(e.component, e.type, a)}`
    , l = ">" + r;
  return e.props ? [o, ...formatProps(e.props), l] : [o + l]
}
function formatProps(e) {
  const t = []
    , r = Object.keys(e);
  return r.slice(0, 3).forEach(a=>{
      t.push(...formatProp(a, e[a]))
  }
  ),
  r.length > 3 && t.push(" ..."),
  t
}
function formatProp(e, t, r) {
  return isString(t) ? (t = JSON.stringify(t),
  r ? t : [`${e}=${t}`]) : typeof t == "number" || typeof t == "boolean" || t == null ? r ? t : [`${e}=${t}`] : isRef(t) ? (t = formatProp(e, toRaw(t.value), !0),
  r ? t : [`${e}=Ref<`, t, ">"]) : isFunction(t) ? [`${e}=fn${t.name ? `<${t.name}>` : ""}`] : (t = toRaw(t),
  r ? t : [`${e}=`, t])
}
function callWithErrorHandling(e, t, r, a) {
  try {
      return a ? e(...a) : e()
  } catch (o) {
      handleError(o, t, r)
  }
}
function callWithAsyncErrorHandling(e, t, r, a) {
  if (isFunction(e)) {
      const l = callWithErrorHandling(e, t, r, a);
      return l && isPromise(l) && l.catch(f=>{
          handleError(f, t, r)
      }
      ),
      l
  }
  const o = [];
  for (let l = 0; l < e.length; l++)
      o.push(callWithAsyncErrorHandling(e[l], t, r, a));
  return o
}
function handleError(e, t, r, a=!0) {
  const o = t ? t.vnode : null;
  if (t) {
      let l = t.parent;
      const f = t.proxy
        , d = `https://vuejs.org/error-reference/#runtime-${r}`;
      for (; l; ) {
          const _ = l.ec;
          if (_) {
              for (let v = 0; v < _.length; v++)
                  if (_[v](e, f, d) === !1)
                      return
          }
          l = l.parent
      }
      const g = t.appContext.config.errorHandler;
      if (g) {
          callWithErrorHandling(g, null, 10, [e, f, d]);
          return
      }
  }
  logError(e, r, o, a)
}
function logError(e, t, r, a=!0) {
  console.error(e)
}
let isFlushing = !1
, isFlushPending = !1;
const queue = [];
let flushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null
, postFlushIndex = 0;
const resolvedPromise = Promise.resolve();
let currentFlushPromise = null;
function nextTick(e) {
  const t = currentFlushPromise || resolvedPromise;
  return e ? t.then(this ? e.bind(this) : e) : t
}
function findInsertionIndex(e) {
  let t = flushIndex + 1
    , r = queue.length;
  for (; t < r; ) {
      const a = t + r >>> 1
        , o = queue[a]
        , l = getId(o);
      l < e || l === e && o.pre ? t = a + 1 : r = a
  }
  return t
}
function queueJob(e) {
  (!queue.length || !queue.includes(e, isFlushing && e.allowRecurse ? flushIndex + 1 : flushIndex)) && (e.id == null ? queue.push(e) : queue.splice(findInsertionIndex(e.id), 0, e),
  queueFlush())
}
function queueFlush() {
  !isFlushing && !isFlushPending && (isFlushPending = !0,
  currentFlushPromise = resolvedPromise.then(flushJobs))
}
function invalidateJob(e) {
  const t = queue.indexOf(e);
  t > flushIndex && queue.splice(t, 1)
}
function queuePostFlushCb(e) {
  isArray$1(e) ? pendingPostFlushCbs.push(...e) : (!activePostFlushCbs || !activePostFlushCbs.includes(e, e.allowRecurse ? postFlushIndex + 1 : postFlushIndex)) && pendingPostFlushCbs.push(e),
  queueFlush()
}
function flushPreFlushCbs(e, t, r=isFlushing ? flushIndex + 1 : 0) {
  for (; r < queue.length; r++) {
      const a = queue[r];
      if (a && a.pre) {
          if (e && a.id !== e.uid)
              continue;
          queue.splice(r, 1),
          r--,
          a()
      }
  }
}
function flushPostFlushCbs(e) {
  if (pendingPostFlushCbs.length) {
      const t = [...new Set(pendingPostFlushCbs)].sort((r,a)=>getId(r) - getId(a));
      if (pendingPostFlushCbs.length = 0,
      activePostFlushCbs) {
          activePostFlushCbs.push(...t);
          return
      }
      for (activePostFlushCbs = t,
      postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++)
          activePostFlushCbs[postFlushIndex]();
      activePostFlushCbs = null,
      postFlushIndex = 0
  }
}
const getId = e=>e.id == null ? 1 / 0 : e.id
, comparator = (e,t)=>{
  const r = getId(e) - getId(t);
  if (r === 0) {
      if (e.pre && !t.pre)
          return -1;
      if (t.pre && !e.pre)
          return 1
  }
  return r
}
;
function flushJobs(e) {
  isFlushPending = !1,
  isFlushing = !0,
  queue.sort(comparator);
  try {
      for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
          const t = queue[flushIndex];
          t && t.active !== !1 && callWithErrorHandling(t, null, 14)
      }
  } finally {
      flushIndex = 0,
      queue.length = 0,
      flushPostFlushCbs(),
      isFlushing = !1,
      currentFlushPromise = null,
      (queue.length || pendingPostFlushCbs.length) && flushJobs()
  }
}
function emit(e, t, ...r) {
  if (e.isUnmounted)
      return;
  const a = e.vnode.props || EMPTY_OBJ;
  let o = r;
  const l = t.startsWith("update:")
    , f = l && t.slice(7);
  if (f && f in a) {
      const v = `${f === "modelValue" ? "model" : f}Modifiers`
        , {number: S, trim: b} = a[v] || EMPTY_OBJ;
      b && (o = r.map(P=>isString(P) ? P.trim() : P)),
      S && (o = r.map(looseToNumber))
  }
  let d, g = a[d = toHandlerKey(t)] || a[d = toHandlerKey(camelize(t))];
  !g && l && (g = a[d = toHandlerKey(hyphenate(t))]),
  g && callWithAsyncErrorHandling(g, e, 6, o);
  const _ = a[d + "Once"];
  if (_) {
      if (!e.emitted)
          e.emitted = {};
      else if (e.emitted[d])
          return;
      e.emitted[d] = !0,
      callWithAsyncErrorHandling(_, e, 6, o)
  }
}
function normalizeEmitsOptions(e, t, r=!1) {
  const a = t.emitsCache
    , o = a.get(e);
  if (o !== void 0)
      return o;
  const l = e.emits;
  let f = {}
    , d = !1;
  if (!isFunction(e)) {
      const g = _=>{
          const v = normalizeEmitsOptions(_, t, !0);
          v && (d = !0,
          extend(f, v))
      }
      ;
      !r && t.mixins.length && t.mixins.forEach(g),
      e.extends && g(e.extends),
      e.mixins && e.mixins.forEach(g)
  }
  return !l && !d ? (isObject(e) && a.set(e, null),
  null) : (isArray$1(l) ? l.forEach(g=>f[g] = null) : extend(f, l),
  isObject(e) && a.set(e, f),
  f)
}
function isEmitListener(e, t) {
  return !e || !isOn(t) ? !1 : (t = t.slice(2).replace(/Once$/, ""),
  hasOwn(e, t[0].toLowerCase() + t.slice(1)) || hasOwn(e, hyphenate(t)) || hasOwn(e, t))
}
let currentRenderingInstance = null
, currentScopeId = null;
function setCurrentRenderingInstance(e) {
  const t = currentRenderingInstance;
  return currentRenderingInstance = e,
  currentScopeId = e && e.type.__scopeId || null,
  t
}
function pushScopeId(e) {
  currentScopeId = e
}
function popScopeId() {
  currentScopeId = null
}
function withCtx(e, t=currentRenderingInstance, r) {
  if (!t || e._n)
      return e;
  const a = (...o)=>{
      a._d && setBlockTracking(-1);
      const l = setCurrentRenderingInstance(t);
      let f;
      try {
          f = e(...o)
      } finally {
          setCurrentRenderingInstance(l),
          a._d && setBlockTracking(1)
      }
      return f
  }
  ;
  return a._n = !0,
  a._c = !0,
  a._d = !0,
  a
}
function markAttrsAccessed() {}
function renderComponentRoot(e) {
  const {type: t, vnode: r, proxy: a, withProxy: o, props: l, propsOptions: [f], slots: d, attrs: g, emit: _, render: v, renderCache: S, data: b, setupState: P, ctx: x, inheritAttrs: E} = e;
  let I, C;
  const A = setCurrentRenderingInstance(e);
  try {
      if (r.shapeFlag & 4) {
          const w = o || a
            , M = w;
          I = normalizeVNode(v.call(M, w, S, l, P, b, x)),
          C = g
      } else {
          const w = t;
          I = normalizeVNode(w.length > 1 ? w(l, {
              attrs: g,
              slots: d,
              emit: _
          }) : w(l, null)),
          C = t.props ? g : getFunctionalFallthrough(g)
      }
  } catch (w) {
      blockStack.length = 0,
      handleError(w, e, 1),
      I = createVNode(Comment)
  }
  let T = I;
  if (C && E !== !1) {
      const w = Object.keys(C)
        , {shapeFlag: M} = T;
      w.length && M & 7 && (f && w.some(isModelListener) && (C = filterModelListeners(C, f)),
      T = cloneVNode(T, C))
  }
  return r.dirs && (T = cloneVNode(T),
  T.dirs = T.dirs ? T.dirs.concat(r.dirs) : r.dirs),
  r.transition && (T.transition = r.transition),
  I = T,
  setCurrentRenderingInstance(A),
  I
}
function filterSingleRoot(e, t=!0) {
  let r;
  for (let a = 0; a < e.length; a++) {
      const o = e[a];
      if (isVNode(o)) {
          if (o.type !== Comment || o.children === "v-if") {
              if (r)
                  return;
              r = o
          }
      } else
          return
  }
  return r
}
const getFunctionalFallthrough = e=>{
  let t;
  for (const r in e)
      (r === "class" || r === "style" || isOn(r)) && ((t || (t = {}))[r] = e[r]);
  return t
}
, filterModelListeners = (e,t)=>{
  const r = {};
  for (const a in e)
      (!isModelListener(a) || !(a.slice(9)in t)) && (r[a] = e[a]);
  return r
}
;
function shouldUpdateComponent(e, t, r) {
  const {props: a, children: o, component: l} = e
    , {props: f, children: d, patchFlag: g} = t
    , _ = l.emitsOptions;
  if (t.dirs || t.transition)
      return !0;
  if (r && g >= 0) {
      if (g & 1024)
          return !0;
      if (g & 16)
          return a ? hasPropsChanged(a, f, _) : !!f;
      if (g & 8) {
          const v = t.dynamicProps;
          for (let S = 0; S < v.length; S++) {
              const b = v[S];
              if (f[b] !== a[b] && !isEmitListener(_, b))
                  return !0
          }
      }
  } else
      return (o || d) && (!d || !d.$stable) ? !0 : a === f ? !1 : a ? f ? hasPropsChanged(a, f, _) : !0 : !!f;
  return !1
}
function hasPropsChanged(e, t, r) {
  const a = Object.keys(t);
  if (a.length !== Object.keys(e).length)
      return !0;
  for (let o = 0; o < a.length; o++) {
      const l = a[o];
      if (t[l] !== e[l] && !isEmitListener(r, l))
          return !0
  }
  return !1
}
function updateHOCHostEl({vnode: e, parent: t}, r) {
  for (; t; ) {
      const a = t.subTree;
      if (a.suspense && a.suspense.activeBranch === e && (a.el = e.el),
      a === e)
          (e = t.vnode).el = r,
          t = t.parent;
      else
          break
  }
}
const COMPONENTS = "components";
function resolveComponent(e, t) {
  return resolveAsset(COMPONENTS, e, !0, t) || e
}
const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
function resolveDynamicComponent(e) {
  return isString(e) ? resolveAsset(COMPONENTS, e, !1) || e : e || NULL_DYNAMIC_COMPONENT
}
function resolveAsset(e, t, r=!0, a=!1) {
  const o = currentRenderingInstance || currentInstance;
  if (o) {
      const l = o.type;
      if (e === COMPONENTS) {
          const d = getComponentName(l, !1);
          if (d && (d === t || d === camelize(t) || d === capitalize(camelize(t))))
              return l
      }
      const f = resolve(o[e] || l[e], t) || resolve(o.appContext[e], t);
      return !f && a ? l : f
  }
}
function resolve(e, t) {
  return e && (e[t] || e[camelize(t)] || e[capitalize(camelize(t))])
}
const isSuspense = e=>e.__isSuspense;
let suspenseId = 0;
const SuspenseImpl = {
  name: "Suspense",
  __isSuspense: !0,
  process(e, t, r, a, o, l, f, d, g, _) {
      if (e == null)
          mountSuspense(t, r, a, o, l, f, d, g, _);
      else {
          if (l && l.deps > 0 && !e.suspense.isInFallback) {
              t.suspense = e.suspense,
              t.suspense.vnode = t,
              t.el = e.el;
              return
          }
          patchSuspense(e, t, r, a, o, f, d, g, _)
      }
  },
  hydrate: hydrateSuspense,
  create: createSuspenseBoundary,
  normalize: normalizeSuspenseChildren
}
, Suspense = SuspenseImpl;
function triggerEvent(e, t) {
  const r = e.props && e.props[t];
  isFunction(r) && r()
}
function mountSuspense(e, t, r, a, o, l, f, d, g) {
  const {p: _, o: {createElement: v}} = g
    , S = v("div")
    , b = e.suspense = createSuspenseBoundary(e, o, a, t, S, r, l, f, d, g);
  _(null, b.pendingBranch = e.ssContent, S, null, a, b, l, f),
  b.deps > 0 ? (triggerEvent(e, "onPending"),
  triggerEvent(e, "onFallback"),
  _(null, e.ssFallback, t, r, a, null, l, f),
  setActiveBranch(b, e.ssFallback)) : b.resolve(!1, !0)
}
function patchSuspense(e, t, r, a, o, l, f, d, {p: g, um: _, o: {createElement: v}}) {
  const S = t.suspense = e.suspense;
  S.vnode = t,
  t.el = e.el;
  const b = t.ssContent
    , P = t.ssFallback
    , {activeBranch: x, pendingBranch: E, isInFallback: I, isHydrating: C} = S;
  if (E)
      S.pendingBranch = b,
      isSameVNodeType(b, E) ? (g(E, b, S.hiddenContainer, null, o, S, l, f, d),
      S.deps <= 0 ? S.resolve() : I && (C || (g(x, P, r, a, o, null, l, f, d),
      setActiveBranch(S, P)))) : (S.pendingId = suspenseId++,
      C ? (S.isHydrating = !1,
      S.activeBranch = E) : _(E, o, S),
      S.deps = 0,
      S.effects.length = 0,
      S.hiddenContainer = v("div"),
      I ? (g(null, b, S.hiddenContainer, null, o, S, l, f, d),
      S.deps <= 0 ? S.resolve() : (g(x, P, r, a, o, null, l, f, d),
      setActiveBranch(S, P))) : x && isSameVNodeType(b, x) ? (g(x, b, r, a, o, S, l, f, d),
      S.resolve(!0)) : (g(null, b, S.hiddenContainer, null, o, S, l, f, d),
      S.deps <= 0 && S.resolve()));
  else if (x && isSameVNodeType(b, x))
      g(x, b, r, a, o, S, l, f, d),
      setActiveBranch(S, b);
  else if (triggerEvent(t, "onPending"),
  S.pendingBranch = b,
  b.shapeFlag & 512 ? S.pendingId = b.component.suspenseId : S.pendingId = suspenseId++,
  g(null, b, S.hiddenContainer, null, o, S, l, f, d),
  S.deps <= 0)
      S.resolve();
  else {
      const {timeout: A, pendingId: T} = S;
      A > 0 ? setTimeout(()=>{
          S.pendingId === T && S.fallback(P)
      }
      , A) : A === 0 && S.fallback(P)
  }
}
function createSuspenseBoundary(e, t, r, a, o, l, f, d, g, _, v=!1) {
  const {p: S, m: b, um: P, n: x, o: {parentNode: E, remove: I}} = _;
  let C;
  const A = isVNodeSuspensible(e);
  A && t != null && t.pendingBranch && (C = t.pendingId,
  t.deps++);
  const T = e.props ? toNumber(e.props.timeout) : void 0
    , w = l
    , M = {
      vnode: e,
      parent: t,
      parentComponent: r,
      namespace: f,
      container: a,
      hiddenContainer: o,
      deps: 0,
      pendingId: suspenseId++,
      timeout: typeof T == "number" ? T : -1,
      activeBranch: null,
      pendingBranch: null,
      isInFallback: !v,
      isHydrating: v,
      isUnmounted: !1,
      effects: [],
      resolve(F=!1, O=!1) {
          const {vnode: $, activeBranch: j, pendingBranch: K, pendingId: Y, effects: W, parentComponent: Z, container: ee} = M;
          let X = !1;
          M.isHydrating ? M.isHydrating = !1 : F || (X = j && K.transition && K.transition.mode === "out-in",
          X && (j.transition.afterLeave = ()=>{
              Y === M.pendingId && (b(K, ee, l === w ? x(j) : l, 0),
              queuePostFlushCb(W))
          }
          ),
          j && (E(j.el) !== M.hiddenContainer && (l = x(j)),
          P(j, Z, M, !0)),
          X || b(K, ee, l, 0)),
          setActiveBranch(M, K),
          M.pendingBranch = null,
          M.isInFallback = !1;
          let D = M.parent
            , B = !1;
          for (; D; ) {
              if (D.pendingBranch) {
                  D.effects.push(...W),
                  B = !0;
                  break
              }
              D = D.parent
          }
          !B && !X && queuePostFlushCb(W),
          M.effects = [],
          A && t && t.pendingBranch && C === t.pendingId && (t.deps--,
          t.deps === 0 && !O && t.resolve()),
          triggerEvent($, "onResolve")
      },
      fallback(F) {
          if (!M.pendingBranch)
              return;
          const {vnode: O, activeBranch: $, parentComponent: j, container: K, namespace: Y} = M;
          triggerEvent(O, "onFallback");
          const W = x($)
            , Z = ()=>{
              M.isInFallback && (S(null, F, K, W, j, null, Y, d, g),
              setActiveBranch(M, F))
          }
            , ee = F.transition && F.transition.mode === "out-in";
          ee && ($.transition.afterLeave = Z),
          M.isInFallback = !0,
          P($, j, null, !0),
          ee || Z()
      },
      move(F, O, $) {
          M.activeBranch && b(M.activeBranch, F, O, $),
          M.container = F
      },
      next() {
          return M.activeBranch && x(M.activeBranch)
      },
      registerDep(F, O) {
          const $ = !!M.pendingBranch;
          $ && M.deps++;
          const j = F.vnode.el;
          F.asyncDep.catch(K=>{
              handleError(K, F, 0)
          }
          ).then(K=>{
              if (F.isUnmounted || M.isUnmounted || M.pendingId !== F.suspenseId)
                  return;
              F.asyncResolved = !0;
              const {vnode: Y} = F;
              handleSetupResult(F, K, !1),
              j && (Y.el = j);
              const W = !j && F.subTree.el;
              O(F, Y, E(j || F.subTree.el), j ? null : x(F.subTree), M, f, g),
              W && I(W),
              updateHOCHostEl(F, Y.el),
              $ && --M.deps === 0 && M.resolve()
          }
          )
      },
      unmount(F, O) {
          M.isUnmounted = !0,
          M.activeBranch && P(M.activeBranch, r, F, O),
          M.pendingBranch && P(M.pendingBranch, r, F, O)
      }
  };
  return M
}
function hydrateSuspense(e, t, r, a, o, l, f, d, g) {
  const _ = t.suspense = createSuspenseBoundary(t, a, r, e.parentNode, document.createElement("div"), null, o, l, f, d, !0)
    , v = g(e, _.pendingBranch = t.ssContent, r, _, l, f);
  return _.deps === 0 && _.resolve(!1, !0),
  v
}
function normalizeSuspenseChildren(e) {
  const {shapeFlag: t, children: r} = e
    , a = t & 32;
  e.ssContent = normalizeSuspenseSlot(a ? r.default : r),
  e.ssFallback = a ? normalizeSuspenseSlot(r.fallback) : createVNode(Comment)
}
function normalizeSuspenseSlot(e) {
  let t;
  if (isFunction(e)) {
      const r = isBlockTreeEnabled && e._c;
      r && (e._d = !1,
      openBlock()),
      e = e(),
      r && (e._d = !0,
      t = currentBlock,
      closeBlock())
  }
  return isArray$1(e) && (e = filterSingleRoot(e)),
  e = normalizeVNode(e),
  t && !e.dynamicChildren && (e.dynamicChildren = t.filter(r=>r !== e)),
  e
}
function queueEffectWithSuspense(e, t) {
  t && t.pendingBranch ? isArray$1(e) ? t.effects.push(...e) : t.effects.push(e) : queuePostFlushCb(e)
}
function setActiveBranch(e, t) {
  e.activeBranch = t;
  const {vnode: r, parentComponent: a} = e;
  let o = t.el;
  for (; !o && t.component; )
      t = t.component.subTree,
      o = t.el;
  r.el = o,
  a && a.subTree === r && (a.vnode.el = o,
  updateHOCHostEl(a, o))
}
function isVNodeSuspensible(e) {
  var t;
  return ((t = e.props) == null ? void 0 : t.suspensible) != null && e.props.suspensible !== !1
}
const ssrContextKey = Symbol.for("v-scx")
, useSSRContext = ()=>inject(ssrContextKey);
function watchEffect(e, t) {
  return doWatch(e, null, t)
}
const INITIAL_WATCHER_VALUE = {};
function watch(e, t, r) {
  return doWatch(e, t, r)
}
function doWatch(e, t, {immediate: r, deep: a, flush: o, once: l, onTrack: f, onTrigger: d}=EMPTY_OBJ) {
  if (t && l) {
      const F = t;
      t = (...O)=>{
          F(...O),
          M()
      }
  }
  const g = currentInstance
    , _ = F=>a === !0 ? F : traverse(F, a === !1 ? 1 : void 0);
  let v, S = !1, b = !1;
  if (isRef(e) ? (v = ()=>e.value,
  S = isShallow(e)) : isReactive(e) ? (v = ()=>_(e),
  S = !0) : isArray$1(e) ? (b = !0,
  S = e.some(F=>isReactive(F) || isShallow(F)),
  v = ()=>e.map(F=>{
      if (isRef(F))
          return F.value;
      if (isReactive(F))
          return _(F);
      if (isFunction(F))
          return callWithErrorHandling(F, g, 2)
  }
  )) : isFunction(e) ? t ? v = ()=>callWithErrorHandling(e, g, 2) : v = ()=>(P && P(),
  callWithAsyncErrorHandling(e, g, 3, [x])) : v = NOOP,
  t && a) {
      const F = v;
      v = ()=>traverse(F())
  }
  let P, x = F=>{
      P = T.onStop = ()=>{
          callWithErrorHandling(F, g, 4),
          P = T.onStop = void 0
      }
  }
  , E;
  if (isInSSRComponentSetup)
      if (x = NOOP,
      t ? r && callWithAsyncErrorHandling(t, g, 3, [v(), b ? [] : void 0, x]) : v(),
      o === "sync") {
          const F = useSSRContext();
          E = F.__watcherHandles || (F.__watcherHandles = [])
      } else
          return NOOP;
  let I = b ? new Array(e.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const C = ()=>{
      if (!(!T.active || !T.dirty))
          if (t) {
              const F = T.run();
              (a || S || (b ? F.some((O,$)=>hasChanged(O, I[$])) : hasChanged(F, I))) && (P && P(),
              callWithAsyncErrorHandling(t, g, 3, [F, I === INITIAL_WATCHER_VALUE ? void 0 : b && I[0] === INITIAL_WATCHER_VALUE ? [] : I, x]),
              I = F)
          } else
              T.run()
  }
  ;
  C.allowRecurse = !!t;
  let A;
  o === "sync" ? A = C : o === "post" ? A = ()=>queuePostRenderEffect(C, g && g.suspense) : (C.pre = !0,
  g && (C.id = g.uid),
  A = ()=>queueJob(C));
  const T = new ReactiveEffect(v,NOOP,A)
    , w = getCurrentScope()
    , M = ()=>{
      T.stop(),
      w && remove(w.effects, T)
  }
  ;
  return t ? r ? C() : I = T.run() : o === "post" ? queuePostRenderEffect(T.run.bind(T), g && g.suspense) : T.run(),
  E && E.push(M),
  M
}
function instanceWatch(e, t, r) {
  const a = this.proxy
    , o = isString(e) ? e.includes(".") ? createPathGetter(a, e) : ()=>a[e] : e.bind(a, a);
  let l;
  isFunction(t) ? l = t : (l = t.handler,
  r = t);
  const f = setCurrentInstance(this)
    , d = doWatch(o, l.bind(a), r);
  return f(),
  d
}
function createPathGetter(e, t) {
  const r = t.split(".");
  return ()=>{
      let a = e;
      for (let o = 0; o < r.length && a; o++)
          a = a[r[o]];
      return a
  }
}
function traverse(e, t, r=0, a) {
  if (!isObject(e) || e.__v_skip)
      return e;
  if (t && t > 0) {
      if (r >= t)
          return e;
      r++
  }
  if (a = a || new Set,
  a.has(e))
      return e;
  if (a.add(e),
  isRef(e))
      traverse(e.value, t, r, a);
  else if (isArray$1(e))
      for (let o = 0; o < e.length; o++)
          traverse(e[o], t, r, a);
  else if (isSet(e) || isMap(e))
      e.forEach(o=>{
          traverse(o, t, r, a)
      }
      );
  else if (isPlainObject$1(e))
      for (const o in e)
          traverse(e[o], t, r, a);
  return e
}
function withDirectives(e, t) {
  if (currentRenderingInstance === null)
      return e;
  const r = getExposeProxy(currentRenderingInstance) || currentRenderingInstance.proxy
    , a = e.dirs || (e.dirs = []);
  for (let o = 0; o < t.length; o++) {
      let[l,f,d,g=EMPTY_OBJ] = t[o];
      l && (isFunction(l) && (l = {
          mounted: l,
          updated: l
      }),
      l.deep && traverse(f),
      a.push({
          dir: l,
          instance: r,
          value: f,
          oldValue: void 0,
          arg: d,
          modifiers: g
      }))
  }
  return e
}
function invokeDirectiveHook(e, t, r, a) {
  const o = e.dirs
    , l = t && t.dirs;
  for (let f = 0; f < o.length; f++) {
      const d = o[f];
      l && (d.oldValue = l[f].value);
      let g = d.dir[a];
      g && (pauseTracking(),
      callWithAsyncErrorHandling(g, r, 8, [e.el, d, e, t]),
      resetTracking())
  }
}
const leaveCbKey = Symbol("_leaveCb")
, enterCbKey = Symbol("_enterCb");
function useTransitionState() {
  const e = {
      isMounted: !1,
      isLeaving: !1,
      isUnmounting: !1,
      leavingVNodes: new Map
  };
  return onMounted(()=>{
      e.isMounted = !0
  }
  ),
  onBeforeUnmount(()=>{
      e.isUnmounting = !0
  }
  ),
  e
}
const TransitionHookValidator = [Function, Array]
, BaseTransitionPropsValidators = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  onBeforeEnter: TransitionHookValidator,
  onEnter: TransitionHookValidator,
  onAfterEnter: TransitionHookValidator,
  onEnterCancelled: TransitionHookValidator,
  onBeforeLeave: TransitionHookValidator,
  onLeave: TransitionHookValidator,
  onAfterLeave: TransitionHookValidator,
  onLeaveCancelled: TransitionHookValidator,
  onBeforeAppear: TransitionHookValidator,
  onAppear: TransitionHookValidator,
  onAfterAppear: TransitionHookValidator,
  onAppearCancelled: TransitionHookValidator
}
, BaseTransitionImpl = {
  name: "BaseTransition",
  props: BaseTransitionPropsValidators,
  setup(e, {slots: t}) {
      const r = getCurrentInstance()
        , a = useTransitionState();
      return ()=>{
          const o = t.default && getTransitionRawChildren(t.default(), !0);
          if (!o || !o.length)
              return;
          let l = o[0];
          if (o.length > 1) {
              for (const b of o)
                  if (b.type !== Comment) {
                      l = b;
                      break
                  }
          }
          const f = toRaw(e)
            , {mode: d} = f;
          if (a.isLeaving)
              return emptyPlaceholder(l);
          const g = getKeepAliveChild(l);
          if (!g)
              return emptyPlaceholder(l);
          const _ = resolveTransitionHooks(g, f, a, r);
          setTransitionHooks(g, _);
          const v = r.subTree
            , S = v && getKeepAliveChild(v);
          if (S && S.type !== Comment && !isSameVNodeType(g, S)) {
              const b = resolveTransitionHooks(S, f, a, r);
              if (setTransitionHooks(S, b),
              d === "out-in")
                  return a.isLeaving = !0,
                  b.afterLeave = ()=>{
                      a.isLeaving = !1,
                      r.update.active !== !1 && (r.effect.dirty = !0,
                      r.update())
                  }
                  ,
                  emptyPlaceholder(l);
              d === "in-out" && g.type !== Comment && (b.delayLeave = (P,x,E)=>{
                  const I = getLeavingNodesForType(a, S);
                  I[String(S.key)] = S,
                  P[leaveCbKey] = ()=>{
                      x(),
                      P[leaveCbKey] = void 0,
                      delete _.delayedLeave
                  }
                  ,
                  _.delayedLeave = E
              }
              )
          }
          return l
      }
  }
}
, BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(e, t) {
  const {leavingVNodes: r} = e;
  let a = r.get(t.type);
  return a || (a = Object.create(null),
  r.set(t.type, a)),
  a
}
function resolveTransitionHooks(e, t, r, a) {
  const {appear: o, mode: l, persisted: f=!1, onBeforeEnter: d, onEnter: g, onAfterEnter: _, onEnterCancelled: v, onBeforeLeave: S, onLeave: b, onAfterLeave: P, onLeaveCancelled: x, onBeforeAppear: E, onAppear: I, onAfterAppear: C, onAppearCancelled: A} = t
    , T = String(e.key)
    , w = getLeavingNodesForType(r, e)
    , M = ($,j)=>{
      $ && callWithAsyncErrorHandling($, a, 9, j)
  }
    , F = ($,j)=>{
      const K = j[1];
      M($, j),
      isArray$1($) ? $.every(Y=>Y.length <= 1) && K() : $.length <= 1 && K()
  }
    , O = {
      mode: l,
      persisted: f,
      beforeEnter($) {
          let j = d;
          if (!r.isMounted)
              if (o)
                  j = E || d;
              else
                  return;
          $[leaveCbKey] && $[leaveCbKey](!0);
          const K = w[T];
          K && isSameVNodeType(e, K) && K.el[leaveCbKey] && K.el[leaveCbKey](),
          M(j, [$])
      },
      enter($) {
          let j = g
            , K = _
            , Y = v;
          if (!r.isMounted)
              if (o)
                  j = I || g,
                  K = C || _,
                  Y = A || v;
              else
                  return;
          let W = !1;
          const Z = $[enterCbKey] = ee=>{
              W || (W = !0,
              ee ? M(Y, [$]) : M(K, [$]),
              O.delayedLeave && O.delayedLeave(),
              $[enterCbKey] = void 0)
          }
          ;
          j ? F(j, [$, Z]) : Z()
      },
      leave($, j) {
          const K = String(e.key);
          if ($[enterCbKey] && $[enterCbKey](!0),
          r.isUnmounting)
              return j();
          M(S, [$]);
          let Y = !1;
          const W = $[leaveCbKey] = Z=>{
              Y || (Y = !0,
              j(),
              Z ? M(x, [$]) : M(P, [$]),
              $[leaveCbKey] = void 0,
              w[K] === e && delete w[K])
          }
          ;
          w[K] = e,
          b ? F(b, [$, W]) : W()
      },
      clone($) {
          return resolveTransitionHooks($, t, r, a)
      }
  };
  return O
}
function emptyPlaceholder(e) {
  if (isKeepAlive(e))
      return e = cloneVNode(e),
      e.children = null,
      e
}
function getKeepAliveChild(e) {
  return isKeepAlive(e) ? e.children ? e.children[0] : void 0 : e
}
function setTransitionHooks(e, t) {
  e.shapeFlag & 6 && e.component ? setTransitionHooks(e.component.subTree, t) : e.shapeFlag & 128 ? (e.ssContent.transition = t.clone(e.ssContent),
  e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t
}
function getTransitionRawChildren(e, t=!1, r) {
  let a = []
    , o = 0;
  for (let l = 0; l < e.length; l++) {
      let f = e[l];
      const d = r == null ? f.key : String(r) + String(f.key != null ? f.key : l);
      f.type === Fragment ? (f.patchFlag & 128 && o++,
      a = a.concat(getTransitionRawChildren(f.children, t, d))) : (t || f.type !== Comment) && a.push(d != null ? cloneVNode(f, {
          key: d
      }) : f)
  }
  if (o > 1)
      for (let l = 0; l < a.length; l++)
          a[l].patchFlag = -2;
  return a
}
/*! #__NO_SIDE_EFFECTS__ */
function defineComponent(e, t) {
  return isFunction(e) ? extend({
      name: e.name
  }, t, {
      setup: e
  }) : e
}
const isAsyncWrapper = e=>!!e.type.__asyncLoader
, isKeepAlive = e=>e.type.__isKeepAlive
, KeepAliveImpl = {
  name: "KeepAlive",
  __isKeepAlive: !0,
  props: {
      include: [String, RegExp, Array],
      exclude: [String, RegExp, Array],
      max: [String, Number]
  },
  setup(e, {slots: t}) {
      const r = getCurrentInstance()
        , a = r.ctx;
      if (!a.renderer)
          return ()=>{
              const A = t.default && t.default();
              return A && A.length === 1 ? A[0] : A
          }
          ;
      const o = new Map
        , l = new Set;
      let f = null;
      const d = r.suspense
        , {renderer: {p: g, m: _, um: v, o: {createElement: S}}} = a
        , b = S("div");
      a.activate = (A,T,w,M,F)=>{
          const O = A.component;
          _(A, T, w, 0, d),
          g(O.vnode, A, T, w, O, d, M, A.slotScopeIds, F),
          queuePostRenderEffect(()=>{
              O.isDeactivated = !1,
              O.a && invokeArrayFns(O.a);
              const $ = A.props && A.props.onVnodeMounted;
              $ && invokeVNodeHook($, O.parent, A)
          }
          , d)
      }
      ,
      a.deactivate = A=>{
          const T = A.component;
          _(A, b, null, 1, d),
          queuePostRenderEffect(()=>{
              T.da && invokeArrayFns(T.da);
              const w = A.props && A.props.onVnodeUnmounted;
              w && invokeVNodeHook(w, T.parent, A),
              T.isDeactivated = !0
          }
          , d)
      }
      ;
      function P(A) {
          resetShapeFlag(A),
          v(A, r, d, !0)
      }
      function x(A) {
          o.forEach((T,w)=>{
              const M = getComponentName(T.type);
              M && (!A || !A(M)) && E(w)
          }
          )
      }
      function E(A) {
          const T = o.get(A);
          !f || !isSameVNodeType(T, f) ? P(T) : f && resetShapeFlag(f),
          o.delete(A),
          l.delete(A)
      }
      watch(()=>[e.include, e.exclude], ([A,T])=>{
          A && x(w=>matches(A, w)),
          T && x(w=>!matches(T, w))
      }
      , {
          flush: "post",
          deep: !0
      });
      let I = null;
      const C = ()=>{
          I != null && o.set(I, getInnerChild(r.subTree))
      }
      ;
      return onMounted(C),
      onUpdated(C),
      onBeforeUnmount(()=>{
          o.forEach(A=>{
              const {subTree: T, suspense: w} = r
                , M = getInnerChild(T);
              if (A.type === M.type && A.key === M.key) {
                  resetShapeFlag(M);
                  const F = M.component.da;
                  F && queuePostRenderEffect(F, w);
                  return
              }
              P(A)
          }
          )
      }
      ),
      ()=>{
          if (I = null,
          !t.default)
              return null;
          const A = t.default()
            , T = A[0];
          if (A.length > 1)
              return f = null,
              A;
          if (!isVNode(T) || !(T.shapeFlag & 4) && !(T.shapeFlag & 128))
              return f = null,
              T;
          let w = getInnerChild(T);
          const M = w.type
            , F = getComponentName(isAsyncWrapper(w) ? w.type.__asyncResolved || {} : M)
            , {include: O, exclude: $, max: j} = e;
          if (O && (!F || !matches(O, F)) || $ && F && matches($, F))
              return f = w,
              T;
          const K = w.key == null ? M : w.key
            , Y = o.get(K);
          return w.el && (w = cloneVNode(w),
          T.shapeFlag & 128 && (T.ssContent = w)),
          I = K,
          Y ? (w.el = Y.el,
          w.component = Y.component,
          w.transition && setTransitionHooks(w, w.transition),
          w.shapeFlag |= 512,
          l.delete(K),
          l.add(K)) : (l.add(K),
          j && l.size > parseInt(j, 10) && E(l.values().next().value)),
          w.shapeFlag |= 256,
          f = w,
          isSuspense(T.type) ? T : w
      }
  }
}
, KeepAlive = KeepAliveImpl;
function matches(e, t) {
  return isArray$1(e) ? e.some(r=>matches(r, t)) : isString(e) ? e.split(",").includes(t) : isRegExp(e) ? e.test(t) : !1
}
function onActivated(e, t) {
  registerKeepAliveHook(e, "a", t)
}
function onDeactivated(e, t) {
  registerKeepAliveHook(e, "da", t)
}
function registerKeepAliveHook(e, t, r=currentInstance) {
  const a = e.__wdc || (e.__wdc = ()=>{
      let o = r;
      for (; o; ) {
          if (o.isDeactivated)
              return;
          o = o.parent
      }
      return e()
  }
  );
  if (injectHook(t, a, r),
  r) {
      let o = r.parent;
      for (; o && o.parent; )
          isKeepAlive(o.parent.vnode) && injectToKeepAliveRoot(a, t, r, o),
          o = o.parent
  }
}
function injectToKeepAliveRoot(e, t, r, a) {
  const o = injectHook(t, e, a, !0);
  onUnmounted(()=>{
      remove(a[t], o)
  }
  , r)
}
function resetShapeFlag(e) {
  e.shapeFlag &= -257,
  e.shapeFlag &= -513
}
function getInnerChild(e) {
  return e.shapeFlag & 128 ? e.ssContent : e
}
function injectHook(e, t, r=currentInstance, a=!1) {
  if (r) {
      const o = r[e] || (r[e] = [])
        , l = t.__weh || (t.__weh = (...f)=>{
          if (r.isUnmounted)
              return;
          pauseTracking();
          const d = setCurrentInstance(r)
            , g = callWithAsyncErrorHandling(t, r, e, f);
          return d(),
          resetTracking(),
          g
      }
      );
      return a ? o.unshift(l) : o.push(l),
      l
  }
}
const createHook = e=>(t,r=currentInstance)=>(!isInSSRComponentSetup || e === "sp") && injectHook(e, (...a)=>t(...a), r)
, onBeforeMount = createHook("bm")
, onMounted = createHook("m")
, onBeforeUpdate = createHook("bu")
, onUpdated = createHook("u")
, onBeforeUnmount = createHook("bum")
, onUnmounted = createHook("um")
, onServerPrefetch = createHook("sp")
, onRenderTriggered = createHook("rtg")
, onRenderTracked = createHook("rtc");
function onErrorCaptured(e, t=currentInstance) {
  injectHook("ec", e, t)
}
function renderList(e, t, r, a) {
  let o;
  const l = r && r[a];
  if (isArray$1(e) || isString(e)) {
      o = new Array(e.length);
      for (let f = 0, d = e.length; f < d; f++)
          o[f] = t(e[f], f, void 0, l && l[f])
  } else if (typeof e == "number") {
      o = new Array(e);
      for (let f = 0; f < e; f++)
          o[f] = t(f + 1, f, void 0, l && l[f])
  } else if (isObject(e))
      if (e[Symbol.iterator])
          o = Array.from(e, (f,d)=>t(f, d, void 0, l && l[d]));
      else {
          const f = Object.keys(e);
          o = new Array(f.length);
          for (let d = 0, g = f.length; d < g; d++) {
              const _ = f[d];
              o[d] = t(e[_], _, d, l && l[d])
          }
      }
  else
      o = [];
  return r && (r[a] = o),
  o
}
function renderSlot(e, t, r={}, a, o) {
  if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE)
      return t !== "default" && (r.name = t),
      createVNode("slot", r, a && a());
  let l = e[t];
  l && l._c && (l._d = !1),
  openBlock();
  const f = l && ensureValidVNode(l(r))
    , d = createBlock(Fragment, {
      key: r.key || f && f.key || `_${t}`
  }, f || (a ? a() : []), f && e._ === 1 ? 64 : -2);
  return !o && d.scopeId && (d.slotScopeIds = [d.scopeId + "-s"]),
  l && l._c && (l._d = !0),
  d
}
function ensureValidVNode(e) {
  return e.some(t=>isVNode(t) ? !(t.type === Comment || t.type === Fragment && !ensureValidVNode(t.children)) : !0) ? e : null
}
const getPublicInstance = e=>e ? isStatefulComponent(e) ? getExposeProxy(e) || e.proxy : getPublicInstance(e.parent) : null
, publicPropertiesMap = extend(Object.create(null), {
  $: e=>e,
  $el: e=>e.vnode.el,
  $data: e=>e.data,
  $props: e=>e.props,
  $attrs: e=>e.attrs,
  $slots: e=>e.slots,
  $refs: e=>e.refs,
  $parent: e=>getPublicInstance(e.parent),
  $root: e=>getPublicInstance(e.root),
  $emit: e=>e.emit,
  $options: e=>resolveMergedOptions(e),
  $forceUpdate: e=>e.f || (e.f = ()=>{
      e.effect.dirty = !0,
      queueJob(e.update)
  }
  ),
  $nextTick: e=>e.n || (e.n = nextTick.bind(e.proxy)),
  $watch: e=>instanceWatch.bind(e)
})
, hasSetupBinding = (e,t)=>e !== EMPTY_OBJ && !e.__isScriptSetup && hasOwn(e, t)
, PublicInstanceProxyHandlers = {
  get({_: e}, t) {
      const {ctx: r, setupState: a, data: o, props: l, accessCache: f, type: d, appContext: g} = e;
      let _;
      if (t[0] !== "$") {
          const P = f[t];
          if (P !== void 0)
              switch (P) {
              case 1:
                  return a[t];
              case 2:
                  return o[t];
              case 4:
                  return r[t];
              case 3:
                  return l[t]
              }
          else {
              if (hasSetupBinding(a, t))
                  return f[t] = 1,
                  a[t];
              if (o !== EMPTY_OBJ && hasOwn(o, t))
                  return f[t] = 2,
                  o[t];
              if ((_ = e.propsOptions[0]) && hasOwn(_, t))
                  return f[t] = 3,
                  l[t];
              if (r !== EMPTY_OBJ && hasOwn(r, t))
                  return f[t] = 4,
                  r[t];
              shouldCacheAccess && (f[t] = 0)
          }
      }
      const v = publicPropertiesMap[t];
      let S, b;
      if (v)
          return t === "$attrs" && track(e, "get", t),
          v(e);
      if ((S = d.__cssModules) && (S = S[t]))
          return S;
      if (r !== EMPTY_OBJ && hasOwn(r, t))
          return f[t] = 4,
          r[t];
      if (b = g.config.globalProperties,
      hasOwn(b, t))
          return b[t]
  },
  set({_: e}, t, r) {
      const {data: a, setupState: o, ctx: l} = e;
      return hasSetupBinding(o, t) ? (o[t] = r,
      !0) : a !== EMPTY_OBJ && hasOwn(a, t) ? (a[t] = r,
      !0) : hasOwn(e.props, t) || t[0] === "$" && t.slice(1)in e ? !1 : (l[t] = r,
      !0)
  },
  has({_: {data: e, setupState: t, accessCache: r, ctx: a, appContext: o, propsOptions: l}}, f) {
      let d;
      return !!r[f] || e !== EMPTY_OBJ && hasOwn(e, f) || hasSetupBinding(t, f) || (d = l[0]) && hasOwn(d, f) || hasOwn(a, f) || hasOwn(publicPropertiesMap, f) || hasOwn(o.config.globalProperties, f)
  },
  defineProperty(e, t, r) {
      return r.get != null ? e._.accessCache[t] = 0 : hasOwn(r, "value") && this.set(e, t, r.value, null),
      Reflect.defineProperty(e, t, r)
  }
};
function normalizePropsOrEmits(e) {
  return isArray$1(e) ? e.reduce((t,r)=>(t[r] = null,
  t), {}) : e
}
function withAsyncContext(e) {
  const t = getCurrentInstance();
  let r = e();
  return unsetCurrentInstance(),
  isPromise(r) && (r = r.catch(a=>{
      throw setCurrentInstance(t),
      a
  }
  )),
  [r, ()=>setCurrentInstance(t)]
}
let shouldCacheAccess = !0;
function applyOptions(e) {
  const t = resolveMergedOptions(e)
    , r = e.proxy
    , a = e.ctx;
  shouldCacheAccess = !1,
  t.beforeCreate && callHook$1(t.beforeCreate, e, "bc");
  const {data: o, computed: l, methods: f, watch: d, provide: g, inject: _, created: v, beforeMount: S, mounted: b, beforeUpdate: P, updated: x, activated: E, deactivated: I, beforeDestroy: C, beforeUnmount: A, destroyed: T, unmounted: w, render: M, renderTracked: F, renderTriggered: O, errorCaptured: $, serverPrefetch: j, expose: K, inheritAttrs: Y, components: W, directives: Z, filters: ee} = t;
  if (_ && resolveInjections(_, a, null),
  f)
      for (const B in f) {
          const R = f[B];
          isFunction(R) && (a[B] = R.bind(r))
      }
  if (o) {
      const B = o.call(r, r);
      isObject(B) && (e.data = reactive(B))
  }
  if (shouldCacheAccess = !0,
  l)
      for (const B in l) {
          const R = l[B]
            , L = isFunction(R) ? R.bind(r, r) : isFunction(R.get) ? R.get.bind(r, r) : NOOP
            , V = !isFunction(R) && isFunction(R.set) ? R.set.bind(r) : NOOP
            , q = computed({
              get: L,
              set: V
          });
          Object.defineProperty(a, B, {
              enumerable: !0,
              configurable: !0,
              get: ()=>q.value,
              set: oe=>q.value = oe
          })
      }
  if (d)
      for (const B in d)
          createWatcher(d[B], a, r, B);
  if (g) {
      const B = isFunction(g) ? g.call(r) : g;
      Reflect.ownKeys(B).forEach(R=>{
          provide(R, B[R])
      }
      )
  }
  v && callHook$1(v, e, "c");
  function D(B, R) {
      isArray$1(R) ? R.forEach(L=>B(L.bind(r))) : R && B(R.bind(r))
  }
  if (D(onBeforeMount, S),
  D(onMounted, b),
  D(onBeforeUpdate, P),
  D(onUpdated, x),
  D(onActivated, E),
  D(onDeactivated, I),
  D(onErrorCaptured, $),
  D(onRenderTracked, F),
  D(onRenderTriggered, O),
  D(onBeforeUnmount, A),
  D(onUnmounted, w),
  D(onServerPrefetch, j),
  isArray$1(K))
      if (K.length) {
          const B = e.exposed || (e.exposed = {});
          K.forEach(R=>{
              Object.defineProperty(B, R, {
                  get: ()=>r[R],
                  set: L=>r[R] = L
              })
          }
          )
      } else
          e.exposed || (e.exposed = {});
  M && e.render === NOOP && (e.render = M),
  Y != null && (e.inheritAttrs = Y),
  W && (e.components = W),
  Z && (e.directives = Z)
}
function resolveInjections(e, t, r=NOOP) {
  isArray$1(e) && (e = normalizeInject(e));
  for (const a in e) {
      const o = e[a];
      let l;
      isObject(o) ? "default"in o ? l = inject(o.from || a, o.default, !0) : l = inject(o.from || a) : l = inject(o),
      isRef(l) ? Object.defineProperty(t, a, {
          enumerable: !0,
          configurable: !0,
          get: ()=>l.value,
          set: f=>l.value = f
      }) : t[a] = l
  }
}
function callHook$1(e, t, r) {
  callWithAsyncErrorHandling(isArray$1(e) ? e.map(a=>a.bind(t.proxy)) : e.bind(t.proxy), t, r)
}
function createWatcher(e, t, r, a) {
  const o = a.includes(".") ? createPathGetter(r, a) : ()=>r[a];
  if (isString(e)) {
      const l = t[e];
      isFunction(l) && watch(o, l)
  } else if (isFunction(e))
      watch(o, e.bind(r));
  else if (isObject(e))
      if (isArray$1(e))
          e.forEach(l=>createWatcher(l, t, r, a));
      else {
          const l = isFunction(e.handler) ? e.handler.bind(r) : t[e.handler];
          isFunction(l) && watch(o, l, e)
      }
}
function resolveMergedOptions(e) {
  const t = e.type
    , {mixins: r, extends: a} = t
    , {mixins: o, optionsCache: l, config: {optionMergeStrategies: f}} = e.appContext
    , d = l.get(t);
  let g;
  return d ? g = d : !o.length && !r && !a ? g = t : (g = {},
  o.length && o.forEach(_=>mergeOptions$1(g, _, f, !0)),
  mergeOptions$1(g, t, f)),
  isObject(t) && l.set(t, g),
  g
}
function mergeOptions$1(e, t, r, a=!1) {
  const {mixins: o, extends: l} = t;
  l && mergeOptions$1(e, l, r, !0),
  o && o.forEach(f=>mergeOptions$1(e, f, r, !0));
  for (const f in t)
      if (!(a && f === "expose")) {
          const d = internalOptionMergeStrats[f] || r && r[f];
          e[f] = d ? d(e[f], t[f]) : t[f]
      }
  return e
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeEmitsOrPropsOptions,
  emits: mergeEmitsOrPropsOptions,
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  watch: mergeWatchOptions,
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(e, t) {
  return t ? e ? function() {
      return extend(isFunction(e) ? e.call(this, this) : e, isFunction(t) ? t.call(this, this) : t)
  }
  : t : e
}
function mergeInject(e, t) {
  return mergeObjectOptions(normalizeInject(e), normalizeInject(t))
}
function normalizeInject(e) {
  if (isArray$1(e)) {
      const t = {};
      for (let r = 0; r < e.length; r++)
          t[e[r]] = e[r];
      return t
  }
  return e
}
function mergeAsArray(e, t) {
  return e ? [...new Set([].concat(e, t))] : t
}
function mergeObjectOptions(e, t) {
  return e ? extend(Object.create(null), e, t) : t
}
function mergeEmitsOrPropsOptions(e, t) {
  return e ? isArray$1(e) && isArray$1(t) ? [...new Set([...e, ...t])] : extend(Object.create(null), normalizePropsOrEmits(e), normalizePropsOrEmits(t ?? {})) : t
}
function mergeWatchOptions(e, t) {
  if (!e)
      return t;
  if (!t)
      return e;
  const r = extend(Object.create(null), e);
  for (const a in t)
      r[a] = mergeAsArray(e[a], t[a]);
  return r
}
function createAppContext() {
  return {
      app: null,
      config: {
          isNativeTag: NO,
          performance: !1,
          globalProperties: {},
          optionMergeStrategies: {},
          errorHandler: void 0,
          warnHandler: void 0,
          compilerOptions: {}
      },
      mixins: [],
      components: {},
      directives: {},
      provides: Object.create(null),
      optionsCache: new WeakMap,
      propsCache: new WeakMap,
      emitsCache: new WeakMap
  }
}
let uid$1 = 0;
function createAppAPI(e, t) {
  return function(a, o=null) {
      isFunction(a) || (a = extend({}, a)),
      o != null && !isObject(o) && (o = null);
      const l = createAppContext()
        , f = new WeakSet;
      let d = !1;
      const g = l.app = {
          _uid: uid$1++,
          _component: a,
          _props: o,
          _container: null,
          _context: l,
          _instance: null,
          version,
          get config() {
              return l.config
          },
          set config(_) {},
          use(_, ...v) {
              return f.has(_) || (_ && isFunction(_.install) ? (f.add(_),
              _.install(g, ...v)) : isFunction(_) && (f.add(_),
              _(g, ...v))),
              g
          },
          mixin(_) {
              return l.mixins.includes(_) || l.mixins.push(_),
              g
          },
          component(_, v) {
              return v ? (l.components[_] = v,
              g) : l.components[_]
          },
          directive(_, v) {
              return v ? (l.directives[_] = v,
              g) : l.directives[_]
          },
          mount(_, v, S) {
              if (!d) {
                  const b = createVNode(a, o);
                  return b.appContext = l,
                  S === !0 ? S = "svg" : S === !1 && (S = void 0),
                  v && t ? t(b, _) : e(b, _, S),
                  d = !0,
                  g._container = _,
                  _.__vue_app__ = g,
                  getExposeProxy(b.component) || b.component.proxy
              }
          },
          unmount() {
              d && (e(null, g._container),
              delete g._container.__vue_app__)
          },
          provide(_, v) {
              return l.provides[_] = v,
              g
          },
          runWithContext(_) {
              const v = currentApp;
              currentApp = g;
              try {
                  return _()
              } finally {
                  currentApp = v
              }
          }
      };
      return g
  }
}
let currentApp = null;
function provide(e, t) {
  if (currentInstance) {
      let r = currentInstance.provides;
      const a = currentInstance.parent && currentInstance.parent.provides;
      a === r && (r = currentInstance.provides = Object.create(a)),
      r[e] = t
  }
}
function inject(e, t, r=!1) {
  const a = currentInstance || currentRenderingInstance;
  if (a || currentApp) {
      const o = a ? a.parent == null ? a.vnode.appContext && a.vnode.appContext.provides : a.parent.provides : currentApp._context.provides;
      if (o && e in o)
          return o[e];
      if (arguments.length > 1)
          return r && isFunction(t) ? t.call(a && a.proxy) : t
  }
}
function hasInjectionContext() {
  return !!(currentInstance || currentRenderingInstance || currentApp)
}
function initProps(e, t, r, a=!1) {
  const o = {}
    , l = {};
  def(l, InternalObjectKey, 1),
  e.propsDefaults = Object.create(null),
  setFullProps(e, t, o, l);
  for (const f in e.propsOptions[0])
      f in o || (o[f] = void 0);
  r ? e.props = a ? o : shallowReactive(o) : e.type.props ? e.props = o : e.props = l,
  e.attrs = l
}
function updateProps(e, t, r, a) {
  const {props: o, attrs: l, vnode: {patchFlag: f}} = e
    , d = toRaw(o)
    , [g] = e.propsOptions;
  let _ = !1;
  if ((a || f > 0) && !(f & 16)) {
      if (f & 8) {
          const v = e.vnode.dynamicProps;
          for (let S = 0; S < v.length; S++) {
              let b = v[S];
              if (isEmitListener(e.emitsOptions, b))
                  continue;
              const P = t[b];
              if (g)
                  if (hasOwn(l, b))
                      P !== l[b] && (l[b] = P,
                      _ = !0);
                  else {
                      const x = camelize(b);
                      o[x] = resolvePropValue(g, d, x, P, e, !1)
                  }
              else
                  P !== l[b] && (l[b] = P,
                  _ = !0)
          }
      }
  } else {
      setFullProps(e, t, o, l) && (_ = !0);
      let v;
      for (const S in d)
          (!t || !hasOwn(t, S) && ((v = hyphenate(S)) === S || !hasOwn(t, v))) && (g ? r && (r[S] !== void 0 || r[v] !== void 0) && (o[S] = resolvePropValue(g, d, S, void 0, e, !0)) : delete o[S]);
      if (l !== d)
          for (const S in l)
              (!t || !hasOwn(t, S)) && (delete l[S],
              _ = !0)
  }
  _ && trigger(e, "set", "$attrs")
}
function setFullProps(e, t, r, a) {
  const [o,l] = e.propsOptions;
  let f = !1, d;
  if (t)
      for (let g in t) {
          if (isReservedProp(g))
              continue;
          const _ = t[g];
          let v;
          o && hasOwn(o, v = camelize(g)) ? !l || !l.includes(v) ? r[v] = _ : (d || (d = {}))[v] = _ : isEmitListener(e.emitsOptions, g) || (!(g in a) || _ !== a[g]) && (a[g] = _,
          f = !0)
      }
  if (l) {
      const g = toRaw(r)
        , _ = d || EMPTY_OBJ;
      for (let v = 0; v < l.length; v++) {
          const S = l[v];
          r[S] = resolvePropValue(o, g, S, _[S], e, !hasOwn(_, S))
      }
  }
  return f
}
function resolvePropValue(e, t, r, a, o, l) {
  const f = e[r];
  if (f != null) {
      const d = hasOwn(f, "default");
      if (d && a === void 0) {
          const g = f.default;
          if (f.type !== Function && !f.skipFactory && isFunction(g)) {
              const {propsDefaults: _} = o;
              if (r in _)
                  a = _[r];
              else {
                  const v = setCurrentInstance(o);
                  a = _[r] = g.call(null, t),
                  v()
              }
          } else
              a = g
      }
      f[0] && (l && !d ? a = !1 : f[1] && (a === "" || a === hyphenate(r)) && (a = !0))
  }
  return a
}
function normalizePropsOptions(e, t, r=!1) {
  const a = t.propsCache
    , o = a.get(e);
  if (o)
      return o;
  const l = e.props
    , f = {}
    , d = [];
  let g = !1;
  if (!isFunction(e)) {
      const v = S=>{
          g = !0;
          const [b,P] = normalizePropsOptions(S, t, !0);
          extend(f, b),
          P && d.push(...P)
      }
      ;
      !r && t.mixins.length && t.mixins.forEach(v),
      e.extends && v(e.extends),
      e.mixins && e.mixins.forEach(v)
  }
  if (!l && !g)
      return isObject(e) && a.set(e, EMPTY_ARR),
      EMPTY_ARR;
  if (isArray$1(l))
      for (let v = 0; v < l.length; v++) {
          const S = camelize(l[v]);
          validatePropName(S) && (f[S] = EMPTY_OBJ)
      }
  else if (l)
      for (const v in l) {
          const S = camelize(v);
          if (validatePropName(S)) {
              const b = l[v]
                , P = f[S] = isArray$1(b) || isFunction(b) ? {
                  type: b
              } : extend({}, b);
              if (P) {
                  const x = getTypeIndex(Boolean, P.type)
                    , E = getTypeIndex(String, P.type);
                  P[0] = x > -1,
                  P[1] = E < 0 || x < E,
                  (x > -1 || hasOwn(P, "default")) && d.push(S)
              }
          }
      }
  const _ = [f, d];
  return isObject(e) && a.set(e, _),
  _
}
function validatePropName(e) {
  return e[0] !== "$" && !isReservedProp(e)
}
function getType(e) {
  return e === null ? "null" : typeof e == "function" ? e.name || "" : typeof e == "object" && e.constructor && e.constructor.name || ""
}
function isSameType(e, t) {
  return getType(e) === getType(t)
}
function getTypeIndex(e, t) {
  return isArray$1(t) ? t.findIndex(r=>isSameType(r, e)) : isFunction(t) && isSameType(t, e) ? 0 : -1
}
const isInternalKey = e=>e[0] === "_" || e === "$stable"
, normalizeSlotValue = e=>isArray$1(e) ? e.map(normalizeVNode) : [normalizeVNode(e)]
, normalizeSlot$1 = (e,t,r)=>{
  if (t._n)
      return t;
  const a = withCtx((...o)=>normalizeSlotValue(t(...o)), r);
  return a._c = !1,
  a
}
, normalizeObjectSlots = (e,t,r)=>{
  const a = e._ctx;
  for (const o in e) {
      if (isInternalKey(o))
          continue;
      const l = e[o];
      if (isFunction(l))
          t[o] = normalizeSlot$1(o, l, a);
      else if (l != null) {
          const f = normalizeSlotValue(l);
          t[o] = ()=>f
      }
  }
}
, normalizeVNodeSlots = (e,t)=>{
  const r = normalizeSlotValue(t);
  e.slots.default = ()=>r
}
, initSlots = (e,t)=>{
  if (e.vnode.shapeFlag & 32) {
      const r = t._;
      r ? (e.slots = toRaw(t),
      def(t, "_", r)) : normalizeObjectSlots(t, e.slots = {})
  } else
      e.slots = {},
      t && normalizeVNodeSlots(e, t);
  def(e.slots, InternalObjectKey, 1)
}
, updateSlots = (e,t,r)=>{
  const {vnode: a, slots: o} = e;
  let l = !0
    , f = EMPTY_OBJ;
  if (a.shapeFlag & 32) {
      const d = t._;
      d ? r && d === 1 ? l = !1 : (extend(o, t),
      !r && d === 1 && delete o._) : (l = !t.$stable,
      normalizeObjectSlots(t, o)),
      f = t
  } else
      t && (normalizeVNodeSlots(e, t),
      f = {
          default: 1
      });
  if (l)
      for (const d in o)
          !isInternalKey(d) && f[d] == null && delete o[d]
}
;
function setRef(e, t, r, a, o=!1) {
  if (isArray$1(e)) {
      e.forEach((b,P)=>setRef(b, t && (isArray$1(t) ? t[P] : t), r, a, o));
      return
  }
  if (isAsyncWrapper(a) && !o)
      return;
  const l = a.shapeFlag & 4 ? getExposeProxy(a.component) || a.component.proxy : a.el
    , f = o ? null : l
    , {i: d, r: g} = e
    , _ = t && t.r
    , v = d.refs === EMPTY_OBJ ? d.refs = {} : d.refs
    , S = d.setupState;
  if (_ != null && _ !== g && (isString(_) ? (v[_] = null,
  hasOwn(S, _) && (S[_] = null)) : isRef(_) && (_.value = null)),
  isFunction(g))
      callWithErrorHandling(g, d, 12, [f, v]);
  else {
      const b = isString(g)
        , P = isRef(g);
      if (b || P) {
          const x = ()=>{
              if (e.f) {
                  const E = b ? hasOwn(S, g) ? S[g] : v[g] : g.value;
                  o ? isArray$1(E) && remove(E, l) : isArray$1(E) ? E.includes(l) || E.push(l) : b ? (v[g] = [l],
                  hasOwn(S, g) && (S[g] = v[g])) : (g.value = [l],
                  e.k && (v[e.k] = g.value))
              } else
                  b ? (v[g] = f,
                  hasOwn(S, g) && (S[g] = f)) : P && (g.value = f,
                  e.k && (v[e.k] = f))
          }
          ;
          f ? (x.id = -1,
          queuePostRenderEffect(x, r)) : x()
      }
  }
}
let hasMismatch = !1;
const isSVGContainer = e=>e.namespaceURI.includes("svg") && e.tagName !== "foreignObject"
, isMathMLContainer = e=>e.namespaceURI.includes("MathML")
, getContainerType = e=>{
  if (isSVGContainer(e))
      return "svg";
  if (isMathMLContainer(e))
      return "mathml"
}
, isComment = e=>e.nodeType === 8;
function createHydrationFunctions(e) {
  const {mt: t, p: r, o: {patchProp: a, createText: o, nextSibling: l, parentNode: f, remove: d, insert: g, createComment: _}} = e
    , v = (T,w)=>{
      if (!w.hasChildNodes()) {
          r(null, T, w),
          flushPostFlushCbs(),
          w._vnode = T;
          return
      }
      hasMismatch = !1,
      S(w.firstChild, T, null, null, null),
      flushPostFlushCbs(),
      w._vnode = T,
      hasMismatch && console.error("Hydration completed but contains mismatches.")
  }
    , S = (T,w,M,F,O,$=!1)=>{
      const j = isComment(T) && T.data === "["
        , K = ()=>E(T, w, M, F, O, j)
        , {type: Y, ref: W, shapeFlag: Z, patchFlag: ee} = w;
      let X = T.nodeType;
      w.el = T,
      ee === -2 && ($ = !1,
      w.dynamicChildren = null);
      let D = null;
      switch (Y) {
      case Text:
          X !== 3 ? w.children === "" ? (g(w.el = o(""), f(T), T),
          D = T) : D = K() : (T.data !== w.children && (hasMismatch = !0,
          T.data = w.children),
          D = l(T));
          break;
      case Comment:
          A(T) ? (D = l(T),
          C(w.el = T.content.firstChild, T, M)) : X !== 8 || j ? D = K() : D = l(T);
          break;
      case Static:
          if (j && (T = l(T),
          X = T.nodeType),
          X === 1 || X === 3) {
              D = T;
              const B = !w.children.length;
              for (let R = 0; R < w.staticCount; R++)
                  B && (w.children += D.nodeType === 1 ? D.outerHTML : D.data),
                  R === w.staticCount - 1 && (w.anchor = D),
                  D = l(D);
              return j ? l(D) : D
          } else
              K();
          break;
      case Fragment:
          j ? D = x(T, w, M, F, O, $) : D = K();
          break;
      default:
          if (Z & 1)
              (X !== 1 || w.type.toLowerCase() !== T.tagName.toLowerCase()) && !A(T) ? D = K() : D = b(T, w, M, F, O, $);
          else if (Z & 6) {
              w.slotScopeIds = O;
              const B = f(T);
              if (j ? D = I(T) : isComment(T) && T.data === "teleport start" ? D = I(T, T.data, "teleport end") : D = l(T),
              t(w, B, null, M, F, getContainerType(B), $),
              isAsyncWrapper(w)) {
                  let R;
                  j ? (R = createVNode(Fragment),
                  R.anchor = D ? D.previousSibling : B.lastChild) : R = T.nodeType === 3 ? createTextVNode("") : createVNode("div"),
                  R.el = T,
                  w.component.subTree = R
              }
          } else
              Z & 64 ? X !== 8 ? D = K() : D = w.type.hydrate(T, w, M, F, O, $, e, P) : Z & 128 && (D = w.type.hydrate(T, w, M, F, getContainerType(f(T)), O, $, e, S))
      }
      return W != null && setRef(W, null, F, w),
      D
  }
    , b = (T,w,M,F,O,$)=>{
      $ = $ || !!w.dynamicChildren;
      const {type: j, props: K, patchFlag: Y, shapeFlag: W, dirs: Z, transition: ee} = w
        , X = j === "input" || j === "option";
      if (X || Y !== -1) {
          Z && invokeDirectiveHook(w, null, M, "created");
          let D = !1;
          if (A(T)) {
              D = needTransition(F, ee) && M && M.vnode.props && M.vnode.props.appear;
              const R = T.content.firstChild;
              D && ee.beforeEnter(R),
              C(R, T, M),
              w.el = T = R
          }
          if (W & 16 && !(K && (K.innerHTML || K.textContent))) {
              let R = P(T.firstChild, w, T, M, F, O, $);
              for (; R; ) {
                  hasMismatch = !0;
                  const L = R;
                  R = R.nextSibling,
                  d(L)
              }
          } else
              W & 8 && T.textContent !== w.children && (hasMismatch = !0,
              T.textContent = w.children);
          if (K)
              if (X || !$ || Y & 48)
                  for (const R in K)
                      (X && (R.endsWith("value") || R === "indeterminate") || isOn(R) && !isReservedProp(R) || R[0] === ".") && a(T, R, null, K[R], void 0, void 0, M);
              else
                  K.onClick && a(T, "onClick", null, K.onClick, void 0, void 0, M);
          let B;
          (B = K && K.onVnodeBeforeMount) && invokeVNodeHook(B, M, w),
          Z && invokeDirectiveHook(w, null, M, "beforeMount"),
          ((B = K && K.onVnodeMounted) || Z || D) && queueEffectWithSuspense(()=>{
              B && invokeVNodeHook(B, M, w),
              D && ee.enter(T),
              Z && invokeDirectiveHook(w, null, M, "mounted")
          }
          , F)
      }
      return T.nextSibling
  }
    , P = (T,w,M,F,O,$,j)=>{
      j = j || !!w.dynamicChildren;
      const K = w.children
        , Y = K.length;
      for (let W = 0; W < Y; W++) {
          const Z = j ? K[W] : K[W] = normalizeVNode(K[W]);
          if (T)
              T = S(T, Z, F, O, $, j);
          else {
              if (Z.type === Text && !Z.children)
                  continue;
              hasMismatch = !0,
              r(null, Z, M, null, F, O, getContainerType(M), $)
          }
      }
      return T
  }
    , x = (T,w,M,F,O,$)=>{
      const {slotScopeIds: j} = w;
      j && (O = O ? O.concat(j) : j);
      const K = f(T)
        , Y = P(l(T), w, K, M, F, O, $);
      return Y && isComment(Y) && Y.data === "]" ? l(w.anchor = Y) : (hasMismatch = !0,
      g(w.anchor = _("]"), K, Y),
      Y)
  }
    , E = (T,w,M,F,O,$)=>{
      if (hasMismatch = !0,
      w.el = null,
      $) {
          const Y = I(T);
          for (; ; ) {
              const W = l(T);
              if (W && W !== Y)
                  d(W);
              else
                  break
          }
      }
      const j = l(T)
        , K = f(T);
      return d(T),
      r(null, w, K, j, M, F, getContainerType(K), O),
      j
  }
    , I = (T,w="[",M="]")=>{
      let F = 0;
      for (; T; )
          if (T = l(T),
          T && isComment(T) && (T.data === w && F++,
          T.data === M)) {
              if (F === 0)
                  return l(T);
              F--
          }
      return T
  }
    , C = (T,w,M)=>{
      const F = w.parentNode;
      F && F.replaceChild(T, w);
      let O = M;
      for (; O; )
          O.vnode.el === w && (O.vnode.el = O.subTree.el = T),
          O = O.parent
  }
    , A = T=>T.nodeType === 1 && T.tagName.toLowerCase() === "template";
  return [v, S]
}
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(e) {
  return baseCreateRenderer(e)
}
function createHydrationRenderer(e) {
  return baseCreateRenderer(e, createHydrationFunctions)
}
function baseCreateRenderer(e, t) {
  const r = getGlobalThis();
  r.__VUE__ = !0;
  const {insert: a, remove: o, patchProp: l, createElement: f, createText: d, createComment: g, setText: _, setElementText: v, parentNode: S, nextSibling: b, setScopeId: P=NOOP, insertStaticContent: x} = e
    , E = (H,z,J,te=null,U=null,ne=null,ie=void 0,se=null,ae=!!z.dynamicChildren)=>{
      if (H === z)
          return;
      H && !isSameVNodeType(H, z) && (te = Q(H),
      oe(H, U, ne, !0),
      H = null),
      z.patchFlag === -2 && (ae = !1,
      z.dynamicChildren = null);
      const {type: re, ref: ce, shapeFlag: ve} = z;
      switch (re) {
      case Text:
          I(H, z, J, te);
          break;
      case Comment:
          C(H, z, J, te);
          break;
      case Static:
          H == null && A(z, J, te, ie);
          break;
      case Fragment:
          W(H, z, J, te, U, ne, ie, se, ae);
          break;
      default:
          ve & 1 ? M(H, z, J, te, U, ne, ie, se, ae) : ve & 6 ? Z(H, z, J, te, U, ne, ie, se, ae) : (ve & 64 || ve & 128) && re.process(H, z, J, te, U, ne, ie, se, ae, ue)
      }
      ce != null && U && setRef(ce, H && H.ref, ne, z || H, !z)
  }
    , I = (H,z,J,te)=>{
      if (H == null)
          a(z.el = d(z.children), J, te);
      else {
          const U = z.el = H.el;
          z.children !== H.children && _(U, z.children)
      }
  }
    , C = (H,z,J,te)=>{
      H == null ? a(z.el = g(z.children || ""), J, te) : z.el = H.el
  }
    , A = (H,z,J,te)=>{
      [H.el,H.anchor] = x(H.children, z, J, te, H.el, H.anchor)
  }
    , T = ({el: H, anchor: z},J,te)=>{
      let U;
      for (; H && H !== z; )
          U = b(H),
          a(H, J, te),
          H = U;
      a(z, J, te)
  }
    , w = ({el: H, anchor: z})=>{
      let J;
      for (; H && H !== z; )
          J = b(H),
          o(H),
          H = J;
      o(z)
  }
    , M = (H,z,J,te,U,ne,ie,se,ae)=>{
      z.type === "svg" ? ie = "svg" : z.type === "math" && (ie = "mathml"),
      H == null ? F(z, J, te, U, ne, ie, se, ae) : j(H, z, U, ne, ie, se, ae)
  }
    , F = (H,z,J,te,U,ne,ie,se)=>{
      let ae, re;
      const {props: ce, shapeFlag: ve, transition: _e, dirs: de} = H;
      if (ae = H.el = f(H.type, ne, ce && ce.is, ce),
      ve & 8 ? v(ae, H.children) : ve & 16 && $(H.children, ae, null, te, U, resolveChildrenNamespace(H, ne), ie, se),
      de && invokeDirectiveHook(H, null, te, "created"),
      O(ae, H, H.scopeId, ie, te),
      ce) {
          for (const Ee in ce)
              Ee !== "value" && !isReservedProp(Ee) && l(ae, Ee, null, ce[Ee], ne, H.children, te, U, me);
          "value"in ce && l(ae, "value", null, ce.value, ne),
          (re = ce.onVnodeBeforeMount) && invokeVNodeHook(re, te, H)
      }
      de && invokeDirectiveHook(H, null, te, "beforeMount");
      const Se = needTransition(U, _e);
      Se && _e.beforeEnter(ae),
      a(ae, z, J),
      ((re = ce && ce.onVnodeMounted) || Se || de) && queuePostRenderEffect(()=>{
          re && invokeVNodeHook(re, te, H),
          Se && _e.enter(ae),
          de && invokeDirectiveHook(H, null, te, "mounted")
      }
      , U)
  }
    , O = (H,z,J,te,U)=>{
      if (J && P(H, J),
      te)
          for (let ne = 0; ne < te.length; ne++)
              P(H, te[ne]);
      if (U) {
          let ne = U.subTree;
          if (z === ne) {
              const ie = U.vnode;
              O(H, ie, ie.scopeId, ie.slotScopeIds, U.parent)
          }
      }
  }
    , $ = (H,z,J,te,U,ne,ie,se,ae=0)=>{
      for (let re = ae; re < H.length; re++) {
          const ce = H[re] = se ? cloneIfMounted(H[re]) : normalizeVNode(H[re]);
          E(null, ce, z, J, te, U, ne, ie, se)
      }
  }
    , j = (H,z,J,te,U,ne,ie)=>{
      const se = z.el = H.el;
      let {patchFlag: ae, dynamicChildren: re, dirs: ce} = z;
      ae |= H.patchFlag & 16;
      const ve = H.props || EMPTY_OBJ
        , _e = z.props || EMPTY_OBJ;
      let de;
      if (J && toggleRecurse(J, !1),
      (de = _e.onVnodeBeforeUpdate) && invokeVNodeHook(de, J, z, H),
      ce && invokeDirectiveHook(z, H, J, "beforeUpdate"),
      J && toggleRecurse(J, !0),
      re ? K(H.dynamicChildren, re, se, J, te, resolveChildrenNamespace(z, U), ne) : ie || R(H, z, se, null, J, te, resolveChildrenNamespace(z, U), ne, !1),
      ae > 0) {
          if (ae & 16)
              Y(se, z, ve, _e, J, te, U);
          else if (ae & 2 && ve.class !== _e.class && l(se, "class", null, _e.class, U),
          ae & 4 && l(se, "style", ve.style, _e.style, U),
          ae & 8) {
              const Se = z.dynamicProps;
              for (let Ee = 0; Ee < Se.length; Ee++) {
                  const Re = Se[Ee]
                    , ke = ve[Re]
                    , Le = _e[Re];
                  (Le !== ke || Re === "value") && l(se, Re, ke, Le, U, H.children, J, te, me)
              }
          }
          ae & 1 && H.children !== z.children && v(se, z.children)
      } else
          !ie && re == null && Y(se, z, ve, _e, J, te, U);
      ((de = _e.onVnodeUpdated) || ce) && queuePostRenderEffect(()=>{
          de && invokeVNodeHook(de, J, z, H),
          ce && invokeDirectiveHook(z, H, J, "updated")
      }
      , te)
  }
    , K = (H,z,J,te,U,ne,ie)=>{
      for (let se = 0; se < z.length; se++) {
          const ae = H[se]
            , re = z[se]
            , ce = ae.el && (ae.type === Fragment || !isSameVNodeType(ae, re) || ae.shapeFlag & 70) ? S(ae.el) : J;
          E(ae, re, ce, null, te, U, ne, ie, !0)
      }
  }
    , Y = (H,z,J,te,U,ne,ie)=>{
      if (J !== te) {
          if (J !== EMPTY_OBJ)
              for (const se in J)
                  !isReservedProp(se) && !(se in te) && l(H, se, J[se], null, ie, z.children, U, ne, me);
          for (const se in te) {
              if (isReservedProp(se))
                  continue;
              const ae = te[se]
                , re = J[se];
              ae !== re && se !== "value" && l(H, se, re, ae, ie, z.children, U, ne, me)
          }
          "value"in te && l(H, "value", J.value, te.value, ie)
      }
  }
    , W = (H,z,J,te,U,ne,ie,se,ae)=>{
      const re = z.el = H ? H.el : d("")
        , ce = z.anchor = H ? H.anchor : d("");
      let {patchFlag: ve, dynamicChildren: _e, slotScopeIds: de} = z;
      de && (se = se ? se.concat(de) : de),
      H == null ? (a(re, J, te),
      a(ce, J, te),
      $(z.children || [], J, ce, U, ne, ie, se, ae)) : ve > 0 && ve & 64 && _e && H.dynamicChildren ? (K(H.dynamicChildren, _e, J, U, ne, ie, se),
      (z.key != null || U && z === U.subTree) && traverseStaticChildren(H, z, !0)) : R(H, z, J, ce, U, ne, ie, se, ae)
  }
    , Z = (H,z,J,te,U,ne,ie,se,ae)=>{
      z.slotScopeIds = se,
      H == null ? z.shapeFlag & 512 ? U.ctx.activate(z, J, te, ie, ae) : ee(z, J, te, U, ne, ie, ae) : X(H, z, ae)
  }
    , ee = (H,z,J,te,U,ne,ie)=>{
      const se = H.component = createComponentInstance(H, te, U);
      if (isKeepAlive(H) && (se.ctx.renderer = ue),
      setupComponent(se),
      se.asyncDep) {
          if (U && U.registerDep(se, D),
          !H.el) {
              const ae = se.subTree = createVNode(Comment);
              C(null, ae, z, J)
          }
      } else
          D(se, H, z, J, U, ne, ie)
  }
    , X = (H,z,J)=>{
      const te = z.component = H.component;
      if (shouldUpdateComponent(H, z, J))
          if (te.asyncDep && !te.asyncResolved) {
              B(te, z, J);
              return
          } else
              te.next = z,
              invalidateJob(te.update),
              te.effect.dirty = !0,
              te.update();
      else
          z.el = H.el,
          te.vnode = z
  }
    , D = (H,z,J,te,U,ne,ie)=>{
      const se = ()=>{
          if (H.isMounted) {
              let {next: ce, bu: ve, u: _e, parent: de, vnode: Se} = H;
              {
                  const Ke = locateNonHydratedAsyncRoot(H);
                  if (Ke) {
                      ce && (ce.el = Se.el,
                      B(H, ce, ie)),
                      Ke.asyncDep.then(()=>{
                          H.isUnmounted || se()
                      }
                      );
                      return
                  }
              }
              let Ee = ce, Re;
              toggleRecurse(H, !1),
              ce ? (ce.el = Se.el,
              B(H, ce, ie)) : ce = Se,
              ve && invokeArrayFns(ve),
              (Re = ce.props && ce.props.onVnodeBeforeUpdate) && invokeVNodeHook(Re, de, ce, Se),
              toggleRecurse(H, !0);
              const ke = renderComponentRoot(H)
                , Le = H.subTree;
              H.subTree = ke,
              E(Le, ke, S(Le.el), Q(Le), H, U, ne),
              ce.el = ke.el,
              Ee === null && updateHOCHostEl(H, ke.el),
              _e && queuePostRenderEffect(_e, U),
              (Re = ce.props && ce.props.onVnodeUpdated) && queuePostRenderEffect(()=>invokeVNodeHook(Re, de, ce, Se), U)
          } else {
              let ce;
              const {el: ve, props: _e} = z
                , {bm: de, m: Se, parent: Ee} = H
                , Re = isAsyncWrapper(z);
              if (toggleRecurse(H, !1),
              de && invokeArrayFns(de),
              !Re && (ce = _e && _e.onVnodeBeforeMount) && invokeVNodeHook(ce, Ee, z),
              toggleRecurse(H, !0),
              ve && ge) {
                  const ke = ()=>{
                      H.subTree = renderComponentRoot(H),
                      ge(ve, H.subTree, H, U, null)
                  }
                  ;
                  Re ? z.type.__asyncLoader().then(()=>!H.isUnmounted && ke()) : ke()
              } else {
                  const ke = H.subTree = renderComponentRoot(H);
                  E(null, ke, J, te, H, U, ne),
                  z.el = ke.el
              }
              if (Se && queuePostRenderEffect(Se, U),
              !Re && (ce = _e && _e.onVnodeMounted)) {
                  const ke = z;
                  queuePostRenderEffect(()=>invokeVNodeHook(ce, Ee, ke), U)
              }
              (z.shapeFlag & 256 || Ee && isAsyncWrapper(Ee.vnode) && Ee.vnode.shapeFlag & 256) && H.a && queuePostRenderEffect(H.a, U),
              H.isMounted = !0,
              z = J = te = null
          }
      }
        , ae = H.effect = new ReactiveEffect(se,NOOP,()=>queueJob(re),H.scope)
        , re = H.update = ()=>{
          ae.dirty && ae.run()
      }
      ;
      re.id = H.uid,
      toggleRecurse(H, !0),
      re()
  }
    , B = (H,z,J)=>{
      z.component = H;
      const te = H.vnode.props;
      H.vnode = z,
      H.next = null,
      updateProps(H, z.props, te, J),
      updateSlots(H, z.children, J),
      pauseTracking(),
      flushPreFlushCbs(H),
      resetTracking()
  }
    , R = (H,z,J,te,U,ne,ie,se,ae=!1)=>{
      const re = H && H.children
        , ce = H ? H.shapeFlag : 0
        , ve = z.children
        , {patchFlag: _e, shapeFlag: de} = z;
      if (_e > 0) {
          if (_e & 128) {
              V(re, ve, J, te, U, ne, ie, se, ae);
              return
          } else if (_e & 256) {
              L(re, ve, J, te, U, ne, ie, se, ae);
              return
          }
      }
      de & 8 ? (ce & 16 && me(re, U, ne),
      ve !== re && v(J, ve)) : ce & 16 ? de & 16 ? V(re, ve, J, te, U, ne, ie, se, ae) : me(re, U, ne, !0) : (ce & 8 && v(J, ""),
      de & 16 && $(ve, J, te, U, ne, ie, se, ae))
  }
    , L = (H,z,J,te,U,ne,ie,se,ae)=>{
      H = H || EMPTY_ARR,
      z = z || EMPTY_ARR;
      const re = H.length
        , ce = z.length
        , ve = Math.min(re, ce);
      let _e;
      for (_e = 0; _e < ve; _e++) {
          const de = z[_e] = ae ? cloneIfMounted(z[_e]) : normalizeVNode(z[_e]);
          E(H[_e], de, J, null, U, ne, ie, se, ae)
      }
      re > ce ? me(H, U, ne, !0, !1, ve) : $(z, J, te, U, ne, ie, se, ae, ve)
  }
    , V = (H,z,J,te,U,ne,ie,se,ae)=>{
      let re = 0;
      const ce = z.length;
      let ve = H.length - 1
        , _e = ce - 1;
      for (; re <= ve && re <= _e; ) {
          const de = H[re]
            , Se = z[re] = ae ? cloneIfMounted(z[re]) : normalizeVNode(z[re]);
          if (isSameVNodeType(de, Se))
              E(de, Se, J, null, U, ne, ie, se, ae);
          else
              break;
          re++
      }
      for (; re <= ve && re <= _e; ) {
          const de = H[ve]
            , Se = z[_e] = ae ? cloneIfMounted(z[_e]) : normalizeVNode(z[_e]);
          if (isSameVNodeType(de, Se))
              E(de, Se, J, null, U, ne, ie, se, ae);
          else
              break;
          ve--,
          _e--
      }
      if (re > ve) {
          if (re <= _e) {
              const de = _e + 1
                , Se = de < ce ? z[de].el : te;
              for (; re <= _e; )
                  E(null, z[re] = ae ? cloneIfMounted(z[re]) : normalizeVNode(z[re]), J, Se, U, ne, ie, se, ae),
                  re++
          }
      } else if (re > _e)
          for (; re <= ve; )
              oe(H[re], U, ne, !0),
              re++;
      else {
          const de = re
            , Se = re
            , Ee = new Map;
          for (re = Se; re <= _e; re++) {
              const Ne = z[re] = ae ? cloneIfMounted(z[re]) : normalizeVNode(z[re]);
              Ne.key != null && Ee.set(Ne.key, re)
          }
          let Re, ke = 0;
          const Le = _e - Se + 1;
          let Ke = !1
            , Ze = 0;
          const Ye = new Array(Le);
          for (re = 0; re < Le; re++)
              Ye[re] = 0;
          for (re = de; re <= ve; re++) {
              const Ne = H[re];
              if (ke >= Le) {
                  oe(Ne, U, ne, !0);
                  continue
              }
              let Ce;
              if (Ne.key != null)
                  Ce = Ee.get(Ne.key);
              else
                  for (Re = Se; Re <= _e; Re++)
                      if (Ye[Re - Se] === 0 && isSameVNodeType(Ne, z[Re])) {
                          Ce = Re;
                          break
                      }
              Ce === void 0 ? oe(Ne, U, ne, !0) : (Ye[Ce - Se] = re + 1,
              Ce >= Ze ? Ze = Ce : Ke = !0,
              E(Ne, z[Ce], J, null, U, ne, ie, se, ae),
              ke++)
          }
          const rt = Ke ? getSequence(Ye) : EMPTY_ARR;
          for (Re = rt.length - 1,
          re = Le - 1; re >= 0; re--) {
              const Ne = Se + re
                , Ce = z[Ne]
                , Xe = Ne + 1 < ce ? z[Ne + 1].el : te;
              Ye[re] === 0 ? E(null, Ce, J, Xe, U, ne, ie, se, ae) : Ke && (Re < 0 || re !== rt[Re] ? q(Ce, J, Xe, 2) : Re--)
          }
      }
  }
    , q = (H,z,J,te,U=null)=>{
      const {el: ne, type: ie, transition: se, children: ae, shapeFlag: re} = H;
      if (re & 6) {
          q(H.component.subTree, z, J, te);
          return
      }
      if (re & 128) {
          H.suspense.move(z, J, te);
          return
      }
      if (re & 64) {
          ie.move(H, z, J, ue);
          return
      }
      if (ie === Fragment) {
          a(ne, z, J);
          for (let ve = 0; ve < ae.length; ve++)
              q(ae[ve], z, J, te);
          a(H.anchor, z, J);
          return
      }
      if (ie === Static) {
          T(H, z, J);
          return
      }
      if (te !== 2 && re & 1 && se)
          if (te === 0)
              se.beforeEnter(ne),
              a(ne, z, J),
              queuePostRenderEffect(()=>se.enter(ne), U);
          else {
              const {leave: ve, delayLeave: _e, afterLeave: de} = se
                , Se = ()=>a(ne, z, J)
                , Ee = ()=>{
                  ve(ne, ()=>{
                      Se(),
                      de && de()
                  }
                  )
              }
              ;
              _e ? _e(ne, Se, Ee) : Ee()
          }
      else
          a(ne, z, J)
  }
    , oe = (H,z,J,te=!1,U=!1)=>{
      const {type: ne, props: ie, ref: se, children: ae, dynamicChildren: re, shapeFlag: ce, patchFlag: ve, dirs: _e} = H;
      if (se != null && setRef(se, null, J, H, !0),
      ce & 256) {
          z.ctx.deactivate(H);
          return
      }
      const de = ce & 1 && _e
        , Se = !isAsyncWrapper(H);
      let Ee;
      if (Se && (Ee = ie && ie.onVnodeBeforeUnmount) && invokeVNodeHook(Ee, z, H),
      ce & 6)
          Pe(H.component, J, te);
      else {
          if (ce & 128) {
              H.suspense.unmount(J, te);
              return
          }
          de && invokeDirectiveHook(H, null, z, "beforeUnmount"),
          ce & 64 ? H.type.remove(H, z, J, U, ue, te) : re && (ne !== Fragment || ve > 0 && ve & 64) ? me(re, z, J, !1, !0) : (ne === Fragment && ve & 384 || !U && ce & 16) && me(ae, z, J),
          te && ye(H)
      }
      (Se && (Ee = ie && ie.onVnodeUnmounted) || de) && queuePostRenderEffect(()=>{
          Ee && invokeVNodeHook(Ee, z, H),
          de && invokeDirectiveHook(H, null, z, "unmounted")
      }
      , J)
  }
    , ye = H=>{
      const {type: z, el: J, anchor: te, transition: U} = H;
      if (z === Fragment) {
          pe(J, te);
          return
      }
      if (z === Static) {
          w(H);
          return
      }
      const ne = ()=>{
          o(J),
          U && !U.persisted && U.afterLeave && U.afterLeave()
      }
      ;
      if (H.shapeFlag & 1 && U && !U.persisted) {
          const {leave: ie, delayLeave: se} = U
            , ae = ()=>ie(J, ne);
          se ? se(H.el, ne, ae) : ae()
      } else
          ne()
  }
    , pe = (H,z)=>{
      let J;
      for (; H !== z; )
          J = b(H),
          o(H),
          H = J;
      o(z)
  }
    , Pe = (H,z,J)=>{
      const {bum: te, scope: U, update: ne, subTree: ie, um: se} = H;
      te && invokeArrayFns(te),
      U.stop(),
      ne && (ne.active = !1,
      oe(ie, H, z, J)),
      se && queuePostRenderEffect(se, z),
      queuePostRenderEffect(()=>{
          H.isUnmounted = !0
      }
      , z),
      z && z.pendingBranch && !z.isUnmounted && H.asyncDep && !H.asyncResolved && H.suspenseId === z.pendingId && (z.deps--,
      z.deps === 0 && z.resolve())
  }
    , me = (H,z,J,te=!1,U=!1,ne=0)=>{
      for (let ie = ne; ie < H.length; ie++)
          oe(H[ie], z, J, te, U)
  }
    , Q = H=>H.shapeFlag & 6 ? Q(H.component.subTree) : H.shapeFlag & 128 ? H.suspense.next() : b(H.anchor || H.el);
  let le = !1;
  const fe = (H,z,J)=>{
      H == null ? z._vnode && oe(z._vnode, null, null, !0) : E(z._vnode || null, H, z, null, null, null, J),
      le || (le = !0,
      flushPreFlushCbs(),
      flushPostFlushCbs(),
      le = !1),
      z._vnode = H
  }
    , ue = {
      p: E,
      um: oe,
      m: q,
      r: ye,
      mt: ee,
      mc: $,
      pc: R,
      pbc: K,
      n: Q,
      o: e
  };
  let be, ge;
  return t && ([be,ge] = t(ue)),
  {
      render: fe,
      hydrate: be,
      createApp: createAppAPI(fe, be)
  }
}
function resolveChildrenNamespace({type: e, props: t}, r) {
  return r === "svg" && e === "foreignObject" || r === "mathml" && e === "annotation-xml" && t && t.encoding && t.encoding.includes("html") ? void 0 : r
}
function toggleRecurse({effect: e, update: t}, r) {
  e.allowRecurse = t.allowRecurse = r
}
function needTransition(e, t) {
  return (!e || e && !e.pendingBranch) && t && !t.persisted
}
function traverseStaticChildren(e, t, r=!1) {
  const a = e.children
    , o = t.children;
  if (isArray$1(a) && isArray$1(o))
      for (let l = 0; l < a.length; l++) {
          const f = a[l];
          let d = o[l];
          d.shapeFlag & 1 && !d.dynamicChildren && ((d.patchFlag <= 0 || d.patchFlag === 32) && (d = o[l] = cloneIfMounted(o[l]),
          d.el = f.el),
          r || traverseStaticChildren(f, d)),
          d.type === Text && (d.el = f.el)
      }
}
function getSequence(e) {
  const t = e.slice()
    , r = [0];
  let a, o, l, f, d;
  const g = e.length;
  for (a = 0; a < g; a++) {
      const _ = e[a];
      if (_ !== 0) {
          if (o = r[r.length - 1],
          e[o] < _) {
              t[a] = o,
              r.push(a);
              continue
          }
          for (l = 0,
          f = r.length - 1; l < f; )
              d = l + f >> 1,
              e[r[d]] < _ ? l = d + 1 : f = d;
          _ < e[r[l]] && (l > 0 && (t[a] = r[l - 1]),
          r[l] = a)
      }
  }
  for (l = r.length,
  f = r[l - 1]; l-- > 0; )
      r[l] = f,
      f = t[f];
  return r
}
function locateNonHydratedAsyncRoot(e) {
  const t = e.subTree.component;
  if (t)
      return t.asyncDep && !t.asyncResolved ? t : locateNonHydratedAsyncRoot(t)
}
const isTeleport = e=>e.__isTeleport
, Fragment = Symbol.for("v-fgt")
, Text = Symbol.for("v-txt")
, Comment = Symbol.for("v-cmt")
, Static = Symbol.for("v-stc")
, blockStack = [];
let currentBlock = null;
function openBlock(e=!1) {
  blockStack.push(currentBlock = e ? null : [])
}
function closeBlock() {
  blockStack.pop(),
  currentBlock = blockStack[blockStack.length - 1] || null
}
let isBlockTreeEnabled = 1;
function setBlockTracking(e) {
  isBlockTreeEnabled += e
}
function setupBlock(e) {
  return e.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null,
  closeBlock(),
  isBlockTreeEnabled > 0 && currentBlock && currentBlock.push(e),
  e
}
function createElementBlock(e, t, r, a, o, l) {
  return setupBlock(createBaseVNode(e, t, r, a, o, l, !0))
}
function createBlock(e, t, r, a, o) {
  return setupBlock(createVNode(e, t, r, a, o, !0))
}
function isVNode(e) {
  return e ? e.__v_isVNode === !0 : !1
}
function isSameVNodeType(e, t) {
  return e.type === t.type && e.key === t.key
}
const InternalObjectKey = "__vInternal"
, normalizeKey = ({key: e})=>e ?? null
, normalizeRef = ({ref: e, ref_key: t, ref_for: r})=>(typeof e == "number" && (e = "" + e),
e != null ? isString(e) || isRef(e) || isFunction(e) ? {
  i: currentRenderingInstance,
  r: e,
  k: t,
  f: !!r
} : e : null);
function createBaseVNode(e, t=null, r=null, a=0, o=null, l=e === Fragment ? 0 : 1, f=!1, d=!1) {
  const g = {
      __v_isVNode: !0,
      __v_skip: !0,
      type: e,
      props: t,
      key: t && normalizeKey(t),
      ref: t && normalizeRef(t),
      scopeId: currentScopeId,
      slotScopeIds: null,
      children: r,
      component: null,
      suspense: null,
      ssContent: null,
      ssFallback: null,
      dirs: null,
      transition: null,
      el: null,
      anchor: null,
      target: null,
      targetAnchor: null,
      staticCount: 0,
      shapeFlag: l,
      patchFlag: a,
      dynamicProps: o,
      dynamicChildren: null,
      appContext: null,
      ctx: currentRenderingInstance
  };
  return d ? (normalizeChildren(g, r),
  l & 128 && e.normalize(g)) : r && (g.shapeFlag |= isString(r) ? 8 : 16),
  isBlockTreeEnabled > 0 && !f && currentBlock && (g.patchFlag > 0 || l & 6) && g.patchFlag !== 32 && currentBlock.push(g),
  g
}
const createVNode = _createVNode;
function _createVNode(e, t=null, r=null, a=0, o=null, l=!1) {
  if ((!e || e === NULL_DYNAMIC_COMPONENT) && (e = Comment),
  isVNode(e)) {
      const d = cloneVNode(e, t, !0);
      return r && normalizeChildren(d, r),
      isBlockTreeEnabled > 0 && !l && currentBlock && (d.shapeFlag & 6 ? currentBlock[currentBlock.indexOf(e)] = d : currentBlock.push(d)),
      d.patchFlag |= -2,
      d
  }
  if (isClassComponent(e) && (e = e.__vccOpts),
  t) {
      t = guardReactiveProps(t);
      let {class: d, style: g} = t;
      d && !isString(d) && (t.class = normalizeClass(d)),
      isObject(g) && (isProxy(g) && !isArray$1(g) && (g = extend({}, g)),
      t.style = normalizeStyle(g))
  }
  const f = isString(e) ? 1 : isSuspense(e) ? 128 : isTeleport(e) ? 64 : isObject(e) ? 4 : isFunction(e) ? 2 : 0;
  return createBaseVNode(e, t, r, a, o, f, l, !0)
}
function guardReactiveProps(e) {
  return e ? isProxy(e) || InternalObjectKey in e ? extend({}, e) : e : null
}
function cloneVNode(e, t, r=!1) {
  const {props: a, ref: o, patchFlag: l, children: f} = e
    , d = t ? mergeProps(a || {}, t) : a;
  return {
      __v_isVNode: !0,
      __v_skip: !0,
      type: e.type,
      props: d,
      key: d && normalizeKey(d),
      ref: t && t.ref ? r && o ? isArray$1(o) ? o.concat(normalizeRef(t)) : [o, normalizeRef(t)] : normalizeRef(t) : o,
      scopeId: e.scopeId,
      slotScopeIds: e.slotScopeIds,
      children: f,
      target: e.target,
      targetAnchor: e.targetAnchor,
      staticCount: e.staticCount,
      shapeFlag: e.shapeFlag,
      patchFlag: t && e.type !== Fragment ? l === -1 ? 16 : l | 16 : l,
      dynamicProps: e.dynamicProps,
      dynamicChildren: e.dynamicChildren,
      appContext: e.appContext,
      dirs: e.dirs,
      transition: e.transition,
      component: e.component,
      suspense: e.suspense,
      ssContent: e.ssContent && cloneVNode(e.ssContent),
      ssFallback: e.ssFallback && cloneVNode(e.ssFallback),
      el: e.el,
      anchor: e.anchor,
      ctx: e.ctx,
      ce: e.ce
  }
}
function createTextVNode(e=" ", t=0) {
  return createVNode(Text, null, e, t)
}
function createStaticVNode(e, t) {
  const r = createVNode(Static, null, e);
  return r.staticCount = t,
  r
}
function createCommentVNode(e="", t=!1) {
  return t ? (openBlock(),
  createBlock(Comment, null, e)) : createVNode(Comment, null, e)
}
function normalizeVNode(e) {
  return e == null || typeof e == "boolean" ? createVNode(Comment) : isArray$1(e) ? createVNode(Fragment, null, e.slice()) : typeof e == "object" ? cloneIfMounted(e) : createVNode(Text, null, String(e))
}
function cloneIfMounted(e) {
  return e.el === null && e.patchFlag !== -1 || e.memo ? e : cloneVNode(e)
}
function normalizeChildren(e, t) {
  let r = 0;
  const {shapeFlag: a} = e;
  if (t == null)
      t = null;
  else if (isArray$1(t))
      r = 16;
  else if (typeof t == "object")
      if (a & 65) {
          const o = t.default;
          o && (o._c && (o._d = !1),
          normalizeChildren(e, o()),
          o._c && (o._d = !0));
          return
      } else {
          r = 32;
          const o = t._;
          !o && !(InternalObjectKey in t) ? t._ctx = currentRenderingInstance : o === 3 && currentRenderingInstance && (currentRenderingInstance.slots._ === 1 ? t._ = 1 : (t._ = 2,
          e.patchFlag |= 1024))
      }
  else
      isFunction(t) ? (t = {
          default: t,
          _ctx: currentRenderingInstance
      },
      r = 32) : (t = String(t),
      a & 64 ? (r = 16,
      t = [createTextVNode(t)]) : r = 8);
  e.children = t,
  e.shapeFlag |= r
}
function mergeProps(...e) {
  const t = {};
  for (let r = 0; r < e.length; r++) {
      const a = e[r];
      for (const o in a)
          if (o === "class")
              t.class !== a.class && (t.class = normalizeClass([t.class, a.class]));
          else if (o === "style")
              t.style = normalizeStyle([t.style, a.style]);
          else if (isOn(o)) {
              const l = t[o]
                , f = a[o];
              f && l !== f && !(isArray$1(l) && l.includes(f)) && (t[o] = l ? [].concat(l, f) : f)
          } else
              o !== "" && (t[o] = a[o])
  }
  return t
}
function invokeVNodeHook(e, t, r, a=null) {
  callWithAsyncErrorHandling(e, t, 7, [r, a])
}
const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(e, t, r) {
  const a = e.type
    , o = (t ? t.appContext : e.appContext) || emptyAppContext
    , l = {
      uid: uid++,
      vnode: e,
      type: a,
      parent: t,
      appContext: o,
      root: null,
      next: null,
      subTree: null,
      effect: null,
      update: null,
      scope: new EffectScope(!0),
      render: null,
      proxy: null,
      exposed: null,
      exposeProxy: null,
      withProxy: null,
      provides: t ? t.provides : Object.create(o.provides),
      accessCache: null,
      renderCache: [],
      components: null,
      directives: null,
      propsOptions: normalizePropsOptions(a, o),
      emitsOptions: normalizeEmitsOptions(a, o),
      emit: null,
      emitted: null,
      propsDefaults: EMPTY_OBJ,
      inheritAttrs: a.inheritAttrs,
      ctx: EMPTY_OBJ,
      data: EMPTY_OBJ,
      props: EMPTY_OBJ,
      attrs: EMPTY_OBJ,
      slots: EMPTY_OBJ,
      refs: EMPTY_OBJ,
      setupState: EMPTY_OBJ,
      setupContext: null,
      attrsProxy: null,
      slotsProxy: null,
      suspense: r,
      suspenseId: r ? r.pendingId : 0,
      asyncDep: null,
      asyncResolved: !1,
      isMounted: !1,
      isUnmounted: !1,
      isDeactivated: !1,
      bc: null,
      c: null,
      bm: null,
      m: null,
      bu: null,
      u: null,
      um: null,
      bum: null,
      da: null,
      a: null,
      rtg: null,
      rtc: null,
      ec: null,
      sp: null
  };
  return l.ctx = {
      _: l
  },
  l.root = t ? t.root : l,
  l.emit = emit.bind(null, l),
  e.ce && e.ce(l),
  l
}
let currentInstance = null;
const getCurrentInstance = ()=>currentInstance || currentRenderingInstance;
let internalSetCurrentInstance, setInSSRSetupState;
{
  const e = getGlobalThis()
    , t = (r,a)=>{
      let o;
      return (o = e[r]) || (o = e[r] = []),
      o.push(a),
      l=>{
          o.length > 1 ? o.forEach(f=>f(l)) : o[0](l)
      }
  }
  ;
  internalSetCurrentInstance = t("__VUE_INSTANCE_SETTERS__", r=>currentInstance = r),
  setInSSRSetupState = t("__VUE_SSR_SETTERS__", r=>isInSSRComponentSetup = r)
}
const setCurrentInstance = e=>{
  const t = currentInstance;
  return internalSetCurrentInstance(e),
  e.scope.on(),
  ()=>{
      e.scope.off(),
      internalSetCurrentInstance(t)
  }
}
, unsetCurrentInstance = ()=>{
  currentInstance && currentInstance.scope.off(),
  internalSetCurrentInstance(null)
}
;
function isStatefulComponent(e) {
  return e.vnode.shapeFlag & 4
}
let isInSSRComponentSetup = !1;
function setupComponent(e, t=!1) {
  t && setInSSRSetupState(t);
  const {props: r, children: a} = e.vnode
    , o = isStatefulComponent(e);
  initProps(e, r, o, t),
  initSlots(e, a);
  const l = o ? setupStatefulComponent(e, t) : void 0;
  return t && setInSSRSetupState(!1),
  l
}
function setupStatefulComponent(e, t) {
  const r = e.type;
  e.accessCache = Object.create(null),
  e.proxy = markRaw(new Proxy(e.ctx,PublicInstanceProxyHandlers));
  const {setup: a} = r;
  if (a) {
      const o = e.setupContext = a.length > 1 ? createSetupContext(e) : null
        , l = setCurrentInstance(e);
      pauseTracking();
      const f = callWithErrorHandling(a, e, 0, [e.props, o]);
      if (resetTracking(),
      l(),
      isPromise(f)) {
          if (f.then(unsetCurrentInstance, unsetCurrentInstance),
          t)
              return f.then(d=>{
                  handleSetupResult(e, d, t)
              }
              ).catch(d=>{
                  handleError(d, e, 0)
              }
              );
          e.asyncDep = f
      } else
          handleSetupResult(e, f, t)
  } else
      finishComponentSetup(e, t)
}
function handleSetupResult(e, t, r) {
  isFunction(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : isObject(t) && (e.setupState = proxyRefs(t)),
  finishComponentSetup(e, r)
}
let compile;
function finishComponentSetup(e, t, r) {
  const a = e.type;
  if (!e.render) {
      if (!t && compile && !a.render) {
          const o = a.template || resolveMergedOptions(e).template;
          if (o) {
              const {isCustomElement: l, compilerOptions: f} = e.appContext.config
                , {delimiters: d, compilerOptions: g} = a
                , _ = extend(extend({
                  isCustomElement: l,
                  delimiters: d
              }, f), g);
              a.render = compile(o, _)
          }
      }
      e.render = a.render || NOOP
  }
  {
      const o = setCurrentInstance(e);
      pauseTracking();
      try {
          applyOptions(e)
      } finally {
          resetTracking(),
          o()
      }
  }
}
function getAttrsProxy(e) {
  return e.attrsProxy || (e.attrsProxy = new Proxy(e.attrs,{
      get(t, r) {
          return track(e, "get", "$attrs"),
          t[r]
      }
  }))
}
function createSetupContext(e) {
  const t = r=>{
      e.exposed = r || {}
  }
  ;
  return {
      get attrs() {
          return getAttrsProxy(e)
      },
      slots: e.slots,
      emit: e.emit,
      expose: t
  }
}
function getExposeProxy(e) {
  if (e.exposed)
      return e.exposeProxy || (e.exposeProxy = new Proxy(proxyRefs(markRaw(e.exposed)),{
          get(t, r) {
              if (r in t)
                  return t[r];
              if (r in publicPropertiesMap)
                  return publicPropertiesMap[r](e)
          },
          has(t, r) {
              return r in t || r in publicPropertiesMap
          }
      }))
}
const classifyRE = /(?:^|[-_])(\w)/g
, classify = e=>e.replace(classifyRE, t=>t.toUpperCase()).replace(/[-_]/g, "");
function getComponentName(e, t=!0) {
  return isFunction(e) ? e.displayName || e.name : e.name || t && e.__name
}
function formatComponentName(e, t, r=!1) {
  let a = getComponentName(t);
  if (!a && t.__file) {
      const o = t.__file.match(/([^/\\]+)\.\w+$/);
      o && (a = o[1])
  }
  if (!a && e && e.parent) {
      const o = l=>{
          for (const f in l)
              if (l[f] === t)
                  return f
      }
      ;
      a = o(e.components || e.parent.type.components) || o(e.appContext.components)
  }
  return a ? classify(a) : r ? "App" : "Anonymous"
}
function isClassComponent(e) {
  return isFunction(e) && "__vccOpts"in e
}
const computed = (e,t)=>computed$1(e, t, isInSSRComponentSetup);
function h(e, t, r) {
  const a = arguments.length;
  return a === 2 ? isObject(t) && !isArray$1(t) ? isVNode(t) ? createVNode(e, null, [t]) : createVNode(e, t) : createVNode(e, null, t) : (a > 3 ? r = Array.prototype.slice.call(arguments, 2) : a === 3 && isVNode(r) && (r = [r]),
  createVNode(e, t, r))
}
const version = "3.4.21";
/**
* @vue/runtime-dom v3.4.21
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const svgNS = "http://www.w3.org/2000/svg"
, mathmlNS = "http://www.w3.org/1998/Math/MathML"
, doc = typeof document < "u" ? document : null
, templateContainer = doc && doc.createElement("template")
, nodeOps = {
  insert: (e,t,r)=>{
      t.insertBefore(e, r || null)
  }
  ,
  remove: e=>{
      const t = e.parentNode;
      t && t.removeChild(e)
  }
  ,
  createElement: (e,t,r,a)=>{
      const o = t === "svg" ? doc.createElementNS(svgNS, e) : t === "mathml" ? doc.createElementNS(mathmlNS, e) : doc.createElement(e, r ? {
          is: r
      } : void 0);
      return e === "select" && a && a.multiple != null && o.setAttribute("multiple", a.multiple),
      o
  }
  ,
  createText: e=>doc.createTextNode(e),
  createComment: e=>doc.createComment(e),
  setText: (e,t)=>{
      e.nodeValue = t
  }
  ,
  setElementText: (e,t)=>{
      e.textContent = t
  }
  ,
  parentNode: e=>e.parentNode,
  nextSibling: e=>e.nextSibling,
  querySelector: e=>doc.querySelector(e),
  setScopeId(e, t) {
      e.setAttribute(t, "")
  },
  insertStaticContent(e, t, r, a, o, l) {
      const f = r ? r.previousSibling : t.lastChild;
      if (o && (o === l || o.nextSibling))
          for (; t.insertBefore(o.cloneNode(!0), r),
          !(o === l || !(o = o.nextSibling)); )
              ;
      else {
          templateContainer.innerHTML = a === "svg" ? `<svg>${e}</svg>` : a === "mathml" ? `<math>${e}</math>` : e;
          const d = templateContainer.content;
          if (a === "svg" || a === "mathml") {
              const g = d.firstChild;
              for (; g.firstChild; )
                  d.appendChild(g.firstChild);
              d.removeChild(g)
          }
          t.insertBefore(d, r)
      }
      return [f ? f.nextSibling : t.firstChild, r ? r.previousSibling : t.lastChild]
  }
}
, TRANSITION = "transition"
, ANIMATION = "animation"
, vtcKey = Symbol("_vtc")
, Transition = (e,{slots: t})=>h(BaseTransition, resolveTransitionProps(e), t);
Transition.displayName = "Transition";
const DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
      type: Boolean,
      default: !0
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
Transition.props = extend({}, BaseTransitionPropsValidators, DOMTransitionPropsValidators);
const callHook = (e,t=[])=>{
  isArray$1(e) ? e.forEach(r=>r(...t)) : e && e(...t)
}
, hasExplicitCallback = e=>e ? isArray$1(e) ? e.some(t=>t.length > 1) : e.length > 1 : !1;
function resolveTransitionProps(e) {
  const t = {};
  for (const W in e)
      W in DOMTransitionPropsValidators || (t[W] = e[W]);
  if (e.css === !1)
      return t;
  const {name: r="v", type: a, duration: o, enterFromClass: l=`${r}-enter-from`, enterActiveClass: f=`${r}-enter-active`, enterToClass: d=`${r}-enter-to`, appearFromClass: g=l, appearActiveClass: _=f, appearToClass: v=d, leaveFromClass: S=`${r}-leave-from`, leaveActiveClass: b=`${r}-leave-active`, leaveToClass: P=`${r}-leave-to`} = e
    , x = normalizeDuration(o)
    , E = x && x[0]
    , I = x && x[1]
    , {onBeforeEnter: C, onEnter: A, onEnterCancelled: T, onLeave: w, onLeaveCancelled: M, onBeforeAppear: F=C, onAppear: O=A, onAppearCancelled: $=T} = t
    , j = (W,Z,ee)=>{
      removeTransitionClass(W, Z ? v : d),
      removeTransitionClass(W, Z ? _ : f),
      ee && ee()
  }
    , K = (W,Z)=>{
      W._isLeaving = !1,
      removeTransitionClass(W, S),
      removeTransitionClass(W, P),
      removeTransitionClass(W, b),
      Z && Z()
  }
    , Y = W=>(Z,ee)=>{
      const X = W ? O : A
        , D = ()=>j(Z, W, ee);
      callHook(X, [Z, D]),
      nextFrame(()=>{
          removeTransitionClass(Z, W ? g : l),
          addTransitionClass(Z, W ? v : d),
          hasExplicitCallback(X) || whenTransitionEnds(Z, a, E, D)
      }
      )
  }
  ;
  return extend(t, {
      onBeforeEnter(W) {
          callHook(C, [W]),
          addTransitionClass(W, l),
          addTransitionClass(W, f)
      },
      onBeforeAppear(W) {
          callHook(F, [W]),
          addTransitionClass(W, g),
          addTransitionClass(W, _)
      },
      onEnter: Y(!1),
      onAppear: Y(!0),
      onLeave(W, Z) {
          W._isLeaving = !0;
          const ee = ()=>K(W, Z);
          addTransitionClass(W, S),
          forceReflow(),
          addTransitionClass(W, b),
          nextFrame(()=>{
              W._isLeaving && (removeTransitionClass(W, S),
              addTransitionClass(W, P),
              hasExplicitCallback(w) || whenTransitionEnds(W, a, I, ee))
          }
          ),
          callHook(w, [W, ee])
      },
      onEnterCancelled(W) {
          j(W, !1),
          callHook(T, [W])
      },
      onAppearCancelled(W) {
          j(W, !0),
          callHook($, [W])
      },
      onLeaveCancelled(W) {
          K(W),
          callHook(M, [W])
      }
  })
}
function normalizeDuration(e) {
  if (e == null)
      return null;
  if (isObject(e))
      return [NumberOf(e.enter), NumberOf(e.leave)];
  {
      const t = NumberOf(e);
      return [t, t]
  }
}
function NumberOf(e) {
  return toNumber(e)
}
function addTransitionClass(e, t) {
  t.split(/\s+/).forEach(r=>r && e.classList.add(r)),
  (e[vtcKey] || (e[vtcKey] = new Set)).add(t)
}
function removeTransitionClass(e, t) {
  t.split(/\s+/).forEach(a=>a && e.classList.remove(a));
  const r = e[vtcKey];
  r && (r.delete(t),
  r.size || (e[vtcKey] = void 0))
}
function nextFrame(e) {
  requestAnimationFrame(()=>{
      requestAnimationFrame(e)
  }
  )
}
let endId = 0;
function whenTransitionEnds(e, t, r, a) {
  const o = e._endId = ++endId
    , l = ()=>{
      o === e._endId && a()
  }
  ;
  if (r)
      return setTimeout(l, r);
  const {type: f, timeout: d, propCount: g} = getTransitionInfo(e, t);
  if (!f)
      return a();
  const _ = f + "end";
  let v = 0;
  const S = ()=>{
      e.removeEventListener(_, b),
      l()
  }
    , b = P=>{
      P.target === e && ++v >= g && S()
  }
  ;
  setTimeout(()=>{
      v < g && S()
  }
  , d + 1),
  e.addEventListener(_, b)
}
function getTransitionInfo(e, t) {
  const r = window.getComputedStyle(e)
    , a = x=>(r[x] || "").split(", ")
    , o = a(`${TRANSITION}Delay`)
    , l = a(`${TRANSITION}Duration`)
    , f = getTimeout(o, l)
    , d = a(`${ANIMATION}Delay`)
    , g = a(`${ANIMATION}Duration`)
    , _ = getTimeout(d, g);
  let v = null
    , S = 0
    , b = 0;
  t === TRANSITION ? f > 0 && (v = TRANSITION,
  S = f,
  b = l.length) : t === ANIMATION ? _ > 0 && (v = ANIMATION,
  S = _,
  b = g.length) : (S = Math.max(f, _),
  v = S > 0 ? f > _ ? TRANSITION : ANIMATION : null,
  b = v ? v === TRANSITION ? l.length : g.length : 0);
  const P = v === TRANSITION && /\b(transform|all)(,|$)/.test(a(`${TRANSITION}Property`).toString());
  return {
      type: v,
      timeout: S,
      propCount: b,
      hasTransform: P
  }
}
function getTimeout(e, t) {
  for (; e.length < t.length; )
      e = e.concat(e);
  return Math.max(...t.map((r,a)=>toMs(r) + toMs(e[a])))
}
function toMs(e) {
  return e === "auto" ? 0 : Number(e.slice(0, -1).replace(",", ".")) * 1e3
}
function forceReflow() {
  return document.body.offsetHeight
}
function patchClass(e, t, r) {
  const a = e[vtcKey];
  a && (t = (t ? [t, ...a] : [...a]).join(" ")),
  t == null ? e.removeAttribute("class") : r ? e.setAttribute("class", t) : e.className = t
}
const vShowOriginalDisplay = Symbol("_vod")
, vShowHidden = Symbol("_vsh")
, CSS_VAR_TEXT = Symbol("")
, displayRE = /(^|;)\s*display\s*:/;
function patchStyle(e, t, r) {
  const a = e.style
    , o = isString(r);
  let l = !1;
  if (r && !o) {
      if (t)
          if (isString(t))
              for (const f of t.split(";")) {
                  const d = f.slice(0, f.indexOf(":")).trim();
                  r[d] == null && setStyle(a, d, "")
              }
          else
              for (const f in t)
                  r[f] == null && setStyle(a, f, "");
      for (const f in r)
          f === "display" && (l = !0),
          setStyle(a, f, r[f])
  } else if (o) {
      if (t !== r) {
          const f = a[CSS_VAR_TEXT];
          f && (r += ";" + f),
          a.cssText = r,
          l = displayRE.test(r)
      }
  } else
      t && e.removeAttribute("style");
  vShowOriginalDisplay in e && (e[vShowOriginalDisplay] = l ? a.display : "",
  e[vShowHidden] && (a.display = "none"))
}
const importantRE = /\s*!important$/;
function setStyle(e, t, r) {
  if (isArray$1(r))
      r.forEach(a=>setStyle(e, t, a));
  else if (r == null && (r = ""),
  t.startsWith("--"))
      e.setProperty(t, r);
  else {
      const a = autoPrefix(e, t);
      importantRE.test(r) ? e.setProperty(hyphenate(a), r.replace(importantRE, ""), "important") : e[a] = r
  }
}
const prefixes = ["Webkit", "Moz", "ms"]
, prefixCache = {};
function autoPrefix(e, t) {
  const r = prefixCache[t];
  if (r)
      return r;
  let a = camelize(t);
  if (a !== "filter" && a in e)
      return prefixCache[t] = a;
  a = capitalize(a);
  for (let o = 0; o < prefixes.length; o++) {
      const l = prefixes[o] + a;
      if (l in e)
          return prefixCache[t] = l
  }
  return t
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(e, t, r, a, o) {
  if (a && t.startsWith("xlink:"))
      r == null ? e.removeAttributeNS(xlinkNS, t.slice(6, t.length)) : e.setAttributeNS(xlinkNS, t, r);
  else {
      const l = isSpecialBooleanAttr(t);
      r == null || l && !includeBooleanAttr(r) ? e.removeAttribute(t) : e.setAttribute(t, l ? "" : r)
  }
}
function patchDOMProp(e, t, r, a, o, l, f) {
  if (t === "innerHTML" || t === "textContent") {
      a && f(a, o, l),
      e[t] = r ?? "";
      return
  }
  const d = e.tagName;
  if (t === "value" && d !== "PROGRESS" && !d.includes("-")) {
      const _ = d === "OPTION" ? e.getAttribute("value") || "" : e.value
        , v = r ?? "";
      (_ !== v || !("_value"in e)) && (e.value = v),
      r == null && e.removeAttribute(t),
      e._value = r;
      return
  }
  let g = !1;
  if (r === "" || r == null) {
      const _ = typeof e[t];
      _ === "boolean" ? r = includeBooleanAttr(r) : r == null && _ === "string" ? (r = "",
      g = !0) : _ === "number" && (r = 0,
      g = !0)
  }
  try {
      e[t] = r
  } catch {}
  g && e.removeAttribute(t)
}
function addEventListener(e, t, r, a) {
  e.addEventListener(t, r, a)
}
function removeEventListener(e, t, r, a) {
  e.removeEventListener(t, r, a)
}
const veiKey = Symbol("_vei");
function patchEvent(e, t, r, a, o=null) {
  const l = e[veiKey] || (e[veiKey] = {})
    , f = l[t];
  if (a && f)
      f.value = a;
  else {
      const [d,g] = parseName(t);
      if (a) {
          const _ = l[t] = createInvoker(a, o);
          addEventListener(e, d, _, g)
      } else
          f && (removeEventListener(e, d, f, g),
          l[t] = void 0)
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(e) {
  let t;
  if (optionsModifierRE.test(e)) {
      t = {};
      let a;
      for (; a = e.match(optionsModifierRE); )
          e = e.slice(0, e.length - a[0].length),
          t[a[0].toLowerCase()] = !0
  }
  return [e[2] === ":" ? e.slice(3) : hyphenate(e.slice(2)), t]
}
let cachedNow = 0;
const p$2 = Promise.resolve()
, getNow = ()=>cachedNow || (p$2.then(()=>cachedNow = 0),
cachedNow = Date.now());
function createInvoker(e, t) {
  const r = a=>{
      if (!a._vts)
          a._vts = Date.now();
      else if (a._vts <= r.attached)
          return;
      callWithAsyncErrorHandling(patchStopImmediatePropagation(a, r.value), t, 5, [a])
  }
  ;
  return r.value = e,
  r.attached = getNow(),
  r
}
function patchStopImmediatePropagation(e, t) {
  if (isArray$1(t)) {
      const r = e.stopImmediatePropagation;
      return e.stopImmediatePropagation = ()=>{
          r.call(e),
          e._stopped = !0
      }
      ,
      t.map(a=>o=>!o._stopped && a && a(o))
  } else
      return t
}
const isNativeOn = e=>e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) > 96 && e.charCodeAt(2) < 123
, patchProp = (e,t,r,a,o,l,f,d,g)=>{
  const _ = o === "svg";
  t === "class" ? patchClass(e, a, _) : t === "style" ? patchStyle(e, r, a) : isOn(t) ? isModelListener(t) || patchEvent(e, t, r, a, f) : (t[0] === "." ? (t = t.slice(1),
  !0) : t[0] === "^" ? (t = t.slice(1),
  !1) : shouldSetAsProp(e, t, a, _)) ? patchDOMProp(e, t, a, l, f, d, g) : (t === "true-value" ? e._trueValue = a : t === "false-value" && (e._falseValue = a),
  patchAttr(e, t, a, _))
}
;
function shouldSetAsProp(e, t, r, a) {
  if (a)
      return !!(t === "innerHTML" || t === "textContent" || t in e && isNativeOn(t) && isFunction(r));
  if (t === "spellcheck" || t === "draggable" || t === "translate" || t === "form" || t === "list" && e.tagName === "INPUT" || t === "type" && e.tagName === "TEXTAREA")
      return !1;
  if (t === "width" || t === "height") {
      const o = e.tagName;
      if (o === "IMG" || o === "VIDEO" || o === "CANVAS" || o === "SOURCE")
          return !1
  }
  return isNativeOn(t) && isString(r) ? !1 : t in e
}
const getModelAssigner = e=>{
  const t = e.props["onUpdate:modelValue"] || !1;
  return isArray$1(t) ? r=>invokeArrayFns(t, r) : t
}
;
function onCompositionStart(e) {
  e.target.composing = !0
}
function onCompositionEnd(e) {
  const t = e.target;
  t.composing && (t.composing = !1,
  t.dispatchEvent(new Event("input")))
}
const assignKey = Symbol("_assign")
, vModelText = {
  created(e, {modifiers: {lazy: t, trim: r, number: a}}, o) {
      e[assignKey] = getModelAssigner(o);
      const l = a || o.props && o.props.type === "number";
      addEventListener(e, t ? "change" : "input", f=>{
          if (f.target.composing)
              return;
          let d = e.value;
          r && (d = d.trim()),
          l && (d = looseToNumber(d)),
          e[assignKey](d)
      }
      ),
      r && addEventListener(e, "change", ()=>{
          e.value = e.value.trim()
      }
      ),
      t || (addEventListener(e, "compositionstart", onCompositionStart),
      addEventListener(e, "compositionend", onCompositionEnd),
      addEventListener(e, "change", onCompositionEnd))
  },
  mounted(e, {value: t}) {
      e.value = t ?? ""
  },
  beforeUpdate(e, {value: t, modifiers: {lazy: r, trim: a, number: o}}, l) {
      if (e[assignKey] = getModelAssigner(l),
      e.composing)
          return;
      const f = o || e.type === "number" ? looseToNumber(e.value) : e.value
        , d = t ?? "";
      f !== d && (document.activeElement === e && e.type !== "range" && (r || a && e.value.trim() === d) || (e.value = d))
  }
}
, vModelCheckbox = {
  deep: !0,
  created(e, t, r) {
      e[assignKey] = getModelAssigner(r),
      addEventListener(e, "change", ()=>{
          const a = e._modelValue
            , o = getValue(e)
            , l = e.checked
            , f = e[assignKey];
          if (isArray$1(a)) {
              const d = looseIndexOf(a, o)
                , g = d !== -1;
              if (l && !g)
                  f(a.concat(o));
              else if (!l && g) {
                  const _ = [...a];
                  _.splice(d, 1),
                  f(_)
              }
          } else if (isSet(a)) {
              const d = new Set(a);
              l ? d.add(o) : d.delete(o),
              f(d)
          } else
              f(getCheckboxValue(e, l))
      }
      )
  },
  mounted: setChecked,
  beforeUpdate(e, t, r) {
      e[assignKey] = getModelAssigner(r),
      setChecked(e, t, r)
  }
};
function setChecked(e, {value: t, oldValue: r}, a) {
  e._modelValue = t,
  isArray$1(t) ? e.checked = looseIndexOf(t, a.props.value) > -1 : isSet(t) ? e.checked = t.has(a.props.value) : t !== r && (e.checked = looseEqual(t, getCheckboxValue(e, !0)))
}
function getValue(e) {
  return "_value"in e ? e._value : e.value
}
function getCheckboxValue(e, t) {
  const r = t ? "_trueValue" : "_falseValue";
  return r in e ? e[r] : t
}
const systemModifiers = ["ctrl", "shift", "alt", "meta"]
, modifierGuards = {
  stop: e=>e.stopPropagation(),
  prevent: e=>e.preventDefault(),
  self: e=>e.target !== e.currentTarget,
  ctrl: e=>!e.ctrlKey,
  shift: e=>!e.shiftKey,
  alt: e=>!e.altKey,
  meta: e=>!e.metaKey,
  left: e=>"button"in e && e.button !== 0,
  middle: e=>"button"in e && e.button !== 1,
  right: e=>"button"in e && e.button !== 2,
  exact: (e,t)=>systemModifiers.some(r=>e[`${r}Key`] && !t.includes(r))
}
, withModifiers = (e,t)=>{
  const r = e._withMods || (e._withMods = {})
    , a = t.join(".");
  return r[a] || (r[a] = (o,...l)=>{
      for (let f = 0; f < t.length; f++) {
          const d = modifierGuards[t[f]];
          if (d && d(o, t))
              return
      }
      return e(o, ...l)
  }
  )
}
, rendererOptions = extend({
  patchProp
}, nodeOps);
let renderer, enabledHydration = !1;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions))
}
function ensureHydrationRenderer() {
  return renderer = enabledHydration ? renderer : createHydrationRenderer(rendererOptions),
  enabledHydration = !0,
  renderer
}
const createApp = (...e)=>{
  const t = ensureRenderer().createApp(...e)
    , {mount: r} = t;
  return t.mount = a=>{
      const o = normalizeContainer(a);
      if (!o)
          return;
      const l = t._component;
      !isFunction(l) && !l.render && !l.template && (l.template = o.innerHTML),
      o.innerHTML = "";
      const f = r(o, !1, resolveRootNamespace(o));
      return o instanceof Element && (o.removeAttribute("v-cloak"),
      o.setAttribute("data-v-app", "")),
      f
  }
  ,
  t
}
, createSSRApp = (...e)=>{
  const t = ensureHydrationRenderer().createApp(...e)
    , {mount: r} = t;
  return t.mount = a=>{
      const o = normalizeContainer(a);
      if (o)
          return r(o, !0, resolveRootNamespace(o))
  }
  ,
  t
}
;
function resolveRootNamespace(e) {
  if (e instanceof SVGElement)
      return "svg";
  if (typeof MathMLElement == "function" && e instanceof MathMLElement)
      return "mathml"
}
function normalizeContainer(e) {
  return isString(e) ? document.querySelector(e) : e
}
const HASH_RE$1 = /#/g
, AMPERSAND_RE$1 = /&/g
, SLASH_RE$1 = /\//g
, EQUAL_RE$1 = /=/g
, PLUS_RE$1 = /\+/g
, ENC_CARET_RE$1 = /%5e/gi
, ENC_BACKTICK_RE$1 = /%60/gi
, ENC_PIPE_RE$1 = /%7c/gi
, ENC_SPACE_RE$1 = /%20/gi;
function encode(e) {
  return encodeURI("" + e).replace(ENC_PIPE_RE$1, "|")
}
function encodeQueryValue$1(e) {
  return encode(typeof e == "string" ? e : JSON.stringify(e)).replace(PLUS_RE$1, "%2B").replace(ENC_SPACE_RE$1, "+").replace(HASH_RE$1, "%23").replace(AMPERSAND_RE$1, "%26").replace(ENC_BACKTICK_RE$1, "`").replace(ENC_CARET_RE$1, "^").replace(SLASH_RE$1, "%2F")
}
function encodeQueryKey$1(e) {
  return encodeQueryValue$1(e).replace(EQUAL_RE$1, "%3D")
}
function decode$1(e="") {
  try {
      return decodeURIComponent("" + e)
  } catch {
      return "" + e
  }
}
function decodeQueryKey(e) {
  return decode$1(e.replace(PLUS_RE$1, " "))
}
function decodeQueryValue(e) {
  return decode$1(e.replace(PLUS_RE$1, " "))
}
function parseQuery$1(e="") {
  const t = {};
  e[0] === "?" && (e = e.slice(1));
  for (const r of e.split("&")) {
      const a = r.match(/([^=]+)=?(.*)/) || [];
      if (a.length < 2)
          continue;
      const o = decodeQueryKey(a[1]);
      if (o === "__proto__" || o === "constructor")
          continue;
      const l = decodeQueryValue(a[2] || "");
      t[o] === void 0 ? t[o] = l : Array.isArray(t[o]) ? t[o].push(l) : t[o] = [t[o], l]
  }
  return t
}
function encodeQueryItem(e, t) {
  return (typeof t == "number" || typeof t == "boolean") && (t = String(t)),
  t ? Array.isArray(t) ? t.map(r=>`${encodeQueryKey$1(e)}=${encodeQueryValue$1(r)}`).join("&") : `${encodeQueryKey$1(e)}=${encodeQueryValue$1(t)}` : encodeQueryKey$1(e)
}
function stringifyQuery$1(e) {
  return Object.keys(e).filter(t=>e[t] !== void 0).map(t=>encodeQueryItem(t, e[t])).filter(Boolean).join("&")
}
const PROTOCOL_STRICT_REGEX = /^[\s\w\0+.-]{2,}:([/\\]{1,2})/
, PROTOCOL_REGEX = /^[\s\w\0+.-]{2,}:([/\\]{2})?/
, PROTOCOL_RELATIVE_REGEX = /^([/\\]\s*){2,}[^/\\]/
, PROTOCOL_SCRIPT_RE = /^[\s\0]*(blob|data|javascript|vbscript):$/i
, TRAILING_SLASH_RE$1 = /\/$|\/\?|\/#/
, JOIN_LEADING_SLASH_RE = /^\.?\//;
function hasProtocol(e, t={}) {
  return typeof t == "boolean" && (t = {
      acceptRelative: t
  }),
  t.strict ? PROTOCOL_STRICT_REGEX.test(e) : PROTOCOL_REGEX.test(e) || (t.acceptRelative ? PROTOCOL_RELATIVE_REGEX.test(e) : !1)
}
function isScriptProtocol(e) {
  return !!e && PROTOCOL_SCRIPT_RE.test(e)
}
function hasTrailingSlash(e="", t) {
  return t ? TRAILING_SLASH_RE$1.test(e) : e.endsWith("/")
}
function withoutTrailingSlash(e="", t) {
  if (!t)
      return (hasTrailingSlash(e) ? e.slice(0, -1) : e) || "/";
  if (!hasTrailingSlash(e, !0))
      return e || "/";
  let r = e
    , a = "";
  const o = e.indexOf("#");
  o >= 0 && (r = e.slice(0, o),
  a = e.slice(o));
  const [l,...f] = r.split("?");
  return ((l.endsWith("/") ? l.slice(0, -1) : l) || "/") + (f.length > 0 ? `?${f.join("?")}` : "") + a
}
function withTrailingSlash(e="", t) {
  if (!t)
      return e.endsWith("/") ? e : e + "/";
  if (hasTrailingSlash(e, !0))
      return e || "/";
  let r = e
    , a = "";
  const o = e.indexOf("#");
  if (o >= 0 && (r = e.slice(0, o),
  a = e.slice(o),
  !r))
      return a;
  const [l,...f] = r.split("?");
  return l + "/" + (f.length > 0 ? `?${f.join("?")}` : "") + a
}
function hasLeadingSlash(e="") {
  return e.startsWith("/")
}
function withLeadingSlash(e="") {
  return hasLeadingSlash(e) ? e : "/" + e
}
function withBase(e, t) {
  if (isEmptyURL(t) || hasProtocol(e))
      return e;
  const r = withoutTrailingSlash(t);
  return e.startsWith(r) ? e : joinURL(r, e)
}
function withoutBase(e, t) {
  if (isEmptyURL(t))
      return e;
  const r = withoutTrailingSlash(t);
  if (!e.startsWith(r))
      return e;
  const a = e.slice(r.length);
  return a[0] === "/" ? a : "/" + a
}
function withQuery(e, t) {
  const r = parseURL$1(e)
    , a = {
      ...parseQuery$1(r.search),
      ...t
  };
  return r.search = stringifyQuery$1(a),
  stringifyParsedURL(r)
}
function isEmptyURL(e) {
  return !e || e === "/"
}
function isNonEmptyURL(e) {
  return e && e !== "/"
}
function joinURL(e, ...t) {
  let r = e || "";
  for (const a of t.filter(o=>isNonEmptyURL(o)))
      if (r) {
          const o = a.replace(JOIN_LEADING_SLASH_RE, "");
          r = withTrailingSlash(r) + o
      } else
          r = a;
  return r
}
function joinRelativeURL(...e) {
  var f, d, g, _;
  const t = /\/(?!\/)/
    , r = e.filter(Boolean)
    , a = [];
  let o = 0;
  for (const v of r)
      if (!(!v || v === "/")) {
          for (const [S,b] of v.split(t).entries())
              if (!(!b || b === ".")) {
                  if (b === "..") {
                      if (a.length === 1 && hasProtocol(a[0]))
                          continue;
                      a.pop(),
                      o--;
                      continue
                  }
                  if (S === 1 && ((f = a[a.length - 1]) != null && f.endsWith(":/"))) {
                      a[a.length - 1] += "/" + b;
                      continue
                  }
                  a.push(b),
                  o++
              }
      }
  let l = a.join("/");
  return o >= 0 ? (d = r[0]) != null && d.startsWith("/") && !l.startsWith("/") ? l = "/" + l : (g = r[0]) != null && g.startsWith("./") && !l.startsWith("./") && (l = "./" + l) : l = "../".repeat(-1 * o) + l,
  (_ = r[r.length - 1]) != null && _.endsWith("/") && !l.endsWith("/") && (l += "/"),
  l
}
function isEqual(e, t, r={}) {
  return r.trailingSlash || (e = withTrailingSlash(e),
  t = withTrailingSlash(t)),
  r.leadingSlash || (e = withLeadingSlash(e),
  t = withLeadingSlash(t)),
  r.encoding || (e = decode$1(e),
  t = decode$1(t)),
  e === t
}
const protocolRelative = Symbol.for("ufo:protocolRelative");
function parseURL$1(e="", t) {
  const r = e.match(/^[\s\0]*(blob:|data:|javascript:|vbscript:)(.*)/i);
  if (r) {
      const [,S,b=""] = r;
      return {
          protocol: S.toLowerCase(),
          pathname: b,
          href: S + b,
          auth: "",
          host: "",
          search: "",
          hash: ""
      }
  }
  if (!hasProtocol(e, {
      acceptRelative: !0
  }))
      return t ? parseURL$1(t + e) : parsePath(e);
  const [,a="",o,l=""] = e.replace(/\\/g, "/").match(/^[\s\0]*([\w+.-]{2,}:)?\/\/([^/@]+@)?(.*)/) || []
    , [,f="",d=""] = l.match(/([^#/?]*)(.*)?/) || []
    , {pathname: g, hash: v} = parsePath(d.replace(/\/(?=[A-Za-z]:)/, ""));
  return {
      protocol: a.toLowerCase(),
      auth: o ? o.slice(0, Math.max(0, o.length - 1)) : "",
      host: f,
      pathname: g,
      search: _,
      hash: v,
      [protocolRelative]: !a
  }
}
function parsePath(e="") {
  const [t="",r="",a=""] = (e.match(/([^#?]*)(\?[^#]*)?(#.*)?/) || []).splice(1);
  return {
      pathname: t,
      search: r,
      hash: a
  }
}
function stringifyParsedURL(e) {
  const t = e.pathname || ""
    , r = e.search ? (e.search.startsWith("?") ? "" : "?") + e.search : ""
    , a = e.hash || ""
    , o = e.auth ? e.auth + "@" : ""
    , l = e.host || "";
  return (e.protocol || e[protocolRelative] ? (e.protocol || "") + "//" : "") + o + l + t + r + a
}
const useRuntimeConfig$1 = ()=>{
  var e;
  return ((e = window == null ? void 0 : window.__NUXT__) == null ? void 0 : e.config) || {}
}
, appConfig = useRuntimeConfig$1().app
, baseURL = ()=>appConfig.baseURL
, buildAssetsDir = ()=>appConfig.buildAssetsDir
, buildAssetsURL = (...e)=>joinRelativeURL(publicAssetsURL(), buildAssetsDir(), ...e)
, publicAssetsURL = (...e)=>{
  const t = appConfig.cdnURL || appConfig.baseURL;
  return e.length ? joinRelativeURL(t, ...e) : t
}
;
globalThis.__buildAssetsURL = buildAssetsURL,
globalThis.__publicAssetsURL = publicAssetsURL;
const suspectProtoRx = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/
, suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/
, JsonSigRx = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function jsonParseTransform(e, t) {
  if (e === "__proto__" || e === "constructor" && t && typeof t == "object" && "prototype"in t) {
      warnKeyDropped(e);
      return
  }
  return t
}
function warnKeyDropped(e) {
  console.warn(`[destr] Dropping "${e}" key to prevent prototype pollution.`)
}
function destr(e, t={}) {
  if (typeof e != "string")
      return e;
  const r = e.trim();
  if (e[0] === '"' && e.endsWith('"') && !e.includes("\\"))
      return r.slice(1, -1);
  if (r.length <= 9) {
      const a = r.toLowerCase();
      if (a === "true")
          return !0;
      if (a === "false")
          return !1;
      if (a === "undefined")
          return;
      if (a === "null")
          return null;
      if (a === "nan")
          return Number.NaN;
      if (a === "infinity")
          return Number.POSITIVE_INFINITY;
      if (a === "-infinity")
          return Number.NEGATIVE_INFINITY
  }
  if (!JsonSigRx.test(e)) {
      if (t.strict)
          throw new SyntaxError("[destr] Invalid JSON");
      return e
  }
  try {
      if (suspectProtoRx.test(e) || suspectConstructorRx.test(e)) {
          if (t.strict)
              throw new Error("[destr] Possible prototype pollution");
          return JSON.parse(e, jsonParseTransform)
      }
      return JSON.parse(e)
  } catch (a) {
      if (t.strict)
          throw a;
      return e
  }
}
class FetchError extends Error {
  constructor(t, r) {
      super(t, r),
      this.name = "FetchError",
      r != null && r.cause && !this.cause && (this.cause = r.cause)
  }
}
function createFetchError(e) {
  var g, _, v, S, b;
  const t = ((g = e.error) == null ? void 0 : g.message) || ((_ = e.error) == null ? void 0 : _.toString()) || ""
    , r = ((v = e.request) == null ? void 0 : v.method) || ((S = e.options) == null ? void 0 : S.method) || "GET"
    , a = ((b = e.request) == null ? void 0 : b.url) || String(e.request) || "/"
    , o = `[${r}] ${JSON.stringify(a)}`
    , l = e.response ? `${e.response.status} ${e.response.statusText}` : "<no response>"
    , f = `${o}: ${l}${t ? ` ${t}` : ""}`
    , d = new FetchError(f,e.error ? {
      cause: e.error
  } : void 0);
  for (const P of ["request", "options", "response"])
      Object.defineProperty(d, P, {
          get() {
              return e[P]
          }
      });
  for (const [P,x] of [["data", "_data"], ["status", "status"], ["statusCode", "status"], ["statusText", "statusText"], ["statusMessage", "statusText"]])
      Object.defineProperty(d, P, {
          get() {
              return e.response && e.response[x]
          }
      });
  return d
}
const payloadMethods = new Set(Object.freeze(["PATCH", "POST", "PUT", "DELETE"]));
function isPayloadMethod(e="GET") {
  return payloadMethods.has(e.toUpperCase())
}
function isJSONSerializable(e) {
  if (e === void 0)
      return !1;
  const t = typeof e;
  return t === "string" || t === "number" || t === "boolean" || t === null ? !0 : t !== "object" ? !1 : Array.isArray(e) ? !0 : e.buffer ? !1 : e.constructor && e.constructor.name === "Object" || typeof e.toJSON == "function"
}
const textTypes = new Set(["image/svg", "application/xml", "application/xhtml", "application/html"])
, JSON_RE = /^application\/(?:[\w!#$%&*.^`~-]*\+)?json(;.+)?$/i;
function detectResponseType(e="") {
  if (!e)
      return "json";
  const t = e.split(";").shift() || "";
  return JSON_RE.test(t) ? "json" : textTypes.has(t) || t.startsWith("text/") ? "text" : "blob"
}
function mergeFetchOptions(e, t, r=globalThis.Headers) {
  const a = {
      ...t,
      ...e
  };
  if (t != null && t.params && (e != null && e.params) && (a.params = {
      ...t == null ? void 0 : t.params,
      ...e == null ? void 0 : e.params
  }),
  t != null && t.query && (e != null && e.query) && (a.query = {
      ...t == null ? void 0 : t.query,
      ...e == null ? void 0 : e.query
  }),
  t != null && t.headers && (e != null && e.headers)) {
      a.headers = new r((t == null ? void 0 : t.headers) || {});
      for (const [o,l] of new r((e == null ? void 0 : e.headers) || {}))
          a.headers.set(o, l)
  }
  return a
}
const retryStatusCodes = new Set([408, 409, 425, 429, 500, 502, 503, 504])
, nullBodyResponses = new Set([101, 204, 205, 304]);
function createFetch(e={}) {
  const {fetch: t=globalThis.fetch, Headers: r=globalThis.Headers, AbortController: a=globalThis.AbortController} = e;
  async function o(d) {
      const g = d.error && d.error.name === "AbortError" && !d.options.timeout || !1;
      if (d.options.retry !== !1 && !g) {
          let v;
          typeof d.options.retry == "number" ? v = d.options.retry : v = isPayloadMethod(d.options.method) ? 0 : 1;
          const S = d.response && d.response.status || 500;
          if (v > 0 && (Array.isArray(d.options.retryStatusCodes) ? d.options.retryStatusCodes.includes(S) : retryStatusCodes.has(S))) {
              const b = d.options.retryDelay || 0;
              return b > 0 && await new Promise(P=>setTimeout(P, b)),
              l(d.request, {
                  ...d.options,
                  retry: v - 1
              })
          }
      }
      const _ = createFetchError(d);
      throw Error.captureStackTrace && Error.captureStackTrace(_, l),
      _
  }
  const l = async function(g, _={}) {
      var P;
      const v = {
          request: g,
          options: mergeFetchOptions(_, e.defaults, r),
          response: void 0,
          error: void 0
      };
      v.options.method = (P = v.options.method) == null ? void 0 : P.toUpperCase(),
      v.options.onRequest && await v.options.onRequest(v),
      typeof v.request == "string" && (v.options.baseURL && (v.request = withBase(v.request, v.options.baseURL)),
      (v.options.query || v.options.params) && (v.request = withQuery(v.request, {
          ...v.options.params,
          ...v.options.query
      }))),
      v.options.body && isPayloadMethod(v.options.method) && (isJSONSerializable(v.options.body) ? (v.options.body = typeof v.options.body == "string" ? v.options.body : JSON.stringify(v.options.body),
      v.options.headers = new r(v.options.headers || {}),
      v.options.headers.has("content-type") || v.options.headers.set("content-type", "application/json"),
      v.options.headers.has("accept") || v.options.headers.set("accept", "application/json")) : ("pipeTo"in v.options.body && typeof v.options.body.pipeTo == "function" || typeof v.options.body.pipe == "function") && ("duplex"in v.options || (v.options.duplex = "half")));
      let S;
      if (!v.options.signal && v.options.timeout) {
          const x = new a;
          S = setTimeout(()=>x.abort(), v.options.timeout),
          v.options.signal = x.signal
      }
      try {
          v.response = await t(v.request, v.options)
      } catch (x) {
          return v.error = x,
          v.options.onRequestError && await v.options.onRequestError(v),
          await o(v)
      } finally {
          S && clearTimeout(S)
      }
      if (v.response.body && !nullBodyResponses.has(v.response.status) && v.options.method !== "HEAD") {
          const x = (v.options.parseResponse ? "json" : v.options.responseType) || detectResponseType(v.response.headers.get("content-type") || "");
          switch (x) {
          case "json":
              {
                  const E = await v.response.text()
                    , I = v.options.parseResponse || destr;
                  v.response._data = I(E);
                  break
              }
          case "stream":
              {
                  v.response._data = v.response.body;
                  break
              }
          default:
              v.response._data = await v.response[x]()
          }
      }
      return v.options.onResponse && await v.options.onResponse(v),
      !v.options.ignoreResponseError && v.response.status >= 400 && v.response.status < 600 ? (v.options.onResponseError && await v.options.onResponseError(v),
      await o(v)) : v.response
  }
    , f = async function(g, _) {
      return (await l(g, _))._data
  };
  return f.raw = l,
  f.native = (...d)=>t(...d),
  f.create = (d={})=>createFetch({
      ...e,
      defaults: {
          ...e.defaults,
          ...d
      }
  }),
  f
}
const _globalThis$1 = function() {
  if (typeof globalThis < "u")
      return globalThis;
  if (typeof self < "u")
      return self;
  if (typeof window < "u")
      return window;
  if (typeof global < "u")
      return global;
  throw new Error("unable to locate global object")
}()
, fetch$1 = _globalThis$1.fetch || (()=>Promise.reject(new Error("[ofetch] global.fetch is not supported!")))
, Headers = _globalThis$1.Headers
, AbortController = _globalThis$1.AbortController
, ofetch = createFetch({
  fetch: fetch$1,
  Headers,
  AbortController
})
, $fetch$1 = ofetch;
globalThis.$fetch || (globalThis.$fetch = $fetch$1.create({
  baseURL: baseURL()
}));
function flatHooks(e, t={}, r) {
  for (const a in e) {
      const o = e[a]
        , l = r ? `${r}:${a}` : a;
      typeof o == "object" && o !== null ? flatHooks(o, t, l) : typeof o == "function" && (t[l] = o)
  }
  return t
}
const defaultTask = {
  run: e=>e()
}
, _createTask = ()=>defaultTask
, createTask = typeof console.createTask < "u" ? console.createTask : _createTask;
function serialTaskCaller(e, t) {
  const r = t.shift()
    , a = createTask(r);
  return e.reduce((o,l)=>o.then(()=>a.run(()=>l(...t))), Promise.resolve())
}
function parallelTaskCaller(e, t) {
  const r = t.shift()
    , a = createTask(r);
  return Promise.all(e.map(o=>a.run(()=>o(...t))))
}
function callEachWith(e, t) {
  for (const r of [...e])
      r(t)
}
class Hookable {
  constructor() {
      this._hooks = {},
      this._before = void 0,
      this._after = void 0,
      this._deprecatedMessages = void 0,
      this._deprecatedHooks = {},
      this.hook = this.hook.bind(this),
      this.callHook = this.callHook.bind(this),
      this.callHookWith = this.callHookWith.bind(this)
  }
  hook(t, r, a={}) {
      if (!t || typeof r != "function")
          return ()=>{}
          ;
      const o = t;
      let l;
      for (; this._deprecatedHooks[t]; )
          l = this._deprecatedHooks[t],
          t = l.to;
      if (l && !a.allowDeprecated) {
          let f = l.message;
          f || (f = `${o} hook has been deprecated` + (l.to ? `, please use ${l.to}` : "")),
          this._deprecatedMessages || (this._deprecatedMessages = new Set),
          this._deprecatedMessages.has(f) || (console.warn(f),
          this._deprecatedMessages.add(f))
      }
      if (!r.name)
          try {
              Object.defineProperty(r, "name", {
                  get: ()=>"_" + t.replace(/\W+/g, "_") + "_hook_cb",
                  configurable: !0
              })
          } catch {}
      return this._hooks[t] = this._hooks[t] || [],
      this._hooks[t].push(r),
      ()=>{
          r && (this.removeHook(t, r),
          r = void 0)
      }
  }
  hookOnce(t, r) {
      let a, o = (...l)=>(typeof a == "function" && a(),
      a = void 0,
      o = void 0,
      r(...l));
      return a = this.hook(t, o),
      a
  }
  removeHook(t, r) {
      if (this._hooks[t]) {
          const a = this._hooks[t].indexOf(r);
          a !== -1 && this._hooks[t].splice(a, 1),
          this._hooks[t].length === 0 && delete this._hooks[t]
      }
  }
  deprecateHook(t, r) {
      this._deprecatedHooks[t] = typeof r == "string" ? {
          to: r
      } : r;
      const a = this._hooks[t] || [];
      delete this._hooks[t];
      for (const o of a)
          this.hook(t, o)
  }
  deprecateHooks(t) {
      Object.assign(this._deprecatedHooks, t);
      for (const r in t)
          this.deprecateHook(r, t[r])
  }
  addHooks(t) {
      const r = flatHooks(t)
        , a = Object.keys(r).map(o=>this.hook(o, r[o]));
      return ()=>{
          for (const o of a.splice(0, a.length))
              o()
      }
  }
  removeHooks(t) {
      const r = flatHooks(t);
      for (const a in r)
          this.removeHook(a, r[a])
  }
  removeAllHooks() {
      for (const t in this._hooks)
          delete this._hooks[t]
  }
  callHook(t, ...r) {
      return r.unshift(t),
      this.callHookWith(serialTaskCaller, t, ...r)
  }
  callHookParallel(t, ...r) {
      return r.unshift(t),
      this.callHookWith(parallelTaskCaller, t, ...r)
  }
  callHookWith(t, r, ...a) {
      const o = this._before || this._after ? {
          name: r,
          args: a,
          context: {}
      } : void 0;
      this._before && callEachWith(this._before, o);
      const l = t(r in this._hooks ? [...this._hooks[r]] : [], a);
      return l instanceof Promise ? l.finally(()=>{
          this._after && o && callEachWith(this._after, o)
      }
      ) : (this._after && o && callEachWith(this._after, o),
      l)
  }
  beforeEach(t) {
      return this._before = this._before || [],
      this._before.push(t),
      ()=>{
          if (this._before !== void 0) {
              const r = this._before.indexOf(t);
              r !== -1 && this._before.splice(r, 1)
          }
      }
  }
  afterEach(t) {
      return this._after = this._after || [],
      this._after.push(t),
      ()=>{
          if (this._after !== void 0) {
              const r = this._after.indexOf(t);
              r !== -1 && this._after.splice(r, 1)
          }
      }
  }
}
function createHooks() {
  return new Hookable
}
function createContext(e={}) {
  let t, r = !1;
  const a = f=>{
      if (t && t !== f)
          throw new Error("Context conflict")
  }
  ;
  let o;
  if (e.asyncContext) {
      const f = e.AsyncLocalStorage || globalThis.AsyncLocalStorage;
      f ? o = new f : console.warn("[unctx] `AsyncLocalStorage` is not provided.")
  }
  const l = ()=>{
      if (o && t === void 0) {
          const f = o.getStore();
          if (f !== void 0)
              return f
      }
      return t
  }
  ;
  return {
      use: ()=>{
          const f = l();
          if (f === void 0)
              throw new Error("Context is not available");
          return f
      }
      ,
      tryUse: ()=>l(),
      set: (f,d)=>{
          d || a(f),
          t = f,
          r = !0
      }
      ,
      unset: ()=>{
          t = void 0,
          r = !1
      }
      ,
      call: (f,d)=>{
          a(f),
          t = f;
          try {
              return o ? o.run(f, d) : d()
          } finally {
              r || (t = void 0)
          }
      }
      ,
      async callAsync(f, d) {
          t = f;
          const g = ()=>{
              t = f
          }
            , _ = ()=>t === f ? g : void 0;
          asyncHandlers.add(_);
          try {
              const v = o ? o.run(f, d) : d();
              return r || (t = void 0),
              await v
          } finally {
              asyncHandlers.delete(_)
          }
      }
  }
}
function createNamespace(e={}) {
  const t = {};
  return {
      get(r, a={}) {
          return t[r] || (t[r] = createContext({
              ...e,
              ...a
          })),
          t[r],
          t[r]
      }
  }
}
const _globalThis = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof global < "u" ? global : typeof window < "u" ? window : {}
, globalKey$1 = "__unctx__"
, defaultNamespace = _globalThis[globalKey$1] || (_globalThis[globalKey$1] = createNamespace())
, getContext = (e,t={})=>defaultNamespace.get(e, t)
, asyncHandlersKey = "__unctx_async_handlers__"
, asyncHandlers = _globalThis[asyncHandlersKey] || (_globalThis[asyncHandlersKey] = new Set);
function executeAsync(e) {
  const t = [];
  for (const o of asyncHandlers) {
      const l = o();
      l && t.push(l)
  }
  const r = ()=>{
      for (const o of t)
          o()
  }
  ;
  let a = e();
  return a && typeof a == "object" && "catch"in a && (a = a.catch(o=>{
      throw r(),
      o
  }
  )),
  [a, r]
}
const nuxtAppCtx = getContext("nuxt-app", {
  asyncContext: !1
})
, NuxtPluginIndicator = "__nuxt_plugin";
function createNuxtApp(e) {
  let t = 0;
  const r = {
      _scope: effectScope(),
      provide: void 0,
      globalName: "nuxt",
      versions: {
          get nuxt() {
              return "3.11.1"
          },
          get vue() {
              return r.vueApp.version
          }
      },
      payload: reactive({
          data: {},
          state: {},
          once: new Set,
          _errors: {},
          ...window.__NUXT__ ?? {}
      }),
      static: {
          data: {}
      },
      runWithContext: o=>r._scope.run(()=>callWithNuxt(r, o)),
      isHydrating: !0,
      deferHydration() {
          if (!r.isHydrating)
              return ()=>{}
              ;
          t++;
          let o = !1;
          return ()=>{
              if (!o && (o = !0,
              t--,
              t === 0))
                  return r.isHydrating = !1,
                  r.callHook("app:suspense:resolve")
          }
      },
      _asyncDataPromises: {},
      _asyncData: {},
      _payloadRevivers: {},
      ...e
  };
  r.hooks = createHooks(),
  r.hook = r.hooks.hook,
  r.callHook = r.hooks.callHook,
  r.provide = (o,l)=>{
      const f = "$" + o;
      defineGetter(r, f, l),
      defineGetter(r.vueApp.config.globalProperties, f, l)
  }
  ,
  defineGetter(r.vueApp, "$nuxt", r),
  defineGetter(r.vueApp.config.globalProperties, "$nuxt", r);
  {
      window.addEventListener("nuxt.preloadError", l=>{
          r.callHook("app:chunkError", {
              error: l.payload
          })
      }
      ),
      window.useNuxtApp = window.useNuxtApp || useNuxtApp;
      const o = r.hook("app:error", (...l)=>{
          console.error("[nuxt] error caught during app initialization", ...l)
      }
      );
      r.hook("app:mounted", o)
  }
  const a = reactive(r.payload.config);
  return r.provide("config", a),
  r
}
async function applyPlugin(e, t) {
  if (t.hooks && e.hooks.addHooks(t.hooks),
  typeof t == "function") {
      const {provide: r} = await e.runWithContext(()=>t(e)) || {};
      if (r && typeof r == "object")
          for (const a in r)
              e.provide(a, r[a])
  }
}
async function applyPlugins(e, t) {
  const r = []
    , a = []
    , o = []
    , l = [];
  let f = 0;
  async function d(g) {
      var v;
      const _ = ((v = g.dependsOn) == null ? void 0 : v.filter(S=>t.some(b=>b._name === S) && !r.includes(S))) ?? [];
      if (_.length > 0)
          a.push([new Set(_), g]);
      else {
          const S = applyPlugin(e, g).then(async()=>{
              g._name && (r.push(g._name),
              await Promise.all(a.map(async([b,P])=>{
                  b.has(g._name) && (b.delete(g._name),
                  b.size === 0 && (f++,
                  await d(P)))
              }
              )))
          }
          );
          g.parallel ? o.push(S.catch(b=>l.push(b))) : await S
      }
  }
  for (const g of t)
      await d(g);
  if (await Promise.all(o),
  f)
      for (let g = 0; g < f; g++)
          await Promise.all(o);
  if (l.length)
      throw l[0]
}
function defineNuxtPlugin(e) {
  if (typeof e == "function")
      return e;
  const t = e._name || e.name;
  return delete e.name,
  Object.assign(e.setup || (()=>{}
  ), e, {
      [NuxtPluginIndicator]: !0,
      _name: t
  })
}
function callWithNuxt(e, t, r) {
  const a = ()=>r ? t(...r) : t();
  return nuxtAppCtx.set(e),
  e.vueApp.runWithContext(a)
}
function tryUseNuxtApp() {
  var t;
  let e;
  return hasInjectionContext() && (e = (t = getCurrentInstance()) == null ? void 0 : t.appContext.app.$nuxt),
  e = e || nuxtAppCtx.tryUse(),
  e || null
}
function useNuxtApp() {
  const e = tryUseNuxtApp();
  if (!e)
      throw new Error("[nuxt] instance unavailable");
  return e
}
function useRuntimeConfig(e) {
  return useNuxtApp().$config
}
function defineGetter(e, t, r) {
  Object.defineProperty(e, t, {
      get: ()=>r
  })
}
function _createMatcher(e, t) {
  return {
      ctx: {
          table: e
      },
      matchAll: r=>_matchRoutes(r, e, t)
  }
}
function _createTableFromExport(e) {
  const t = {};
  for (const r in e)
      t[r] = r === "dynamic" ? new Map(Object.entries(e[r]).map(([a,o])=>[a, _createTableFromExport(o)])) : new Map(Object.entries(e[r]));
  return t
}
function createMatcherFromExport(e) {
  return _createMatcher(_createTableFromExport(e))
}
function _matchRoutes(e, t, r) {
  r !== !0 && e.endsWith("/") && (e = e.slice(0, -1) || "/");
  const a = [];
  for (const [l,f] of _sortRoutesMap(t.wildcard))
      (e === l || e.startsWith(l + "/")) && a.push(f);
  for (const [l,f] of _sortRoutesMap(t.dynamic))
      if (e.startsWith(l + "/")) {
          const d = "/" + e.slice(l.length).split("/").splice(2).join("/");
          a.push(..._matchRoutes(d, f))
      }
  const o = t.static.get(e);
  return o && a.push(o),
  a.filter(Boolean)
}
function _sortRoutesMap(e) {
  return [...e.entries()].sort((t,r)=>t[0].length - r[0].length)
}
function isPlainObject(e) {
  if (e === null || typeof e != "object")
      return !1;
  const t = Object.getPrototypeOf(e);
  return t !== null && t !== Object.prototype && Object.getPrototypeOf(t) !== null || Symbol.iterator in e ? !1 : Symbol.toStringTag in e ? Object.prototype.toString.call(e) === "[object Module]" : !0
}
function _defu(e, t, r=".", a) {
  if (!isPlainObject(t))
      return _defu(e, {}, r, a);
  const o = Object.assign({}, t);
  for (const l in e) {
      if (l === "__proto__" || l === "constructor")
          continue;
      const f = e[l];
      f != null && (a && a(o, l, f, r) || (Array.isArray(f) && Array.isArray(o[l]) ? o[l] = [...f, ...o[l]] : isPlainObject(f) && isPlainObject(o[l]) ? o[l] = _defu(f, o[l], (r ? `${r}.` : "") + l.toString(), a) : o[l] = f))
  }
  return o
}
function createDefu(e) {
  return (...t)=>t.reduce((r,a)=>_defu(r, a, "", e), {})
}
const defu = createDefu()
, defuFn = createDefu((e,t,r)=>{
  if (e[t] !== void 0 && typeof r == "function")
      return e[t] = r(e[t]),
      !0
}
);
function hasProp(e, t) {
  try {
      return t in e
  } catch {
      return !1
  }
}
var __defProp$2 = Object.defineProperty
, __defNormalProp$2 = (e,t,r)=>t in e ? __defProp$2(e, t, {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: r
}) : e[t] = r
, __publicField$2 = (e,t,r)=>(__defNormalProp$2(e, typeof t != "symbol" ? t + "" : t, r),
r);
class H3Error extends Error {
  constructor(t, r={}) {
      super(t, r),
      __publicField$2(this, "statusCode", 500),
      __publicField$2(this, "fatal", !1),
      __publicField$2(this, "unhandled", !1),
      __publicField$2(this, "statusMessage"),
      __publicField$2(this, "data"),
      __publicField$2(this, "cause"),
      r.cause && !this.cause && (this.cause = r.cause)
  }
  toJSON() {
      const t = {
          message: this.message,
          statusCode: sanitizeStatusCode(this.statusCode, 500)
      };
      return this.statusMessage && (t.statusMessage = sanitizeStatusMessage(this.statusMessage)),
      this.data !== void 0 && (t.data = this.data),
      t
  }
}
__publicField$2(H3Error, "__h3_error__", !0);
function createError$1(e) {
  if (typeof e == "string")
      return new H3Error(e);
  if (isError(e))
      return e;
  const t = new H3Error(e.message ?? e.statusMessage ?? "",{
      cause: e.cause || e
  });
  if (hasProp(e, "stack"))
      try {
          Object.defineProperty(t, "stack", {
              get() {
                  return e.stack
              }
          })
      } catch {
          try {
              t.stack = e.stack
          } catch {}
      }
  if (e.data && (t.data = e.data),
  e.statusCode ? t.statusCode = sanitizeStatusCode(e.statusCode, t.statusCode) : e.status && (t.statusCode = sanitizeStatusCode(e.status, t.statusCode)),
  e.statusMessage ? t.statusMessage = e.statusMessage : e.statusText && (t.statusMessage = e.statusText),
  t.statusMessage) {
      const r = t.statusMessage;
      sanitizeStatusMessage(t.statusMessage) !== r && console.warn("[h3] Please prefer using `message` for longer error messages instead of `statusMessage`. In the future, `statusMessage` will be sanitized by default.")
  }
  return e.fatal !== void 0 && (t.fatal = e.fatal),
  e.unhandled !== void 0 && (t.unhandled = e.unhandled),
  t
}
function isError(e) {
  var t;
  return ((t = e == null ? void 0 : e.constructor) == null ? void 0 : t.__h3_error__) === !0
}
const DISALLOWED_STATUS_CHARS = /[^\u0009\u0020-\u007E]/g;
function sanitizeStatusMessage(e="") {
  return e.replace(DISALLOWED_STATUS_CHARS, "")
}
function sanitizeStatusCode(e, t=200) {
  return !e || (typeof e == "string" && (e = Number.parseInt(e, 10)),
  e < 100 || e > 999) ? t : e
}
typeof setImmediate > "u" || setImmediate;
const LayoutMetaSymbol = Symbol("layout-meta")
, PageRouteSymbol = Symbol("route")
, useRouter = ()=>{
  var e;
  return (e = useNuxtApp()) == null ? void 0 : e.$router
}
, useRoute$1 = ()=>hasInjectionContext() ? inject(PageRouteSymbol, useNuxtApp()._route) : useNuxtApp()._route;
function defineNuxtRouteMiddleware(e) {
  return e
}
const isProcessingMiddleware = ()=>{
  try {
      if (useNuxtApp()._processingMiddleware)
          return !0
  } catch {
      return !0
  }
  return !1
}
, navigateTo = (e,t)=>{
  e || (e = "/");
  const r = typeof e == "string" ? e : withQuery(e.path || "/", e.query || {}) + (e.hash || "");
  if (t != null && t.open) {
      {
          const {target: d="_blank", windowFeatures: g={}} = t.open
            , _ = Object.entries(g).filter(([v,S])=>S !== void 0).map(([v,S])=>`${v.toLowerCase()}=${S}`).join(", ");
          open(r, d, _)
      }
      return Promise.resolve()
  }
  const a = (t == null ? void 0 : t.external) || hasProtocol(r, {
      acceptRelative: !0
  });
  if (a) {
      if (!(t != null && t.external))
          throw new Error("Navigating to an external URL is not allowed by default. Use `navigateTo(url, { external: true })`.");
      const d = parseURL$1(r).protocol;
      if (d && isScriptProtocol(d))
          throw new Error(`Cannot navigate to a URL with '${d}' protocol.`)
  }
  const o = isProcessingMiddleware();
  if (!a && o)
      return e;
  const l = useRouter()
    , f = useNuxtApp();
  return a ? (f._scope.stop(),
  t != null && t.replace ? location.replace(r) : location.href = r,
  o ? f.isHydrating ? new Promise(()=>{}
  ) : !1 : Promise.resolve()) : t != null && t.replace ? l.replace(e) : l.push(e)
}
, NUXT_ERROR_SIGNATURE = "__nuxt_error"
, useError = ()=>toRef(useNuxtApp().payload, "error")
, showError = e=>{
  const t = createError(e);
  try {
      const r = useNuxtApp()
        , a = useError();
      r.hooks.callHook("app:error", t),
      a.value = a.value || t
  } catch {
      throw t
  }
  return t
}
, clearError = async(e={})=>{
  const t = useNuxtApp()
    , r = useError();
  t.callHook("app:error:cleared", e),
  e.redirect && await useRouter().replace(e.redirect),
  r.value = null
}
, isNuxtError = e=>!!e && typeof e == "object" && NUXT_ERROR_SIGNATURE in e
, createError = e=>{
  const t = createError$1(e);
  return Object.defineProperty(t, NUXT_ERROR_SIGNATURE, {
      value: !0,
      configurable: !1,
      writable: !1
  }),
  t
}
, scriptRel = "modulepreload"
, assetsURL = function(e, t) {
  return e[0] === "." ? new URL(e,t).href : e
}
, seen = {}
, ___vitePreload = function(t, r, a) {
  let o = Promise.resolve();
  if (r && r.length > 0) {
      const l = document.getElementsByTagName("link")
        , f = document.querySelector("meta[property=csp-nonce]")
        , d = (f == null ? void 0 : f.nonce) || (f == null ? void 0 : f.getAttribute("nonce"));
      o = Promise.all(r.map(g=>{
          if (g = assetsURL(g, a),
          g in seen)
              return;
          seen[g] = !0;
          const _ = g.endsWith(".css")
            , v = _ ? '[rel="stylesheet"]' : "";
          if (!!a)
              for (let P = l.length - 1; P >= 0; P--) {
                  const x = l[P];
                  if (x.href === g && (!_ || x.rel === "stylesheet"))
                      return
              }
          else if (document.querySelector(`link[href="${g}"]${v}`))
              return;
          const b = document.createElement("link");
          if (b.rel = _ ? "stylesheet" : scriptRel,
          _ || (b.as = "script",
          b.crossOrigin = ""),
          b.href = g,
          d && b.setAttribute("nonce", d),
          document.head.appendChild(b),
          _)
              return new Promise((P,x)=>{
                  b.addEventListener("load", P),
                  b.addEventListener("error", ()=>x(new Error(`Unable to preload CSS for ${g}`)))
              }
              )
      }
      ))
  }
  return o.then(()=>t()).catch(l=>{
      const f = new Event("vite:preloadError",{
          cancelable: !0
      });
      if (f.payload = l,
      window.dispatchEvent(f),
      !f.defaultPrevented)
          throw l
  }
  )
}
, __vitePreload = (...e)=>___vitePreload(...e).catch(t=>{
  const r = new Event("nuxt.preloadError");
  throw r.payload = t,
  window.dispatchEvent(r),
  t
}
)
, UNDEFINED = -1
, HOLE = -2
, NAN = -3
, POSITIVE_INFINITY = -4
, NEGATIVE_INFINITY = -5
, NEGATIVE_ZERO = -6;
function parse(e, t) {
  return unflatten(JSON.parse(e), t)
}
function unflatten(e, t) {
  if (typeof e == "number")
      return o(e, !0);
  if (!Array.isArray(e) || e.length === 0)
      throw new Error("Invalid input");
  const r = e
    , a = Array(r.length);
  function o(l, f=!1) {
      if (l === UNDEFINED)
          return;
      if (l === NAN)
          return NaN;
      if (l === POSITIVE_INFINITY)
          return 1 / 0;
      if (l === NEGATIVE_INFINITY)
          return -1 / 0;
      if (l === NEGATIVE_ZERO)
          return -0;
      if (f)
          throw new Error("Invalid input");
      if (l in a)
          return a[l];
      const d = r[l];
      if (!d || typeof d != "object")
          a[l] = d;
      else if (Array.isArray(d))
          if (typeof d[0] == "string") {
              const g = d[0]
                , _ = t == null ? void 0 : t[g];
              if (_)
                  return a[l] = _(o(d[1]));
              switch (g) {
              case "Date":
                  a[l] = new Date(d[1]);
                  break;
              case "Set":
                  const v = new Set;
                  a[l] = v;
                  for (let P = 1; P < d.length; P += 1)
                      v.add(o(d[P]));
                  break;
              case "Map":
                  const S = new Map;
                  a[l] = S;
                  for (let P = 1; P < d.length; P += 2)
                      S.set(o(d[P]), o(d[P + 1]));
                  break;
              case "RegExp":
                  a[l] = new RegExp(d[1],d[2]);
                  break;
              case "Object":
                  a[l] = Object(d[1]);
                  break;
              case "BigInt":
                  a[l] = BigInt(d[1]);
                  break;
              case "null":
                  const b = Object.create(null);
                  a[l] = b;
                  for (let P = 1; P < d.length; P += 2)
                      b[d[P]] = o(d[P + 1]);
                  break;
              default:
                  throw new Error(`Unknown type ${g}`)
              }
          } else {
              const g = new Array(d.length);
              a[l] = g;
              for (let _ = 0; _ < d.length; _ += 1) {
                  const v = d[_];
                  v !== HOLE && (g[_] = o(v))
              }
          }
      else {
          const g = {};
          a[l] = g;
          for (const _ in d) {
              const v = d[_];
              g[_] = o(v)
          }
      }
      return a[l]
  }
  return o(0)
}
function asArray$1(e) {
  return Array.isArray(e) ? e : [e]
}
const TagsWithInnerContent = ["title", "titleTemplate", "script", "style", "noscript"]
, HasElementTags = ["base", "meta", "link", "style", "script", "noscript"]
, ValidHeadTags = ["title", "titleTemplate", "templateParams", "base", "htmlAttrs", "bodyAttrs", "meta", "link", "style", "script", "noscript"]
, UniqueTags = ["base", "title", "titleTemplate", "bodyAttrs", "htmlAttrs", "templateParams"]
, TagConfigKeys = ["tagPosition", "tagPriority", "tagDuplicateStrategy", "children", "innerHTML", "textContent", "processTemplateParams"]
, IsBrowser = typeof window < "u";
function defineHeadPlugin(e) {
  return e
}
function hashCode(e) {
  let t = 9;
  for (let r = 0; r < e.length; )
      t = Math.imul(t ^ e.charCodeAt(r++), 9 ** 9);
  return ((t ^ t >>> 9) + 65536).toString(16).substring(1, 8).toLowerCase()
}
function hashTag(e) {
  return e._h || hashCode(e._d ? e._d : `${e.tag}:${e.textContent || e.innerHTML || ""}:${Object.entries(e.props).map(([t,r])=>`${t}:${String(r)}`).join(",")}`)
}
function tagDedupeKey(e, t) {
  const {props: r, tag: a} = e;
  if (UniqueTags.includes(a))
      return a;
  if (a === "link" && r.rel === "canonical")
      return "canonical";
  if (r.charset)
      return "charset";
  const o = ["id"];
  a === "meta" && o.push("name", "property", "http-equiv");
  for (const l of o)
      if (typeof r[l] < "u") {
          const f = String(r[l]);
          return t && !t(f) ? !1 : `${a}:${l}:${f}`
      }
  return !1
}
function resolveTitleTemplate(e, t) {
  return e == null ? t || null : typeof e == "function" ? e(t) : e
}
function unpackToArray(e, t) {
  const r = []
    , a = t.resolveKeyData || (l=>l.key)
    , o = t.resolveValueData || (l=>l.value);
  for (const [l,f] of Object.entries(e))
      r.push(...(Array.isArray(f) ? f : [f]).map(d=>{
          const g = {
              key: l,
              value: d
          }
            , _ = o(g);
          return typeof _ == "object" ? unpackToArray(_, t) : Array.isArray(_) ? _ : {
              [typeof t.key == "function" ? t.key(g) : t.key]: a(g),
              [typeof t.value == "function" ? t.value(g) : t.value]: _
          }
      }
      ).flat());
  return r
}
function unpackToString(e, t) {
  return Object.entries(e).map(([r,a])=>{
      if (typeof a == "object" && (a = unpackToString(a, t)),
      t.resolve) {
          const o = t.resolve({
              key: r,
              value: a
          });
          if (typeof o < "u")
              return o
      }
      return typeof a == "number" && (a = a.toString()),
      typeof a == "string" && t.wrapValue && (a = a.replace(new RegExp(t.wrapValue,"g"), `\\${t.wrapValue}`),
      a = `${t.wrapValue}${a}${t.wrapValue}`),
      `${r}${t.keyValueSeparator || ""}${a}`
  }
  ).join(t.entrySeparator || "")
}
const p$1 = e=>({
  keyValue: e,
  metaKey: "property"
})
, k = e=>({
  keyValue: e
})
, MetaPackingSchema = {
  appleItunesApp: {
      unpack: {
          entrySeparator: ", ",
          resolve({key: e, value: t}) {
              return `${fixKeyCase(e)}=${t}`
          }
      }
  },
  articleExpirationTime: p$1("article:expiration_time"),
  articleModifiedTime: p$1("article:modified_time"),
  articlePublishedTime: p$1("article:published_time"),
  bookReleaseDate: p$1("book:release_date"),
  charset: {
      metaKey: "charset"
  },
  contentSecurityPolicy: {
      unpack: {
          entrySeparator: "; ",
          resolve({key: e, value: t}) {
              return `${fixKeyCase(e)} ${t}`
          }
      },
      metaKey: "http-equiv"
  },
  contentType: {
      metaKey: "http-equiv"
  },
  defaultStyle: {
      metaKey: "http-equiv"
  },
  fbAppId: p$1("fb:app_id"),
  msapplicationConfig: k("msapplication-Config"),
  msapplicationTileColor: k("msapplication-TileColor"),
  msapplicationTileImage: k("msapplication-TileImage"),
  ogAudioSecureUrl: p$1("og:audio:secure_url"),
  ogAudioUrl: p$1("og:audio"),
  ogImageSecureUrl: p$1("og:image:secure_url"),
  ogImageUrl: p$1("og:image"),
  ogSiteName: p$1("og:site_name"),
  ogVideoSecureUrl: p$1("og:video:secure_url"),
  ogVideoUrl: p$1("og:video"),
  profileFirstName: p$1("profile:first_name"),
  profileLastName: p$1("profile:last_name"),
  profileUsername: p$1("profile:username"),
  refresh: {
      metaKey: "http-equiv",
      unpack: {
          entrySeparator: ";",
          resolve({key: e, value: t}) {
              if (e === "seconds")
                  return `${t}`
          }
      }
  },
  robots: {
      unpack: {
          entrySeparator: ", ",
          resolve({key: e, value: t}) {
              return typeof t == "boolean" ? `${fixKeyCase(e)}` : `${fixKeyCase(e)}:${t}`
          }
      }
  },
  xUaCompatible: {
      metaKey: "http-equiv"
  }
}
, openGraphNamespaces = ["og", "book", "article", "profile"];
function resolveMetaKeyType(e) {
  var r;
  const t = fixKeyCase(e).split(":")[0];
  return openGraphNamespaces.includes(t) ? "property" : ((r = MetaPackingSchema[e]) == null ? void 0 : r.metaKey) || "name"
}
function resolveMetaKeyValue(e) {
  var t;
  return ((t = MetaPackingSchema[e]) == null ? void 0 : t.keyValue) || fixKeyCase(e)
}
function fixKeyCase(e) {
  const t = e.replace(/([A-Z])/g, "-$1").toLowerCase()
    , r = t.split("-")[0];
  return openGraphNamespaces.includes(r) || r === "twitter" ? e.replace(/([A-Z])/g, ":$1").toLowerCase() : t
}
function changeKeyCasingDeep(e) {
  if (Array.isArray(e))
      return e.map(r=>changeKeyCasingDeep(r));
  if (typeof e != "object" || Array.isArray(e))
      return e;
  const t = {};
  for (const [r,a] of Object.entries(e))
      t[fixKeyCase(r)] = changeKeyCasingDeep(a);
  return t
}
function resolvePackedMetaObjectValue(e, t) {
  const r = MetaPackingSchema[t];
  return t === "refresh" ? `${e.seconds};url=${e.url}` : unpackToString(changeKeyCasingDeep(e), {
      keyValueSeparator: "=",
      entrySeparator: ", ",
      resolve({value: a, key: o}) {
          if (a === null)
              return "";
          if (typeof a == "boolean")
              return `${o}`
      },
      ...r == null ? void 0 : r.unpack
  })
}
const ObjectArrayEntries = ["og:image", "og:video", "og:audio", "twitter:image"];
function sanitize(e) {
  const t = {};
  return Object.entries(e).forEach(([r,a])=>{
      String(a) !== "false" && r && (t[r] = a)
  }
  ),
  t
}
function handleObjectEntry(e, t) {
  const r = sanitize(t)
    , a = fixKeyCase(e)
    , o = resolveMetaKeyType(a);
  if (ObjectArrayEntries.includes(a)) {
      const l = {};
      return Object.entries(r).forEach(([f,d])=>{
          l[`${e}${f === "url" ? "" : `${f.charAt(0).toUpperCase()}${f.slice(1)}`}`] = d
      }
      ),
      unpackMeta(l).sort((f,d)=>{
          var g, _;
          return (((g = f[o]) == null ? void 0 : g.length) || 0) - (((_ = d[o]) == null ? void 0 : _.length) || 0)
      }
      )
  }
  return [{
      [o]: a,
      ...r
  }]
}
function unpackMeta(e) {
  const t = []
    , r = {};
  Object.entries(e).forEach(([o,l])=>{
      if (!Array.isArray(l)) {
          if (typeof l == "object" && l) {
              if (ObjectArrayEntries.includes(fixKeyCase(o))) {
                  t.push(...handleObjectEntry(o, l));
                  return
              }
              r[o] = sanitize(l)
          } else
              r[o] = l;
          return
      }
      l.forEach(f=>{
          t.push(...typeof f == "string" ? unpackMeta({
              [o]: f
          }) : handleObjectEntry(o, f))
      }
      )
  }
  );
  const a = unpackToArray(r, {
      key({key: o}) {
          return resolveMetaKeyType(o)
      },
      value({key: o}) {
          return o === "charset" ? "charset" : "content"
      },
      resolveKeyData({key: o}) {
          return resolveMetaKeyValue(o)
      },
      resolveValueData({value: o, key: l}) {
          return o === null ? "_null" : typeof o == "object" ? resolvePackedMetaObjectValue(o, l) : typeof o == "number" ? o.toString() : o
      }
  });
  return [...t, ...a].map(o=>(o.content === "_null" && (o.content = null),
  o))
}
const WhitelistAttributes = {
  htmlAttrs: ["id", "class", "lang", "dir"],
  bodyAttrs: ["id", "class"],
  meta: ["id", "name", "property", "charset", "content"],
  noscript: ["id", "textContent"],
  script: ["id", "type", "textContent"],
  link: ["id", "color", "crossorigin", "fetchpriority", "href", "hreflang", "imagesrcset", "imagesizes", "integrity", "media", "referrerpolicy", "rel", "sizes", "type"]
};
function acceptDataAttrs(e) {
  const t = {};
  return Object.keys(e || {}).filter(r=>r.startsWith("data-")).forEach(r=>{
      t[r] = e[r]
  }
  ),
  t
}
function whitelistSafeInput(e) {
  const t = {};
  return Object.keys(e).forEach(r=>{
      const a = e[r];
      if (a)
          switch (r) {
          case "title":
          case "titleTemplate":
          case "templateParams":
              t[r] = a;
              break;
          case "htmlAttrs":
          case "bodyAttrs":
              t[r] = acceptDataAttrs(a),
              WhitelistAttributes[r].forEach(o=>{
                  a[o] && (t[r][o] = a[o])
              }
              );
              break;
          case "meta":
              Array.isArray(a) && (t[r] = a.map(o=>{
                  const l = acceptDataAttrs(o);
                  return WhitelistAttributes.meta.forEach(f=>{
                      o[f] && (l[f] = o[f])
                  }
                  ),
                  l
              }
              ).filter(o=>Object.keys(o).length > 0));
              break;
          case "link":
              Array.isArray(a) && (t[r] = a.map(o=>{
                  const l = acceptDataAttrs(o);
                  return WhitelistAttributes.link.forEach(f=>{
                      const d = o[f];
                      if (!(f === "rel" && ["stylesheet", "canonical", "modulepreload", "prerender", "preload", "prefetch"].includes(d)))
                          if (f === "href") {
                              if (d.includes("javascript:") || d.includes("data:"))
                                  return;
                              l[f] = d
                          } else
                              d && (l[f] = d)
                  }
                  ),
                  l
              }
              ).filter(o=>Object.keys(o).length > 1 && !!o.rel));
              break;
          case "noscript":
              Array.isArray(a) && (t[r] = a.map(o=>{
                  const l = acceptDataAttrs(o);
                  return WhitelistAttributes.noscript.forEach(f=>{
                      o[f] && (l[f] = o[f])
                  }
                  ),
                  l
              }
              ).filter(o=>Object.keys(o).length > 0));
              break;
          case "script":
              Array.isArray(a) && (t[r] = a.map(o=>{
                  const l = acceptDataAttrs(o);
                  return WhitelistAttributes.script.forEach(f=>{
                      if (o[f])
                          if (f === "textContent")
                              try {
                                  const d = typeof o[f] == "string" ? JSON.parse(o[f]) : o[f];
                                  l[f] = JSON.stringify(d, null, 0)
                              } catch {}
                          else
                              l[f] = o[f]
                  }
                  ),
                  l
              }
              ).filter(o=>Object.keys(o).length > 0));
              break
          }
  }
  ),
  t
}
async function normaliseTag(e, t, r) {
  const a = {
      tag: e,
      props: await normaliseProps(typeof t == "object" && typeof t != "function" && !(t instanceof Promise) ? {
          ...t
      } : {
          [["script", "noscript", "style"].includes(e) ? "innerHTML" : "textContent"]: t
      }, ["templateParams", "titleTemplate"].includes(e))
  };
  return TagConfigKeys.forEach(o=>{
      const l = typeof a.props[o] < "u" ? a.props[o] : r[o];
      typeof l < "u" && ((!["innerHTML", "textContent", "children"].includes(o) || TagsWithInnerContent.includes(a.tag)) && (a[o === "children" ? "innerHTML" : o] = l),
      delete a.props[o])
  }
  ),
  a.props.body && (a.tagPosition = "bodyClose",
  delete a.props.body),
  a.tag === "script" && typeof a.innerHTML == "object" && (a.innerHTML = JSON.stringify(a.innerHTML),
  a.props.type = a.props.type || "application/json"),
  Array.isArray(a.props.content) ? a.props.content.map(o=>({
      ...a,
      props: {
          ...a.props,
          content: o
      }
  })) : a
}
function normaliseStyleClassProps(e, t) {
  const r = e === "class" ? " " : ";";
  return typeof t == "object" && !Array.isArray(t) && (t = Object.entries(t).filter(([,a])=>a).map(([a,o])=>e === "style" ? `${a}:${o}` : a)),
  (Array.isArray(t) ? t.join(r) : t).split(r).filter(a=>a.trim()).filter(Boolean).join(r)
}
async function normaliseProps(e, t) {
  for (const r of Object.keys(e)) {
      if (["class", "style"].includes(r)) {
          e[r] = normaliseStyleClassProps(r, e[r]);
          continue
      }
      if (e[r]instanceof Promise && (e[r] = await e[r]),
      !t && !TagConfigKeys.includes(r)) {
          const a = String(e[r])
            , o = r.startsWith("data-");
          a === "true" || a === "" ? e[r] = o ? "true" : !0 : e[r] || (o && a === "false" ? e[r] = "false" : delete e[r])
      }
  }
  return e
}
const TagEntityBits = 10;
async function normaliseEntryTags(e) {
  const t = [];
  return Object.entries(e.resolvedInput).filter(([r,a])=>typeof a < "u" && ValidHeadTags.includes(r)).forEach(([r,a])=>{
      const o = asArray$1(a);
      t.push(...o.map(l=>normaliseTag(r, l, e)).flat())
  }
  ),
  (await Promise.all(t)).flat().filter(Boolean).map((r,a)=>(r._e = e._i,
  e.mode && (r._m = e.mode),
  r._p = (e._i << TagEntityBits) + a,
  r))
}
const TAG_WEIGHTS = {
  base: -10,
  title: 10
}
, TAG_ALIASES = {
  critical: -80,
  high: -10,
  low: 20
};
function tagWeight(e) {
  let t = 100;
  const r = e.tagPriority;
  return typeof r == "number" ? r : (e.tag === "meta" ? (e.props["http-equiv"] === "content-security-policy" && (t = -30),
  e.props.charset && (t = -20),
  e.props.name === "viewport" && (t = -15)) : e.tag === "link" && e.props.rel === "preconnect" ? t = 20 : e.tag in TAG_WEIGHTS && (t = TAG_WEIGHTS[e.tag]),
  typeof r == "string" && r in TAG_ALIASES ? t + TAG_ALIASES[r] : t)
}
const SortModifiers = [{
  prefix: "before:",
  offset: -1
}, {
  prefix: "after:",
  offset: 1
}]
, NetworkEvents = ["onload", "onerror", "onabort", "onprogress", "onloadstart"]
, sepSub = "%separator";
function processTemplateParams(e, t, r) {
  if (typeof e != "string" || !e.includes("%"))
      return e;
  function a(f) {
      let d;
      return ["s", "pageTitle"].includes(f) ? d = t.pageTitle : f.includes(".") ? d = f.split(".").reduce((g,_)=>g && g[_] || void 0, t) : d = t[f],
      typeof d < "u" ? (d || "").replace(/"/g, '\\"') : !1
  }
  let o = e;
  try {
      o = decodeURI(e)
  } catch {}
  return (o.match(/%(\w+\.+\w+)|%(\w+)/g) || []).sort().reverse().forEach(f=>{
      const d = a(f.slice(1));
      typeof d == "string" && (e = e.replace(new RegExp(`\\${f}(\\W|$)`,"g"), (g,_)=>`${d}${_}`).trim())
  }
  ),
  e.includes(sepSub) && (e.endsWith(sepSub) && (e = e.slice(0, -sepSub.length).trim()),
  e.startsWith(sepSub) && (e = e.slice(sepSub.length).trim()),
  e = e.replace(new RegExp(`\\${sepSub}\\s*\\${sepSub}`,"g"), sepSub),
  e = processTemplateParams(e, {
      separator: r
  }, r)),
  e
}
async function renderDOMHead(e, t={}) {
  var v;
  const r = t.document || e.resolvedOptions.document;
  if (!r || !e.dirty)
      return;
  const a = {
      shouldRender: !0,
      tags: []
  };
  if (await e.hooks.callHook("dom:beforeRender", a),
  !a.shouldRender)
      return;
  const o = (await e.resolveTags()).map(S=>({
      tag: S,
      id: HasElementTags.includes(S.tag) ? hashTag(S) : S.tag,
      shouldRender: !0
  }));
  let l = e._dom;
  if (!l) {
      l = {
          elMap: {
              htmlAttrs: r.documentElement,
              bodyAttrs: r.body
          }
      };
      for (const S of ["body", "head"]) {
          const b = (v = r[S]) == null ? void 0 : v.children
            , P = [];
          for (const x of [...b].filter(E=>HasElementTags.includes(E.tagName.toLowerCase()))) {
              const E = {
                  tag: x.tagName.toLowerCase(),
                  props: await normaliseProps(x.getAttributeNames().reduce((A,T)=>({
                      ...A,
                      [T]: x.getAttribute(T)
                  }), {})),
                  innerHTML: x.innerHTML
              };
              let I = 1
                , C = tagDedupeKey(E);
              for (; C && P.find(A=>A._d === C); )
                  C = `${C}:${I++}`;
              E._d = C || void 0,
              P.push(E),
              l.elMap[x.getAttribute("data-hid") || hashTag(E)] = x
          }
      }
  }
  l.pendingSideEffects = {
      ...l.sideEffects || {}
  },
  l.sideEffects = {};
  function f(S, b, P) {
      const x = `${S}:${b}`;
      l.sideEffects[x] = P,
      delete l.pendingSideEffects[x]
  }
  function d({id: S, $el: b, tag: P}) {
      const x = P.tag.endsWith("Attrs");
      l.elMap[S] = b,
      x || (["textContent", "innerHTML"].forEach(E=>{
          P[E] && P[E] !== b[E] && (b[E] = P[E])
      }
      ),
      f(S, "el", ()=>{
          var E;
          (E = l.elMap[S]) == null || E.remove(),
          delete l.elMap[S]
      }
      ));
      for (const [E,I] of Object.entries(P._eventHandlers || {}))
          b.getAttribute(`data-${E}`) !== "" && ((P.tag === "bodyAttrs" ? r.defaultView : b).addEventListener(E.replace("on", ""), I.bind(b)),
          b.setAttribute(`data-${E}`, ""));
      Object.entries(P.props).forEach(([E,I])=>{
          const C = `attr:${E}`;
          if (E === "class")
              for (const A of (I || "").split(" ").filter(Boolean))
                  x && f(S, `${C}:${A}`, ()=>b.classList.remove(A)),
                  !b.classList.contains(A) && b.classList.add(A);
          else if (E === "style")
              for (const A of (I || "").split(";").filter(Boolean)) {
                  const [T,...w] = A.split(":").map(M=>M.trim());
                  f(S, `${C}:${A}:${T}`, ()=>{
                      b.style.removeProperty(T)
                  }
                  ),
                  b.style.setProperty(T, w.join(":"))
              }
          else
              b.getAttribute(E) !== I && b.setAttribute(E, I === !0 ? "" : String(I)),
              x && f(S, C, ()=>b.removeAttribute(E))
      }
      )
  }
  const g = []
    , _ = {
      bodyClose: void 0,
      bodyOpen: void 0,
      head: void 0
  };
  for (const S of o) {
      const {tag: b, shouldRender: P, id: x} = S;
      if (P) {
          if (b.tag === "title") {
              r.title = b.textContent;
              continue
          }
          S.$el = S.$el || l.elMap[x],
          S.$el ? d(S) : HasElementTags.includes(b.tag) && g.push(S)
      }
  }
  for (const S of g) {
      const b = S.tag.tagPosition || "head";
      S.$el = r.createElement(S.tag.tag),
      d(S),
      _[b] = _[b] || r.createDocumentFragment(),
      _[b].appendChild(S.$el)
  }
  for (const S of o)
      await e.hooks.callHook("dom:renderTag", S, r, f);
  _.head && r.head.appendChild(_.head),
  _.bodyOpen && r.body.insertBefore(_.bodyOpen, r.body.firstChild),
  _.bodyClose && r.body.appendChild(_.bodyClose),
  Object.values(l.pendingSideEffects).forEach(S=>S()),
  e._dom = l,
  e.dirty = !1,
  await e.hooks.callHook("dom:rendered", {
      renders: o
  })
}
async function debouncedRenderDOMHead(e, t={}) {
  const r = t.delayFn || (a=>setTimeout(a, 10));
  return e._domUpdatePromise = e._domUpdatePromise || new Promise(a=>r(async()=>{
      await renderDOMHead(e, t),
      delete e._domUpdatePromise,
      a()
  }
  ))
}
function DomPlugin(e) {
  return t=>{
      var a, o;
      const r = ((o = (a = t.resolvedOptions.document) == null ? void 0 : a.head.querySelector('script[id="unhead:payload"]')) == null ? void 0 : o.innerHTML) || !1;
      return r && t.push(JSON.parse(r)),
      {
          mode: "client",
          hooks: {
              "entries:updated": function(l) {
                  debouncedRenderDOMHead(l, e)
              }
          }
      }
  }
}
const UsesMergeStrategy = ["templateParams", "htmlAttrs", "bodyAttrs"]
, DedupePlugin = {
  hooks: {
      "tag:normalise": function({tag: e}) {
          ["hid", "vmid", "key"].forEach(a=>{
              e.props[a] && (e.key = e.props[a],
              delete e.props[a])
          }
          );
          const r = tagDedupeKey(e) || (e.key ? `${e.tag}:${e.key}` : !1);
          r && (e._d = r)
      },
      "tags:resolve": function(e) {
          const t = {};
          e.tags.forEach(a=>{
              const o = (a.key ? `${a.tag}:${a.key}` : a._d) || a._p
                , l = t[o];
              if (l) {
                  let d = a == null ? void 0 : a.tagDuplicateStrategy;
                  if (!d && UsesMergeStrategy.includes(a.tag) && (d = "merge"),
                  d === "merge") {
                      const g = l.props;
                      ["class", "style"].forEach(_=>{
                          g[_] && (a.props[_] ? (_ === "style" && !g[_].endsWith(";") && (g[_] += ";"),
                          a.props[_] = `${g[_]} ${a.props[_]}`) : a.props[_] = g[_])
                      }
                      ),
                      t[o].props = {
                          ...g,
                          ...a.props
                      };
                      return
                  } else if (a._e === l._e) {
                      l._duped = l._duped || [],
                      a._d = `${l._d}:${l._duped.length + 1}`,
                      l._duped.push(a);
                      return
                  } else if (tagWeight(a) > tagWeight(l))
                      return
              }
              const f = Object.keys(a.props).length + (a.innerHTML ? 1 : 0) + (a.textContent ? 1 : 0);
              if (HasElementTags.includes(a.tag) && f === 0) {
                  delete t[o];
                  return
              }
              t[o] = a
          }
          );
          const r = [];
          Object.values(t).forEach(a=>{
              const o = a._duped;
              delete a._duped,
              r.push(a),
              o && r.push(...o)
          }
          ),
          e.tags = r,
          e.tags = e.tags.filter(a=>!(a.tag === "meta" && (a.props.name || a.props.property) && !a.props.content))
      }
  }
}
, PayloadPlugin = {
  mode: "server",
  hooks: {
      "tags:resolve": function(e) {
          const t = {};
          e.tags.filter(r=>["titleTemplate", "templateParams", "title"].includes(r.tag) && r._m === "server").forEach(r=>{
              t[r.tag] = r.tag.startsWith("title") ? r.textContent : r.props
          }
          ),
          Object.keys(t).length && e.tags.push({
              tag: "script",
              innerHTML: JSON.stringify(t),
              props: {
                  id: "unhead:payload",
                  type: "application/json"
              }
          })
      }
  }
}
, ValidEventTags = ["script", "link", "bodyAttrs"]
, EventHandlersPlugin = e=>({
  hooks: {
      "tags:resolve": function(t) {
          for (const r of t.tags.filter(a=>ValidEventTags.includes(a.tag)))
              Object.entries(r.props).forEach(([a,o])=>{
                  a.startsWith("on") && typeof o == "function" && (e.ssr && NetworkEvents.includes(a) ? r.props[a] = `this.dataset.${a}fired = true` : delete r.props[a],
                  r._eventHandlers = r._eventHandlers || {},
                  r._eventHandlers[a] = o)
              }
              ),
              e.ssr && r._eventHandlers && (r.props.src || r.props.href) && (r.key = r.key || hashCode(r.props.src || r.props.href))
      },
      "dom:renderTag": function({$el: t, tag: r}) {
          var a, o;
          for (const l of Object.keys((t == null ? void 0 : t.dataset) || {}).filter(f=>NetworkEvents.some(d=>`${d}fired` === f))) {
              const f = l.replace("fired", "");
              (o = (a = r._eventHandlers) == null ? void 0 : a[f]) == null || o.call(t, new Event(f.replace("on", "")))
          }
      }
  }
})
, DupeableTags = ["link", "style", "script", "noscript"]
, HashKeyedPlugin = {
  hooks: {
      "tag:normalise": ({tag: e})=>{
          e.key && DupeableTags.includes(e.tag) && (e.props["data-hid"] = e._h = hashCode(e.key))
      }
  }
}
, SortPlugin = {
  hooks: {
      "tags:resolve": e=>{
          const t = r=>{
              var a;
              return (a = e.tags.find(o=>o._d === r)) == null ? void 0 : a._p
          }
          ;
          for (const {prefix: r, offset: a} of SortModifiers)
              for (const o of e.tags.filter(l=>typeof l.tagPriority == "string" && l.tagPriority.startsWith(r))) {
                  const l = t(o.tagPriority.replace(r, ""));
                  typeof l < "u" && (o._p = l + a)
              }
          e.tags.sort((r,a)=>r._p - a._p).sort((r,a)=>tagWeight(r) - tagWeight(a))
      }
  }
}
, SupportedAttrs = {
  meta: "content",
  link: "href",
  htmlAttrs: "lang"
}
, TemplateParamsPlugin = e=>({
  hooks: {
      "tags:resolve": t=>{
          var d;
          const {tags: r} = t
            , a = (d = r.find(g=>g.tag === "title")) == null ? void 0 : d.textContent
            , o = r.findIndex(g=>g.tag === "templateParams")
            , l = o !== -1 ? r[o].props : {}
            , f = l.separator || "|";
          delete l.separator,
          l.pageTitle = processTemplateParams(l.pageTitle || a || "", l, f);
          for (const g of r.filter(_=>_.processTemplateParams !== !1)) {
              const _ = SupportedAttrs[g.tag];
              _ && typeof g.props[_] == "string" ? g.props[_] = processTemplateParams(g.props[_], l, f) : (g.processTemplateParams === !0 || ["titleTemplate", "title"].includes(g.tag)) && ["innerHTML", "textContent"].forEach(v=>{
                  typeof g[v] == "string" && (g[v] = processTemplateParams(g[v], l, f))
              }
              )
          }
          e._templateParams = l,
          e._separator = f,
          t.tags = r.filter(g=>g.tag !== "templateParams")
      }
  }
})
, TitleTemplatePlugin = {
  hooks: {
      "tags:resolve": e=>{
          const {tags: t} = e;
          let r = t.findIndex(o=>o.tag === "titleTemplate");
          const a = t.findIndex(o=>o.tag === "title");
          if (a !== -1 && r !== -1) {
              const o = resolveTitleTemplate(t[r].textContent, t[a].textContent);
              o !== null ? t[a].textContent = o || t[a].textContent : delete t[a]
          } else if (r !== -1) {
              const o = resolveTitleTemplate(t[r].textContent);
              o !== null && (t[r].textContent = o,
              t[r].tag = "title",
              r = -1)
          }
          r !== -1 && delete t[r],
          e.tags = t.filter(Boolean)
      }
  }
}
, XSSPlugin = {
  hooks: {
      "tags:afterResolve": function(e) {
          for (const t of e.tags)
              typeof t.innerHTML == "string" && (t.innerHTML && ["application/ld+json", "application/json"].includes(t.props.type) ? t.innerHTML = t.innerHTML.replace(/</g, "\\u003C") : t.innerHTML = t.innerHTML.replace(new RegExp(`</${t.tag}`,"g"), `<\\/${t.tag}`))
      }
  }
};
let activeHead;
function createHead$1(e={}) {
  const t = createHeadCore(e);
  return t.use(DomPlugin()),
  activeHead = t
}
function filterMode(e, t) {
  return !e || e === "server" && t || e === "client" && !t
}
function createHeadCore(e={}) {
  const t = createHooks();
  t.addHooks(e.hooks || {}),
  e.document = e.document || (IsBrowser ? document : void 0);
  const r = !e.document
    , a = ()=>{
      d.dirty = !0,
      t.callHook("entries:updated", d)
  }
  ;
  let o = 0
    , l = [];
  const f = []
    , d = {
      plugins: f,
      dirty: !1,
      resolvedOptions: e,
      hooks: t,
      headEntries() {
          return l
      },
      use(g) {
          const _ = typeof g == "function" ? g(d) : g;
          (!_.key || !f.some(v=>v.key === _.key)) && (f.push(_),
          filterMode(_.mode, r) && t.addHooks(_.hooks || {}))
      },
      push(g, _) {
          _ == null || delete _.head;
          const v = {
              _i: o++,
              input: g,
              ..._
          };
          return filterMode(v.mode, r) && (l.push(v),
          a()),
          {
              dispose() {
                  l = l.filter(S=>S._i !== v._i),
                  t.callHook("entries:updated", d),
                  a()
              },
              patch(S) {
                  l = l.map(b=>(b._i === v._i && (b.input = v.input = S),
                  b)),
                  a()
              }
          }
      },
      async resolveTags() {
          const g = {
              tags: [],
              entries: [...l]
          };
          await t.callHook("entries:resolve", g);
          for (const _ of g.entries) {
              const v = _.resolvedInput || _.input;
              if (_.resolvedInput = await (_.transform ? _.transform(v) : v),
              _.resolvedInput)
                  for (const S of await normaliseEntryTags(_)) {
                      const b = {
                          tag: S,
                          entry: _,
                          resolvedOptions: d.resolvedOptions
                      };
                      await t.callHook("tag:normalise", b),
                      g.tags.push(b.tag)
                  }
          }
          return await t.callHook("tags:beforeResolve", g),
          await t.callHook("tags:resolve", g),
          await t.callHook("tags:afterResolve", g),
          g.tags
      },
      ssr: r
  };
  return [DedupePlugin, PayloadPlugin, EventHandlersPlugin, HashKeyedPlugin, SortPlugin, TemplateParamsPlugin, TitleTemplatePlugin, XSSPlugin, ...(e == null ? void 0 : e.plugins) || []].forEach(g=>d.use(g)),
  d.hooks.callHook("init", d),
  d
}
function getActiveHead() {
  return activeHead
}
const Vue3 = version.startsWith("3");
function resolveUnref(e) {
  return typeof e == "function" ? e() : unref(e)
}
function resolveUnrefHeadInput(e, t="") {
  if (e instanceof Promise)
      return e;
  const r = resolveUnref(e);
  return !e || !r ? r : Array.isArray(r) ? r.map(a=>resolveUnrefHeadInput(a, t)) : typeof r == "object" ? Object.fromEntries(Object.entries(r).map(([a,o])=>a === "titleTemplate" || a.startsWith("on") ? [a, unref(o)] : [a, resolveUnrefHeadInput(o, a)])) : r
}
const VueReactivityPlugin = {
  hooks: {
      "entries:resolve": function(e) {
          for (const t of e.entries)
              t.resolvedInput = resolveUnrefHeadInput(t.input)
      }
  }
}
, headSymbol = "usehead";
function vueInstall(e) {
  return {
      install(r) {
          Vue3 && (r.config.globalProperties.$unhead = e,
          r.config.globalProperties.$head = e,
          r.provide(headSymbol, e))
      }
  }.install
}
function createHead(e={}) {
  e.domDelayFn = e.domDelayFn || (r=>nextTick(()=>setTimeout(()=>r(), 0)));
  const t = createHead$1(e);
  return t.use(VueReactivityPlugin),
  t.install = vueInstall(t),
  t
}
const _global = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}
, globalKey = "__unhead_injection_handler__";
function setHeadInjectionHandler(e) {
  _global[globalKey] = e
}
function injectHead() {
  if (globalKey in _global)
      return _global[globalKey]();
  const e = inject(headSymbol);
  return e || getActiveHead()
}
function useHead(e, t={}) {
  const r = t.head || injectHead();
  if (r)
      return r.ssr ? r.push(e, t) : clientUseHead(r, e, t)
}
function clientUseHead(e, t, r={}) {
  const a = ref(!1)
    , o = ref({});
  watchEffect(()=>{
      o.value = a.value ? {} : resolveUnrefHeadInput(t)
  }
  );
  const l = e.push(o.value, r);
  return watch(o, d=>{
      l.patch(d)
  }
  ),
  getCurrentInstance() && (onBeforeUnmount(()=>{
      l.dispose()
  }
  ),
  onDeactivated(()=>{
      a.value = !0
  }
  ),
  onActivated(()=>{
      a.value = !1
  }
  )),
  l
}
function useHeadSafe(e, t={}) {
  return useHead(e, {
      ...t,
      transform: whitelistSafeInput
  })
}
function useSeoMeta(e, t) {
  const {title: r, titleTemplate: a, ...o} = e;
  return useHead({
      title: r,
      titleTemplate: a,
      _flatMeta: o
  }, {
      ...t,
      transform(l) {
          const f = unpackMeta({
              ...l._flatMeta
          });
          return delete l._flatMeta,
          {
              ...l,
              meta: f
          }
      }
  })
}
const inlineConfig = {
  nuxt: {
      buildId: "99127027-146c-4304-a3f1-bd01d7006f87"
  }
}
, __appConfig = defuFn(inlineConfig);
function useAppConfig() {
  const e = useNuxtApp();
  return e._appConfig || (e._appConfig = reactive(__appConfig)),
  e._appConfig
}
const appLayoutTransition = !1
, appPageTransition = !1
, appKeepalive = !1
, nuxtLinkDefaults = {
  componentName: "NuxtLink"
}
, asyncDataDefaults = {
  deep: !0
}
, fetchDefaults = {}
, vueAppRootContainer = "#__nuxt";
let manifest, matcher;
function fetchManifest() {
  var t;
  const e = (t = useAppConfig().nuxt) == null ? void 0 : t.buildId;
  return manifest = $fetch(buildAssetsURL(`builds/meta/${e}.json`)),
  manifest.then(r=>{
      matcher = createMatcherFromExport(r.matcher)
  }
  ),
  manifest
}
function getAppManifest() {
  return manifest || fetchManifest()
}
async function getRouteRules(e) {
  return await getAppManifest(),
  defu({}, ...matcher.matchAll(e).reverse())
}
function loadPayload(e, t={}) {
  const r = _getPayloadURL(e, t)
    , a = useNuxtApp()
    , o = a._payloadCache = a._payloadCache || {};
  return r in o || (o[r] = isPrerendered(e).then(l=>l ? _importPayload(r).then(f=>f || (delete o[r],
  null)) : (o[r] = null,
  null))),
  o[r]
}
const filename = "_payload.json";
function _getPayloadURL(e, t={}) {
  var o;
  const r = new URL(e,"http://localhost");
  if (r.host !== "localhost" || hasProtocol(r.pathname, {
      acceptRelative: !0
  }))
      throw new Error("Payload URL must not include hostname: " + e);
  const a = t.hash || (t.fresh ? Date.now() : (o = useAppConfig().nuxt) == null ? void 0 : o.buildId);
  return joinURL(useRuntimeConfig().app.baseURL, r.pathname, filename + (a ? `?${a}` : ""))
}
async function _importPayload(e) {
  const t = fetch(e).then(r=>r.text().then(parsePayload));
  try {
      return await t
  } catch (r) {
      console.warn("[nuxt] Cannot load payload ", e, r)
  }
  return null
}
async function isPrerendered(e=useRoute$1().path) {
  if (e = withoutTrailingSlash(e),
  (await getAppManifest()).prerendered.includes(e))
      return !0;
  const r = await getRouteRules(e);
  return !!r.prerender && !r.redirect
}
let payloadCache = null;
async function getNuxtClientPayload() {
  if (payloadCache)
      return payloadCache;
  const e = document.getElementById("__NUXT_DATA__");
  if (!e)
      return {};
  const t = await parsePayload(e.textContent || "")
    , r = e.dataset.src ? await _importPayload(e.dataset.src) : void 0;
  return payloadCache = {
      ...t,
      ...r,
      ...window.__NUXT__
  },
  payloadCache
}
async function parsePayload(e) {
  return await parse(e, useNuxtApp()._payloadRevivers)
}
function definePayloadReviver(e, t) {
  useNuxtApp()._payloadRevivers[e] = t
}
const revivers = {
  NuxtError: e=>createError(e),
  EmptyShallowRef: e=>shallowRef(e === "_" ? void 0 : e === "0n" ? BigInt(0) : destr(e)),
  EmptyRef: e=>ref(e === "_" ? void 0 : e === "0n" ? BigInt(0) : destr(e)),
  ShallowRef: e=>shallowRef(e),
  ShallowReactive: e=>shallowReactive(e),
  Ref: e=>ref(e),
  Reactive: e=>reactive(e)
}
, revive_payload_client_UiS3SX29k8 = defineNuxtPlugin({
  name: "nuxt:revive-payload:client",
  order: -30,
  async setup(e) {
      let t, r;
      for (const a in revivers)
          definePayloadReviver(a, revivers[a]);
      Object.assign(e.payload, ([t,r] = executeAsync(()=>e.runWithContext(getNuxtClientPayload)),
      t = await t,
      r(),
      t)),
      window.__NUXT__ = e.payload
  }
})
, unheadPlugins = []
, unhead_ql6q2sxwsI = defineNuxtPlugin({
  name: "nuxt:head",
  enforce: "pre",
  setup(e) {
      const t = createHead({
          plugins: unheadPlugins
      });
      setHeadInjectionHandler(()=>useNuxtApp().vueApp._context.provides.usehead),
      e.vueApp.use(t);
      {
          let r = !0;
          const a = async()=>{
              r = !1,
              await renderDOMHead(t)
          }
          ;
          t.hooks.hook("dom:beforeRender", o=>{
              o.shouldRender = !r
          }
          ),
          e.hooks.hook("page:start", ()=>{
              r = !0
          }
          ),
          e.hooks.hook("page:finish", ()=>{
              e.isHydrating || a()
          }
          ),
          e.hooks.hook("app:error", a),
          e.hooks.hook("app:suspense:resolve", a)
      }
  }
});
/*!
* vue-router v4.3.0
* (c) 2024 Eduardo San Martin Morote
* @license MIT
*/
const isBrowser = typeof document < "u";
function isESModule(e) {
  return e.__esModule || e[Symbol.toStringTag] === "Module"
}
const assign = Object.assign;
function applyToParams(e, t) {
  const r = {};
  for (const a in t) {
      const o = t[a];
      r[a] = isArray(o) ? o.map(e) : e(o)
  }
  return r
}
const noop = ()=>{}
, isArray = Array.isArray
, HASH_RE = /#/g
, AMPERSAND_RE = /&/g
, SLASH_RE = /\//g
, EQUAL_RE = /=/g
, IM_RE = /\?/g
, PLUS_RE = /\+/g
, ENC_BRACKET_OPEN_RE = /%5B/g
, ENC_BRACKET_CLOSE_RE = /%5D/g
, ENC_CARET_RE = /%5E/g
, ENC_BACKTICK_RE = /%60/g
, ENC_CURLY_OPEN_RE = /%7B/g
, ENC_PIPE_RE = /%7C/g
, ENC_CURLY_CLOSE_RE = /%7D/g
, ENC_SPACE_RE = /%20/g;
function commonEncode(e) {
  return encodeURI("" + e).replace(ENC_PIPE_RE, "|").replace(ENC_BRACKET_OPEN_RE, "[").replace(ENC_BRACKET_CLOSE_RE, "]")
}
function encodeHash(e) {
  return commonEncode(e).replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^")
}
function encodeQueryValue(e) {
  return commonEncode(e).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^")
}
function encodeQueryKey(e) {
  return encodeQueryValue(e).replace(EQUAL_RE, "%3D")
}
function encodePath(e) {
  return commonEncode(e).replace(HASH_RE, "%23").replace(IM_RE, "%3F")
}
function encodeParam(e) {
  return e == null ? "" : encodePath(e).replace(SLASH_RE, "%2F")
}
function decode(e) {
  try {
      return decodeURIComponent("" + e)
  } catch {}
  return "" + e
}
const TRAILING_SLASH_RE = /\/$/
, removeTrailingSlash = e=>e.replace(TRAILING_SLASH_RE, "");
function parseURL(e, t, r="/") {
  let a, o = {}, l = "", f = "";
  const d = t.indexOf("#");
  let g = t.indexOf("?");
  return d < g && d >= 0 && (g = -1),
  g > -1 && (a = t.slice(0, g),
  l = t.slice(g + 1, d > -1 ? d : t.length),
  o = e(l)),
  d > -1 && (a = a || t.slice(0, d),
  f = t.slice(d, t.length)),
  a = resolveRelativePath(a ?? t, r),
  {
      fullPath: a + (l && "?") + l + f,
      path: a,
      query: o,
      hash: decode(f)
  }
}
function stringifyURL(e, t) {
  const r = t.query ? e(t.query) : "";
  return t.path + (r && "?") + r + (t.hash || "")
}
function stripBase(e, t) {
  return !t || !e.toLowerCase().startsWith(t.toLowerCase()) ? e : e.slice(t.length) || "/"
}
function isSameRouteLocation(e, t, r) {
  const a = t.matched.length - 1
    , o = r.matched.length - 1;
  return a > -1 && a === o && isSameRouteRecord(t.matched[a], r.matched[o]) && isSameRouteLocationParams(t.params, r.params) && e(t.query) === e(r.query) && t.hash === r.hash
}
function isSameRouteRecord(e, t) {
  return (e.aliasOf || e) === (t.aliasOf || t)
}
function isSameRouteLocationParams(e, t) {
  if (Object.keys(e).length !== Object.keys(t).length)
      return !1;
  for (const r in e)
      if (!isSameRouteLocationParamsValue(e[r], t[r]))
          return !1;
  return !0
}
function isSameRouteLocationParamsValue(e, t) {
  return isArray(e) ? isEquivalentArray(e, t) : isArray(t) ? isEquivalentArray(t, e) : e === t
}
function isEquivalentArray(e, t) {
  return isArray(t) ? e.length === t.length && e.every((r,a)=>r === t[a]) : e.length === 1 && e[0] === t
}
function resolveRelativePath(e, t) {
  if (e.startsWith("/"))
      return e;
  if (!e)
      return t;
  const r = t.split("/")
    , a = e.split("/")
    , o = a[a.length - 1];
  (o === ".." || o === ".") && a.push("");
  let l = r.length - 1, f, d;
  for (f = 0; f < a.length; f++)
      if (d = a[f],
      d !== ".")
          if (d === "..")
              l > 1 && l--;
          else
              break;
  return r.slice(0, l).join("/") + "/" + a.slice(f).join("/")
}
var NavigationType;
(function(e) {
  e.pop = "pop",
  e.push = "push"
}
)(NavigationType || (NavigationType = {}));
var NavigationDirection;
(function(e) {
  e.back = "back",
  e.forward = "forward",
  e.unknown = ""
}
)(NavigationDirection || (NavigationDirection = {}));
function normalizeBase(e) {
  if (!e)
      if (isBrowser) {
          const t = document.querySelector("base");
          e = t && t.getAttribute("href") || "/",
          e = e.replace(/^\w+:\/\/[^\/]+/, "")
      } else
          e = "/";
  return e[0] !== "/" && e[0] !== "#" && (e = "/" + e),
  removeTrailingSlash(e)
}
const BEFORE_HASH_RE = /^[^#]+#/;
function createHref(e, t) {
  return e.replace(BEFORE_HASH_RE, "#") + t
}
function getElementPosition(e, t) {
  const r = document.documentElement.getBoundingClientRect()
    , a = e.getBoundingClientRect();
  return {
      behavior: t.behavior,
      left: a.left - r.left - (t.left || 0),
      top: a.top - r.top - (t.top || 0)
  }
}
const computeScrollPosition = ()=>({
  left: window.scrollX,
  top: window.scrollY
});
function scrollToPosition(e) {
  let t;
  if ("el"in e) {
      const r = e.el
        , a = typeof r == "string" && r.startsWith("#")
        , o = typeof r == "string" ? a ? document.getElementById(r.slice(1)) : document.querySelector(r) : r;
      if (!o)
          return;
      t = getElementPosition(o, e)
  } else
      t = e;
  "scrollBehavior"in document.documentElement.style ? window.scrollTo(t) : window.scrollTo(t.left != null ? t.left : window.scrollX, t.top != null ? t.top : window.scrollY)
}
function getScrollKey(e, t) {
  return (history.state ? history.state.position - t : -1) + e
}
const scrollPositions = new Map;
function saveScrollPosition(e, t) {
  scrollPositions.set(e, t)
}
function getSavedScrollPosition(e) {
  const t = scrollPositions.get(e);
  return scrollPositions.delete(e),
  t
}
let createBaseLocation = ()=>location.protocol + "//" + location.host;
function createCurrentLocation$1(e, t) {
  const {pathname: r, search: a, hash: o} = t
    , l = e.indexOf("#");
  if (l > -1) {
      let d = o.includes(e.slice(l)) ? e.slice(l).length : 1
        , g = o.slice(d);
      return g[0] !== "/" && (g = "/" + g),
      stripBase(g, "")
  }
  return stripBase(r, e) + a + o
}
function useHistoryListeners(e, t, r, a) {
  let o = []
    , l = []
    , f = null;
  const d = ({state: b})=>{
      const P = createCurrentLocation$1(e, location)
        , x = r.value
        , E = t.value;
      let I = 0;
      if (b) {
          if (r.value = P,
          t.value = b,
          f && f === x) {
              f = null;
              return
          }
          I = E ? b.position - E.position : 0
      } else
          a(P);
      o.forEach(C=>{
          C(r.value, x, {
              delta: I,
              type: NavigationType.pop,
              direction: I ? I > 0 ? NavigationDirection.forward : NavigationDirection.back : NavigationDirection.unknown
          })
      }
      )
  }
  ;
  function g() {
      f = r.value
  }
  function _(b) {
      o.push(b);
      const P = ()=>{
          const x = o.indexOf(b);
          x > -1 && o.splice(x, 1)
      }
      ;
      return l.push(P),
      P
  }
  function v() {
      const {history: b} = window;
      b.state && b.replaceState(assign({}, b.state, {
          scroll: computeScrollPosition()
      }), "")
  }
  function S() {
      for (const b of l)
          b();
      l = [],
      window.removeEventListener("popstate", d),
      window.removeEventListener("beforeunload", v)
  }
  return window.addEventListener("popstate", d),
  window.addEventListener("beforeunload", v, {
      passive: !0
  }),
  {
      pauseListeners: g,
      listen: _,
      destroy: S
  }
}
function buildState(e, t, r, a=!1, o=!1) {
  return {
      back: e,
      current: t,
      forward: r,
      replaced: a,
      position: window.history.length,
      scroll: o ? computeScrollPosition() : null
  }
}
function useHistoryStateNavigation(e) {
  const {history: t, location: r} = window
    , a = {
      value: createCurrentLocation$1(e, r)
  }
    , o = {
      value: t.state
  };
  o.value || l(a.value, {
      back: null,
      current: a.value,
      forward: null,
      position: t.length - 1,
      replaced: !0,
      scroll: null
  }, !0);
  function l(g, _, v) {
      const S = e.indexOf("#")
        , b = S > -1 ? (r.host && document.querySelector("base") ? e : e.slice(S)) + g : createBaseLocation() + e + g;
      try {
          t[v ? "replaceState" : "pushState"](_, "", b),
          o.value = _
      } catch (P) {
          console.error(P),
          r[v ? "replace" : "assign"](b)
      }
  }
  function f(g, _) {
      const v = assign({}, t.state, buildState(o.value.back, g, o.value.forward, !0), _, {
          position: o.value.position
      });
      l(g, v, !0),
      a.value = g
  }
  function d(g, _) {
      const v = assign({}, o.value, t.state, {
          forward: g,
          scroll: computeScrollPosition()
      });
      l(v.current, v, !0);
      const S = assign({}, buildState(a.value, g, null), {
          position: v.position + 1
      }, _);
      l(g, S, !1),
      a.value = g
  }
  return {
      location: a,
      state: o,
      push: d,
      replace: f
  }
}
function createWebHistory(e) {
  e = normalizeBase(e);
  const t = useHistoryStateNavigation(e)
    , r = useHistoryListeners(e, t.state, t.location, t.replace);
  function a(l, f=!0) {
      f || r.pauseListeners(),
      history.go(l)
  }
  const o = assign({
      location: "",
      base: e,
      go: a,
      createHref: createHref.bind(null, e)
  }, t, r);
  return Object.defineProperty(o, "location", {
      enumerable: !0,
      get: ()=>t.location.value
  }),
  Object.defineProperty(o, "state", {
      enumerable: !0,
      get: ()=>t.state.value
  }),
  o
}
function createWebHashHistory(e) {
  return e = location.host ? e || location.pathname + location.search : "",
  e.includes("#") || (e += "#"),
  createWebHistory(e)
}
function isRouteLocation(e) {
  return typeof e == "string" || e && typeof e == "object"
}
function isRouteName(e) {
  return typeof e == "string" || typeof e == "symbol"
}
const START_LOCATION_NORMALIZED = {
  path: "/",
  name: void 0,
  params: {},
  query: {},
  hash: "",
  fullPath: "/",
  matched: [],
  meta: {},
  redirectedFrom: void 0
}
, NavigationFailureSymbol = Symbol("");
var NavigationFailureType;
(function(e) {
  e[e.aborted = 4] = "aborted",
  e[e.cancelled = 8] = "cancelled",
  e[e.duplicated = 16] = "duplicated"
}
)(NavigationFailureType || (NavigationFailureType = {}));
function createRouterError(e, t) {
  return assign(new Error, {
      type: e,
      [NavigationFailureSymbol]: !0
  }, t)
}
function isNavigationFailure(e, t) {
  return e instanceof Error && NavigationFailureSymbol in e && (t == null || !!(e.type & t))
}
const BASE_PARAM_PATTERN = "[^/]+?"
, BASE_PATH_PARSER_OPTIONS = {
  sensitive: !1,
  strict: !1,
  start: !0,
  end: !0
}
, REGEX_CHARS_RE = /[.+*?^${}()[\]/\\]/g;
function tokensToParser(e, t) {
  const r = assign({}, BASE_PATH_PARSER_OPTIONS, t)
    , a = [];
  let o = r.start ? "^" : "";
  const l = [];
  for (const _ of e) {
      const v = _.length ? [] : [90];
      r.strict && !_.length && (o += "/");
      for (let S = 0; S < _.length; S++) {
          const b = _[S];
          let P = 40 + (r.sensitive ? .25 : 0);
          if (b.type === 0)
              S || (o += "/"),
              o += b.value.replace(REGEX_CHARS_RE, "\\$&"),
              P += 40;
          else if (b.type === 1) {
              const {value: x, repeatable: E, optional: I, regexp: C} = b;
              l.push({
                  name: x,
                  repeatable: E,
                  optional: I
              });
              const A = C || BASE_PARAM_PATTERN;
              if (A !== BASE_PARAM_PATTERN) {
                  P += 10;
                  try {
                      new RegExp(`(${A})`)
                  } catch (w) {
                      throw new Error(`Invalid custom RegExp for param "${x}" (${A}): ` + w.message)
                  }
              }
              let T = E ? `((?:${A})(?:/(?:${A}))*)` : `(${A})`;
              S || (T = I && _.length < 2 ? `(?:/${T})` : "/" + T),
              I && (T += "?"),
              o += T,
              P += 20,
              I && (P += -8),
              E && (P += -20),
              A === ".*" && (P += -50)
          }
          v.push(P)
      }
      a.push(v)
  }
  if (r.strict && r.end) {
      const _ = a.length - 1;
      a[_][a[_].length - 1] += .7000000000000001
  }
  r.strict || (o += "/?"),
  r.end ? o += "$" : r.strict && (o += "(?:/|$)");
  const f = new RegExp(o,r.sensitive ? "" : "i");
  function d(_) {
      const v = _.match(f)
        , S = {};
      if (!v)
          return null;
      for (let b = 1; b < v.length; b++) {
          const P = v[b] || ""
            , x = l[b - 1];
          S[x.name] = P && x.repeatable ? P.split("/") : P
      }
      return S
  }
  function g(_) {
      let v = ""
        , S = !1;
      for (const b of e) {
          (!S || !v.endsWith("/")) && (v += "/"),
          S = !1;
          for (const P of b)
              if (P.type === 0)
                  v += P.value;
              else if (P.type === 1) {
                  const {value: x, repeatable: E, optional: I} = P
                    , C = x in _ ? _[x] : "";
                  if (isArray(C) && !E)
                      throw new Error(`Provided param "${x}" is an array but it is not repeatable (* or + modifiers)`);
                  const A = isArray(C) ? C.join("/") : C;
                  if (!A)
                      if (I)
                          b.length < 2 && (v.endsWith("/") ? v = v.slice(0, -1) : S = !0);
                      else
                          throw new Error(`Missing required param "${x}"`);
                  v += A
              }
      }
      return v || "/"
  }
  return {
      re: f,
      score: a,
      keys: l,
      parse: d,
      stringify: g
  }
}
function compareScoreArray(e, t) {
  let r = 0;
  for (; r < e.length && r < t.length; ) {
      const a = t[r] - e[r];
      if (a)
          return a;
      r++
  }
  return e.length < t.length ? e.length === 1 && e[0] === 80 ? -1 : 1 : e.length > t.length ? t.length === 1 && t[0] === 80 ? 1 : -1 : 0
}
function comparePathParserScore(e, t) {
  let r = 0;
  const a = e.score
    , o = t.score;
  for (; r < a.length && r < o.length; ) {
      const l = compareScoreArray(a[r], o[r]);
      if (l)
          return l;
      r++
  }
  if (Math.abs(o.length - a.length) === 1) {
      if (isLastScoreNegative(a))
          return 1;
      if (isLastScoreNegative(o))
          return -1
  }
  return o.length - a.length
}
function isLastScoreNegative(e) {
  const t = e[e.length - 1];
  return e.length > 0 && t[t.length - 1] < 0
}
const ROOT_TOKEN = {
  type: 0,
  value: ""
}
, VALID_PARAM_RE = /[a-zA-Z0-9_]/;
function tokenizePath(e) {
  if (!e)
      return [[]];
  if (e === "/")
      return [[ROOT_TOKEN]];
  if (!e.startsWith("/"))
      throw new Error(`Invalid path "${e}"`);
  function t(P) {
      throw new Error(`ERR (${r})/"${_}": ${P}`)
  }
  let r = 0
    , a = r;
  const o = [];
  let l;
  function f() {
      l && o.push(l),
      l = []
  }
  let d = 0, g, _ = "", v = "";
  function S() {
      _ && (r === 0 ? l.push({
          type: 0,
          value: _
      }) : r === 1 || r === 2 || r === 3 ? (l.length > 1 && (g === "*" || g === "+") && t(`A repeatable param (${_}) must be alone in its segment. eg: '/:ids+.`),
      l.push({
          type: 1,
          value: _,
          regexp: v,
          repeatable: g === "*" || g === "+",
          optional: g === "*" || g === "?"
      })) : t("Invalid state to consume buffer"),
      _ = "")
  }
  function b() {
      _ += g
  }
  for (; d < e.length; ) {
      if (g = e[d++],
      g === "\\" && r !== 2) {
          a = r,
          r = 4;
          continue
      }
      switch (r) {
      case 0:
          g === "/" ? (_ && S(),
          f()) : g === ":" ? (S(),
          r = 1) : b();
          break;
      case 4:
          b(),
          r = a;
          break;
      case 1:
          g === "(" ? r = 2 : VALID_PARAM_RE.test(g) ? b() : (S(),
          r = 0,
          g !== "*" && g !== "?" && g !== "+" && d--);
          break;
      case 2:
          g === ")" ? v[v.length - 1] == "\\" ? v = v.slice(0, -1) + g : r = 3 : v += g;
          break;
      case 3:
          S(),
          r = 0,
          g !== "*" && g !== "?" && g !== "+" && d--,
          v = "";
          break;
      default:
          t("Unknown state");
          break
      }
  }
  return r === 2 && t(`Unfinished custom RegExp for param "${_}"`),
  S(),
  f(),
  o
}
function createRouteRecordMatcher(e, t, r) {
  const a = tokensToParser(tokenizePath(e.path), r)
    , o = assign(a, {
      record: e,
      parent: t,
      children: [],
      alias: []
  });
  return t && !o.record.aliasOf == !t.record.aliasOf && t.children.push(o),
  o
}
function createRouterMatcher(e, t) {
  const r = []
    , a = new Map;
  t = mergeOptions({
      strict: !1,
      end: !0,
      sensitive: !1
  }, t);
  function o(v) {
      return a.get(v)
  }
  function l(v, S, b) {
      const P = !b
        , x = normalizeRouteRecord(v);
      x.aliasOf = b && b.record;
      const E = mergeOptions(t, v)
        , I = [x];
      if ("alias"in v) {
          const T = typeof v.alias == "string" ? [v.alias] : v.alias;
          for (const w of T)
              I.push(assign({}, x, {
                  components: b ? b.record.components : x.components,
                  path: w,
                  aliasOf: b ? b.record : x
              }))
      }
      let C, A;
      for (const T of I) {
          const {path: w} = T;
          if (S && w[0] !== "/") {
              const M = S.record.path
                , F = M[M.length - 1] === "/" ? "" : "/";
              T.path = S.record.path + (w && F + w)
          }
          if (C = createRouteRecordMatcher(T, S, E),
          b ? b.alias.push(C) : (A = A || C,
          A !== C && A.alias.push(C),
          P && v.name && !isAliasRecord(C) && f(v.name)),
          x.children) {
              const M = x.children;
              for (let F = 0; F < M.length; F++)
                  l(M[F], C, b && b.children[F])
          }
          b = b || C,
          (C.record.components && Object.keys(C.record.components).length || C.record.name || C.record.redirect) && g(C)
      }
      return A ? ()=>{
          f(A)
      }
      : noop
  }
  function f(v) {
      if (isRouteName(v)) {
          const S = a.get(v);
          S && (a.delete(v),
          r.splice(r.indexOf(S), 1),
          S.children.forEach(f),
          S.alias.forEach(f))
      } else {
          const S = r.indexOf(v);
          S > -1 && (r.splice(S, 1),
          v.record.name && a.delete(v.record.name),
          v.children.forEach(f),
          v.alias.forEach(f))
      }
  }
  function d() {
      return r
  }
  function g(v) {
      let S = 0;
      for (; S < r.length && comparePathParserScore(v, r[S]) >= 0 && (v.record.path !== r[S].record.path || !isRecordChildOf(v, r[S])); )
          S++;
      r.splice(S, 0, v),
      v.record.name && !isAliasRecord(v) && a.set(v.record.name, v)
  }
  function _(v, S) {
      let b, P = {}, x, E;
      if ("name"in v && v.name) {
          if (b = a.get(v.name),
          !b)
              throw createRouterError(1, {
                  location: v
              });
          E = b.record.name,
          P = assign(paramsFromLocation(S.params, b.keys.filter(A=>!A.optional).concat(b.parent ? b.parent.keys.filter(A=>A.optional) : []).map(A=>A.name)), v.params && paramsFromLocation(v.params, b.keys.map(A=>A.name))),
          x = b.stringify(P)
      } else if (v.path != null)
          x = v.path,
          b = r.find(A=>A.re.test(x)),
          b && (P = b.parse(x),
          E = b.record.name);
      else {
          if (b = S.name ? a.get(S.name) : r.find(A=>A.re.test(S.path)),
          !b)
              throw createRouterError(1, {
                  location: v,
                  currentLocation: S
              });
          E = b.record.name,
          P = assign({}, S.params, v.params),
          x = b.stringify(P)
      }
      const I = [];
      let C = b;
      for (; C; )
          I.unshift(C.record),
          C = C.parent;
      return {
          name: E,
          path: x,
          params: P,
          matched: I,
          meta: mergeMetaFields(I)
      }
  }
  return e.forEach(v=>l(v)),
  {
      addRoute: l,
      resolve: _,
      removeRoute: f,
      getRoutes: d,
      getRecordMatcher: o
  }
}
function paramsFromLocation(e, t) {
  const r = {};
  for (const a of t)
      a in e && (r[a] = e[a]);
  return r
}
function normalizeRouteRecord(e) {
  return {
      path: e.path,
      redirect: e.redirect,
      name: e.name,
      meta: e.meta || {},
      aliasOf: void 0,
      beforeEnter: e.beforeEnter,
      props: normalizeRecordProps(e),
      children: e.children || [],
      instances: {},
      leaveGuards: new Set,
      updateGuards: new Set,
      enterCallbacks: {},
      components: "components"in e ? e.components || null : e.component && {
          default: e.component
      }
  }
}
function normalizeRecordProps(e) {
  const t = {}
    , r = e.props || !1;
  if ("component"in e)
      t.default = r;
  else
      for (const a in e.components)
          t[a] = typeof r == "object" ? r[a] : r;
  return t
}
function isAliasRecord(e) {
  for (; e; ) {
      if (e.record.aliasOf)
          return !0;
      e = e.parent
  }
  return !1
}
function mergeMetaFields(e) {
  return e.reduce((t,r)=>assign(t, r.meta), {})
}
function mergeOptions(e, t) {
  const r = {};
  for (const a in e)
      r[a] = a in t ? t[a] : e[a];
  return r
}
function isRecordChildOf(e, t) {
  return t.children.some(r=>r === e || isRecordChildOf(e, r))
}
function parseQuery(e) {
  const t = {};
  if (e === "" || e === "?")
      return t;
  const a = (e[0] === "?" ? e.slice(1) : e).split("&");
  for (let o = 0; o < a.length; ++o) {
      const l = a[o].replace(PLUS_RE, " ")
        , f = l.indexOf("=")
        , d = decode(f < 0 ? l : l.slice(0, f))
        , g = f < 0 ? null : decode(l.slice(f + 1));
      if (d in t) {
          let _ = t[d];
          isArray(_) || (_ = t[d] = [_]),
          _.push(g)
      } else
          t[d] = g
  }
  return t
}
function stringifyQuery(e) {
  let t = "";
  for (let r in e) {
      const a = e[r];
      if (r = encodeQueryKey(r),
      a == null) {
          a !== void 0 && (t += (t.length ? "&" : "") + r);
          continue
      }
      (isArray(a) ? a.map(l=>l && encodeQueryValue(l)) : [a && encodeQueryValue(a)]).forEach(l=>{
          l !== void 0 && (t += (t.length ? "&" : "") + r,
          l != null && (t += "=" + l))
      }
      )
  }
  return t
}
function normalizeQuery(e) {
  const t = {};
  for (const r in e) {
      const a = e[r];
      a !== void 0 && (t[r] = isArray(a) ? a.map(o=>o == null ? null : "" + o) : a == null ? a : "" + a)
  }
  return t
}
const matchedRouteKey = Symbol("")
, viewDepthKey = Symbol("")
, routerKey = Symbol("")
, routeLocationKey = Symbol("")
, routerViewLocationKey = Symbol("");
function useCallbacks() {
  let e = [];
  function t(a) {
      return e.push(a),
      ()=>{
          const o = e.indexOf(a);
          o > -1 && e.splice(o, 1)
      }
  }
  function r() {
      e = []
  }
  return {
      add: t,
      list: ()=>e.slice(),
      reset: r
  }
}
function guardToPromiseFn(e, t, r, a, o, l=f=>f()) {
  const f = a && (a.enterCallbacks[o] = a.enterCallbacks[o] || []);
  return ()=>new Promise((d,g)=>{
      const _ = b=>{
          b === !1 ? g(createRouterError(4, {
              from: r,
              to: t
          })) : b instanceof Error ? g(b) : isRouteLocation(b) ? g(createRouterError(2, {
              from: t,
              to: b
          })) : (f && a.enterCallbacks[o] === f && typeof b == "function" && f.push(b),
          d())
      }
        , v = l(()=>e.call(a && a.instances[o], t, r, _));
      let S = Promise.resolve(v);
      e.length < 3 && (S = S.then(_)),
      S.catch(b=>g(b))
  }
  )
}
function extractComponentsGuards(e, t, r, a, o=l=>l()) {
  const l = [];
  for (const f of e)
      for (const d in f.components) {
          let g = f.components[d];
          if (!(t !== "beforeRouteEnter" && !f.instances[d]))
              if (isRouteComponent(g)) {
                  const v = (g.__vccOpts || g)[t];
                  v && l.push(guardToPromiseFn(v, r, a, f, d, o))
              } else {
                  let _ = g();
                  l.push(()=>_.then(v=>{
                      if (!v)
                          return Promise.reject(new Error(`Couldn't resolve component "${d}" at "${f.path}"`));
                      const S = isESModule(v) ? v.default : v;
                      f.components[d] = S;
                      const P = (S.__vccOpts || S)[t];
                      return P && guardToPromiseFn(P, r, a, f, d, o)()
                  }
                  ))
              }
      }
  return l
}
function isRouteComponent(e) {
  return typeof e == "object" || "displayName"in e || "props"in e || "__vccOpts"in e
}
function useLink(e) {
  const t = inject(routerKey)
    , r = inject(routeLocationKey)
    , a = computed(()=>t.resolve(unref(e.to)))
    , o = computed(()=>{
      const {matched: g} = a.value
        , {length: _} = g
        , v = g[_ - 1]
        , S = r.matched;
      if (!v || !S.length)
          return -1;
      const b = S.findIndex(isSameRouteRecord.bind(null, v));
      if (b > -1)
          return b;
      const P = getOriginalPath(g[_ - 2]);
      return _ > 1 && getOriginalPath(v) === P && S[S.length - 1].path !== P ? S.findIndex(isSameRouteRecord.bind(null, g[_ - 2])) : b
  }
  )
    , l = computed(()=>o.value > -1 && includesParams(r.params, a.value.params))
    , f = computed(()=>o.value > -1 && o.value === r.matched.length - 1 && isSameRouteLocationParams(r.params, a.value.params));
  function d(g={}) {
      return guardEvent(g) ? t[unref(e.replace) ? "replace" : "push"](unref(e.to)).catch(noop) : Promise.resolve()
  }
  return {
      route: a,
      href: computed(()=>a.value.href),
      isActive: l,
      isExactActive: f,
      navigate: d
  }
}
const RouterLinkImpl = defineComponent({
  name: "RouterLink",
  compatConfig: {
      MODE: 3
  },
  props: {
      to: {
          type: [String, Object],
          required: !0
      },
      replace: Boolean,
      activeClass: String,
      exactActiveClass: String,
      custom: Boolean,
      ariaCurrentValue: {
          type: String,
          default: "page"
      }
  },
  useLink,
  setup(e, {slots: t}) {
      const r = reactive(useLink(e))
        , {options: a} = inject(routerKey)
        , o = computed(()=>({
          [getLinkClass(e.activeClass, a.linkActiveClass, "router-link-active")]: r.isActive,
          [getLinkClass(e.exactActiveClass, a.linkExactActiveClass, "router-link-exact-active")]: r.isExactActive
      }));
      return ()=>{
          const l = t.default && t.default(r);
          return e.custom ? l : h("a", {
              "aria-current": r.isExactActive ? e.ariaCurrentValue : null,
              href: r.href,
              onClick: r.navigate,
              class: o.value
          }, l)
      }
  }
})
, RouterLink = RouterLinkImpl;
function guardEvent(e) {
  if (!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) && !e.defaultPrevented && !(e.button !== void 0 && e.button !== 0)) {
      if (e.currentTarget && e.currentTarget.getAttribute) {
          const t = e.currentTarget.getAttribute("target");
          if (/\b_blank\b/i.test(t))
              return
      }
      return e.preventDefault && e.preventDefault(),
      !0
  }
}
function includesParams(e, t) {
  for (const r in t) {
      const a = t[r]
        , o = e[r];
      if (typeof a == "string") {
          if (a !== o)
              return !1
      } else if (!isArray(o) || o.length !== a.length || a.some((l,f)=>l !== o[f]))
          return !1
  }
  return !0
}
function getOriginalPath(e) {
  return e ? e.aliasOf ? e.aliasOf.path : e.path : ""
}
const getLinkClass = (e,t,r)=>e ?? t ?? r
, RouterViewImpl = defineComponent({
  name: "RouterView",
  inheritAttrs: !1,
  props: {
      name: {
          type: String,
          default: "default"
      },
      route: Object
  },
  compatConfig: {
      MODE: 3
  },
  setup(e, {attrs: t, slots: r}) {
      const a = inject(routerViewLocationKey)
        , o = computed(()=>e.route || a.value)
        , l = inject(viewDepthKey, 0)
        , f = computed(()=>{
          let _ = unref(l);
          const {matched: v} = o.value;
          let S;
          for (; (S = v[_]) && !S.components; )
              _++;
          return _
      }
      )
        , d = computed(()=>o.value.matched[f.value]);
      provide(viewDepthKey, computed(()=>f.value + 1)),
      provide(matchedRouteKey, d),
      provide(routerViewLocationKey, o);
      const g = ref();
      return watch(()=>[g.value, d.value, e.name], ([_,v,S],[b,P,x])=>{
          v && (v.instances[S] = _,
          P && P !== v && _ && _ === b && (v.leaveGuards.size || (v.leaveGuards = P.leaveGuards),
          v.updateGuards.size || (v.updateGuards = P.updateGuards))),
          _ && v && (!P || !isSameRouteRecord(v, P) || !b) && (v.enterCallbacks[S] || []).forEach(E=>E(_))
      }
      , {
          flush: "post"
      }),
      ()=>{
          const _ = o.value
            , v = e.name
            , S = d.value
            , b = S && S.components[v];
          if (!b)
              return normalizeSlot(r.default, {
                  Component: b,
                  route: _
              });
          const P = S.props[v]
            , x = P ? P === !0 ? _.params : typeof P == "function" ? P(_) : P : null
            , I = h(b, assign({}, x, t, {
              onVnodeUnmounted: C=>{
                  C.component.isUnmounted && (S.instances[v] = null)
              }
              ,
              ref: g
          }));
          return normalizeSlot(r.default, {
              Component: I,
              route: _
          }) || I
      }
  }
});
function normalizeSlot(e, t) {
  if (!e)
      return null;
  const r = e(t);
  return r.length === 1 ? r[0] : r
}
const RouterView = RouterViewImpl;
function createRouter(e) {
  const t = createRouterMatcher(e.routes, e)
    , r = e.parseQuery || parseQuery
    , a = e.stringifyQuery || stringifyQuery
    , o = e.history
    , l = useCallbacks()
    , f = useCallbacks()
    , d = useCallbacks()
    , g = shallowRef(START_LOCATION_NORMALIZED);
  let _ = START_LOCATION_NORMALIZED;
  isBrowser && e.scrollBehavior && "scrollRestoration"in history && (history.scrollRestoration = "manual");
  const v = applyToParams.bind(null, Q=>"" + Q)
    , S = applyToParams.bind(null, encodeParam)
    , b = applyToParams.bind(null, decode);
  function P(Q, le) {
      let fe, ue;
      return isRouteName(Q) ? (fe = t.getRecordMatcher(Q),
      ue = le) : ue = Q,
      t.addRoute(ue, fe)
  }
  function x(Q) {
      const le = t.getRecordMatcher(Q);
      le && t.removeRoute(le)
  }
  function E() {
      return t.getRoutes().map(Q=>Q.record)
  }
  function I(Q) {
      return !!t.getRecordMatcher(Q)
  }
  function C(Q, le) {
      if (le = assign({}, le || g.value),
      typeof Q == "string") {
          const z = parseURL(r, Q, le.path)
            , J = t.resolve({
              path: z.path
          }, le)
            , te = o.createHref(z.fullPath);
          return assign(z, J, {
              params: b(J.params),
              hash: decode(z.hash),
              redirectedFrom: void 0,
              href: te
          })
      }
      let fe;
      if (Q.path != null)
          fe = assign({}, Q, {
              path: parseURL(r, Q.path, le.path).path
          });
      else {
          const z = assign({}, Q.params);
          for (const J in z)
              z[J] == null && delete z[J];
          fe = assign({}, Q, {
              params: S(z)
          }),
          le.params = S(le.params)
      }
      const ue = t.resolve(fe, le)
        , be = Q.hash || "";
      ue.params = v(b(ue.params));
      const ge = stringifyURL(a, assign({}, Q, {
          hash: encodeHash(be),
          path: ue.path
      }))
        , H = o.createHref(ge);
      return assign({
          fullPath: ge,
          hash: be,
          query: a === stringifyQuery ? normalizeQuery(Q.query) : Q.query || {}
      }, ue, {
          redirectedFrom: void 0,
          href: H
      })
  }
  function A(Q) {
      return typeof Q == "string" ? parseURL(r, Q, g.value.path) : assign({}, Q)
  }
  function T(Q, le) {
      if (_ !== Q)
          return createRouterError(8, {
              from: le,
              to: Q
          })
  }
  function w(Q) {
      return O(Q)
  }
  function M(Q) {
      return w(assign(A(Q), {
          replace: !0
      }))
  }
  function F(Q) {
      const le = Q.matched[Q.matched.length - 1];
      if (le && le.redirect) {
          const {redirect: fe} = le;
          let ue = typeof fe == "function" ? fe(Q) : fe;
          return typeof ue == "string" && (ue = ue.includes("?") || ue.includes("#") ? ue = A(ue) : {
              path: ue
          },
          ue.params = {}),
          assign({
              query: Q.query,
              hash: Q.hash,
              params: ue.path != null ? {} : Q.params
          }, ue)
      }
  }
  function O(Q, le) {
      const fe = _ = C(Q)
        , ue = g.value
        , be = Q.state
        , ge = Q.force
        , H = Q.replace === !0
        , z = F(fe);
      if (z)
          return O(assign(A(z), {
              state: typeof z == "object" ? assign({}, be, z.state) : be,
              force: ge,
              replace: H
          }), le || fe);
      const J = fe;
      J.redirectedFrom = le;
      let te;
      return !ge && isSameRouteLocation(a, ue, fe) && (te = createRouterError(16, {
          to: J,
          from: ue
      }),
      q(ue, ue, !0, !1)),
      (te ? Promise.resolve(te) : K(J, ue)).catch(U=>isNavigationFailure(U) ? isNavigationFailure(U, 2) ? U : V(U) : R(U, J, ue)).then(U=>{
          if (U) {
              if (isNavigationFailure(U, 2))
                  return O(assign({
                      replace: H
                  }, A(U.to), {
                      state: typeof U.to == "object" ? assign({}, be, U.to.state) : be,
                      force: ge
                  }), le || J)
          } else
              U = W(J, ue, !0, H, be);
          return Y(J, ue, U),
          U
      }
      )
  }
  function $(Q, le) {
      const fe = T(Q, le);
      return fe ? Promise.reject(fe) : Promise.resolve()
  }
  function j(Q) {
      const le = pe.values().next().value;
      return le && typeof le.runWithContext == "function" ? le.runWithContext(Q) : Q()
  }
  function K(Q, le) {
      let fe;
      const [ue,be,ge] = extractChangingRecords(Q, le);
      fe = extractComponentsGuards(ue.reverse(), "beforeRouteLeave", Q, le);
      for (const z of ue)
          z.leaveGuards.forEach(J=>{
              fe.push(guardToPromiseFn(J, Q, le))
          }
          );
      const H = $.bind(null, Q, le);
      return fe.push(H),
      me(fe).then(()=>{
          fe = [];
          for (const z of l.list())
              fe.push(guardToPromiseFn(z, Q, le));
          return fe.push(H),
          me(fe)
      }
      ).then(()=>{
          fe = extractComponentsGuards(be, "beforeRouteUpdate", Q, le);
          for (const z of be)
              z.updateGuards.forEach(J=>{
                  fe.push(guardToPromiseFn(J, Q, le))
              }
              );
          return fe.push(H),
          me(fe)
      }
      ).then(()=>{
          fe = [];
          for (const z of ge)
              if (z.beforeEnter)
                  if (isArray(z.beforeEnter))
                      for (const J of z.beforeEnter)
                          fe.push(guardToPromiseFn(J, Q, le));
                  else
                      fe.push(guardToPromiseFn(z.beforeEnter, Q, le));
          return fe.push(H),
          me(fe)
      }
      ).then(()=>(Q.matched.forEach(z=>z.enterCallbacks = {}),
      fe = extractComponentsGuards(ge, "beforeRouteEnter", Q, le, j),
      fe.push(H),
      me(fe))).then(()=>{
          fe = [];
          for (const z of f.list())
              fe.push(guardToPromiseFn(z, Q, le));
          return fe.push(H),
          me(fe)
      }
      ).catch(z=>isNavigationFailure(z, 8) ? z : Promise.reject(z))
  }
  function Y(Q, le, fe) {
      d.list().forEach(ue=>j(()=>ue(Q, le, fe)))
  }
  function W(Q, le, fe, ue, be) {
      const ge = T(Q, le);
      if (ge)
          return ge;
      const H = le === START_LOCATION_NORMALIZED
        , z = isBrowser ? history.state : {};
      fe && (ue || H ? o.replace(Q.fullPath, assign({
          scroll: H && z && z.scroll
      }, be)) : o.push(Q.fullPath, be)),
      g.value = Q,
      q(Q, le, fe, H),
      V()
  }
  let Z;
  function ee() {
      Z || (Z = o.listen((Q,le,fe)=>{
          if (!Pe.listening)
              return;
          const ue = C(Q)
            , be = F(ue);
          if (be) {
              O(assign(be, {
                  replace: !0
              }), ue).catch(noop);
              return
          }
          _ = ue;
          const ge = g.value;
          isBrowser && saveScrollPosition(getScrollKey(ge.fullPath, fe.delta), computeScrollPosition()),
          K(ue, ge).catch(H=>isNavigationFailure(H, 12) ? H : isNavigationFailure(H, 2) ? (O(H.to, ue).then(z=>{
              isNavigationFailure(z, 20) && !fe.delta && fe.type === NavigationType.pop && o.go(-1, !1)
          }
          ).catch(noop),
          Promise.reject()) : (fe.delta && o.go(-fe.delta, !1),
          R(H, ue, ge))).then(H=>{
              H = H || W(ue, ge, !1),
              H && (fe.delta && !isNavigationFailure(H, 8) ? o.go(-fe.delta, !1) : fe.type === NavigationType.pop && isNavigationFailure(H, 20) && o.go(-1, !1)),
              Y(ue, ge, H)
          }
          ).catch(noop)
      }
      ))
  }
  let X = useCallbacks(), D = useCallbacks(), B;
  function R(Q, le, fe) {
      V(Q);
      const ue = D.list();
      return ue.length ? ue.forEach(be=>be(Q, le, fe)) : console.error(Q),
      Promise.reject(Q)
  }
  function L() {
      return B && g.value !== START_LOCATION_NORMALIZED ? Promise.resolve() : new Promise((Q,le)=>{
          X.add([Q, le])
      }
      )
  }
  function V(Q) {
      return B || (B = !Q,
      ee(),
      X.list().forEach(([le,fe])=>Q ? fe(Q) : le()),
      X.reset()),
      Q
  }
  function q(Q, le, fe, ue) {
      const {scrollBehavior: be} = e;
      if (!isBrowser || !be)
          return Promise.resolve();
      const ge = !fe && getSavedScrollPosition(getScrollKey(Q.fullPath, 0)) || (ue || !fe) && history.state && history.state.scroll || null;
      return nextTick().then(()=>be(Q, le, ge)).then(H=>H && scrollToPosition(H)).catch(H=>R(H, Q, le))
  }
  const oe = Q=>o.go(Q);
  let ye;
  const pe = new Set
    , Pe = {
      currentRoute: g,
      listening: !0,
      addRoute: P,
      removeRoute: x,
      hasRoute: I,
      getRoutes: E,
      resolve: C,
      options: e,
      push: w,
      replace: M,
      go: oe,
      back: ()=>oe(-1),
      forward: ()=>oe(1),
      beforeEach: l.add,
      beforeResolve: f.add,
      afterEach: d.add,
      onError: D.add,
      isReady: L,
      install(Q) {
          const le = this;
          Q.component("RouterLink", RouterLink),
          Q.component("RouterView", RouterView),
          Q.config.globalProperties.$router = le,
          Object.defineProperty(Q.config.globalProperties, "$route", {
              enumerable: !0,
              get: ()=>unref(g)
          }),
          isBrowser && !ye && g.value === START_LOCATION_NORMALIZED && (ye = !0,
          w(o.location).catch(be=>{}
          ));
          const fe = {};
          for (const be in START_LOCATION_NORMALIZED)
              Object.defineProperty(fe, be, {
                  get: ()=>g.value[be],
                  enumerable: !0
              });
          Q.provide(routerKey, le),
          Q.provide(routeLocationKey, shallowReactive(fe)),
          Q.provide(routerViewLocationKey, g);
          const ue = Q.unmount;
          pe.add(Q),
          Q.unmount = function() {
              pe.delete(Q),
              pe.size < 1 && (_ = START_LOCATION_NORMALIZED,
              Z && Z(),
              Z = null,
              g.value = START_LOCATION_NORMALIZED,
              ye = !1,
              B = !1),
              ue()
          }
      }
  };
  function me(Q) {
      return Q.reduce((le,fe)=>le.then(()=>j(fe)), Promise.resolve())
  }
  return Pe
}
function extractChangingRecords(e, t) {
  const r = []
    , a = []
    , o = []
    , l = Math.max(t.matched.length, e.matched.length);
  for (let f = 0; f < l; f++) {
      const d = t.matched[f];
      d && (e.matched.find(_=>isSameRouteRecord(_, d)) ? a.push(d) : r.push(d));
      const g = e.matched[f];
      g && (t.matched.find(_=>isSameRouteRecord(_, g)) || o.push(g))
  }
  return [r, a, o]
}
function useRoute() {
  return inject(routeLocationKey)
}
const interpolatePath = (e,t)=>t.path.replace(/(:\w+)\([^)]+\)/g, "$1").replace(/(:\w+)[?+*]/g, "$1").replace(/:\w+/g, r=>{
  var a;
  return ((a = e.params[r.slice(1)]) == null ? void 0 : a.toString()) || ""
}
)
, generateRouteKey$1 = (e,t)=>{
  const r = e.route.matched.find(o=>{
      var l;
      return ((l = o.components) == null ? void 0 : l.default) === e.Component.type
  }
  )
    , a = t ?? (r == null ? void 0 : r.meta.key) ?? (r && interpolatePath(e.route, r));
  return typeof a == "function" ? a(e.route) : a
}
, wrapInKeepAlive = (e,t)=>({
  default: ()=>e ? h(KeepAlive, e === !0 ? {} : e, t) : t
});
function toArray$1(e) {
  return Array.isArray(e) ? e : [e]
}
function _assertThisInitialized(e) {
  if (e === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e
}
function _inheritsLoose(e, t) {
  e.prototype = Object.create(t.prototype),
  e.prototype.constructor = e,
  e.__proto__ = t
}
/*!
* GSAP 3.11.5
* https://greensock.com
*
* @license Copyright 2008-2023, GreenSock. All rights reserved.
* Subject to the terms at https://greensock.com/standard-license or for
* Club GreenSock members, the agreement issued with that membership.
* @author: Jack Doyle, jack@greensock.com
*/
var _config = {
  autoSleep: 120,
  force3D: "auto",
  nullTargetWarn: 1,
  units: {
      lineHeight: ""
  }
}, _defaults$1 = {
  duration: .5,
  overwrite: !1,
  delay: 0
}, _suppressOverwrites$1, _reverting$1, _context$2, _bigNum$1 = 1e8, _tinyNum = 1 / _bigNum$1, _2PI = Math.PI * 2, _HALF_PI = _2PI / 4, _gsID = 0, _sqrt = Math.sqrt, _cos = Math.cos, _sin = Math.sin, _isString$1 = function(t) {
  return typeof t == "string"
}, _isFunction$1 = function(t) {
  return typeof t == "function"
}, _isNumber$1 = function(t) {
  return typeof t == "number"
}, _isUndefined = function(t) {
  return typeof t > "u"
}, _isObject$1 = function(t) {
  return typeof t == "object"
}, _isNotFalse = function(t) {
  return t !== !1
}, _windowExists$2 = function() {
  return typeof window < "u"
}, _isFuncOrString = function(t) {
  return _isFunction$1(t) || _isString$1(t)
}, _isTypedArray = typeof ArrayBuffer == "function" && ArrayBuffer.isView || function() {}
, _isArray = Array.isArray, _strictNumExp = /(?:-?\.?\d|\.)+/gi, _numExp = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, _numWithUnitExp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, _complexStringNumExp = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, _relExp = /[+-]=-?[.\d]+/, _delimitedValueExp = /[^,'"\[\]\s]+/gi, _unitExp = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, _globalTimeline, _win$3, _coreInitted$2, _doc$3, _globals = {}, _installScope = {}, _coreReady, _install = function(t) {
  return (_installScope = _merge(t, _globals)) && gsap$2
}, _missingPlugin = function(t, r) {
  return console.warn("Invalid property", t, "set to", r, "Missing plugin? gsap.registerPlugin()")
}, _warn = function(t, r) {
  return !r && console.warn(t)
}, _addGlobal = function(t, r) {
  return t && (_globals[t] = r) && _installScope && (_installScope[t] = r) || _globals
}, _emptyFunc = function() {
  return 0
}, _startAtRevertConfig = {
  suppressEvents: !0,
  isStart: !0,
  kill: !1
}, _revertConfigNoKill = {
  suppressEvents: !0,
  kill: !1
}, _revertConfig = {
  suppressEvents: !0
}, _reservedProps = {}, _lazyTweens = [], _lazyLookup = {}, _lastRenderedFrame, _plugins = {}, _effects = {}, _nextGCFrame = 30, _harnessPlugins = [], _callbackNames = "", _harness = function(t) {
  var r = t[0], a, o;
  if (_isObject$1(r) || _isFunction$1(r) || (t = [t]),
  !(a = (r._gsap || {}).harness)) {
      for (o = _harnessPlugins.length; o-- && !_harnessPlugins[o].targetTest(r); )
          ;
      a = _harnessPlugins[o]
  }
  for (o = t.length; o--; )
      t[o] && (t[o]._gsap || (t[o]._gsap = new GSCache(t[o],a))) || t.splice(o, 1);
  return t
}, _getCache = function(t) {
  return t._gsap || _harness(toArray(t))[0]._gsap
}, _getProperty = function(t, r, a) {
  return (a = t[r]) && _isFunction$1(a) ? t[r]() : _isUndefined(a) && t.getAttribute && t.getAttribute(r) || a
}, _forEachName = function(t, r) {
  return (t = t.split(",")).forEach(r) || t
}, _round$1 = function(t) {
  return Math.round(t * 1e5) / 1e5 || 0
}, _roundPrecise = function(t) {
  return Math.round(t * 1e7) / 1e7 || 0
}, _parseRelative = function(t, r) {
  var a = r.charAt(0)
    , o = parseFloat(r.substr(2));
  return t = parseFloat(t),
  a === "+" ? t + o : a === "-" ? t - o : a === "*" ? t * o : t / o
}, _arrayContainsAny = function(t, r) {
  for (var a = r.length, o = 0; t.indexOf(r[o]) < 0 && ++o < a; )
      ;
  return o < a
}, _lazyRender = function() {
  var t = _lazyTweens.length, r = _lazyTweens.slice(0), a, o;
  for (_lazyLookup = {},
  _lazyTweens.length = 0,
  a = 0; a < t; a++)
      o = r[a],
      o && o._lazy && (o.render(o._lazy[0], o._lazy[1], !0)._lazy = 0)
}, _lazySafeRender = function(t, r, a, o) {
  _lazyTweens.length && !_reverting$1 && _lazyRender(),
  t.render(r, a, o || _reverting$1 && r < 0 && (t._initted || t._startAt)),
  _lazyTweens.length && !_reverting$1 && _lazyRender()
}, _numericIfPossible = function(t) {
  var r = parseFloat(t);
  return (r || r === 0) && (t + "").match(_delimitedValueExp).length < 2 ? r : _isString$1(t) ? t.trim() : t
}, _passThrough$1 = function(t) {
  return t
}, _setDefaults$1 = function(t, r) {
  for (var a in r)
      a in t || (t[a] = r[a]);
  return t
}, _setKeyframeDefaults = function(t) {
  return function(r, a) {
      for (var o in a)
          o in r || o === "duration" && t || o === "ease" || (r[o] = a[o])
  }
}, _merge = function(t, r) {
  for (var a in r)
      t[a] = r[a];
  return t
}, _mergeDeep = function e(t, r) {
  for (var a in r)
      a !== "__proto__" && a !== "constructor" && a !== "prototype" && (t[a] = _isObject$1(r[a]) ? e(t[a] || (t[a] = {}), r[a]) : r[a]);
  return t
}, _copyExcluding = function(t, r) {
  var a = {}, o;
  for (o in t)
      o in r || (a[o] = t[o]);
  return a
}, _inheritDefaults = function(t) {
  var r = t.parent || _globalTimeline
    , a = t.keyframes ? _setKeyframeDefaults(_isArray(t.keyframes)) : _setDefaults$1;
  if (_isNotFalse(t.inherit))
      for (; r; )
          a(t, r.vars.defaults),
          r = r.parent || r._dp;
  return t
}, _arraysMatch = function(t, r) {
  for (var a = t.length, o = a === r.length; o && a-- && t[a] === r[a]; )
      ;
  return a < 0
}, _addLinkedListItem = function(t, r, a, o, l) {
  a === void 0 && (a = "_first"),
  o === void 0 && (o = "_last");
  var f = t[o], d;
  if (l)
      for (d = r[l]; f && f[l] > d; )
          f = f._prev;
  return f ? (r._next = f._next,
  f._next = r) : (r._next = t[a],
  t[a] = r),
  r._next ? r._next._prev = r : t[o] = r,
  r._prev = f,
  r.parent = r._dp = t,
  r
}, _removeLinkedListItem = function(t, r, a, o) {
  a === void 0 && (a = "_first"),
  o === void 0 && (o = "_last");
  var l = r._prev
    , f = r._next;
  l ? l._next = f : t[a] === r && (t[a] = f),
  f ? f._prev = l : t[o] === r && (t[o] = l),
  r._next = r._prev = r.parent = null
}, _removeFromParent = function(t, r) {
  t.parent && (!r || t.parent.autoRemoveChildren) && t.parent.remove(t),
  t._act = 0
}, _uncache = function(t, r) {
  if (t && (!r || r._end > t._dur || r._start < 0))
      for (var a = t; a; )
          a._dirty = 1,
          a = a.parent;
  return t
}, _recacheAncestors = function(t) {
  for (var r = t.parent; r && r.parent; )
      r._dirty = 1,
      r.totalDuration(),
      r = r.parent;
  return t
}, _rewindStartAt = function(t, r, a, o) {
  return t._startAt && (_reverting$1 ? t._startAt.revert(_revertConfigNoKill) : t.vars.immediateRender && !t.vars.autoRevert || t._startAt.render(r, !0, o))
}, _hasNoPausedAncestors = function e(t) {
  return !t || t._ts && e(t.parent)
}, _elapsedCycleDuration = function(t) {
  return t._repeat ? _animationCycle(t._tTime, t = t.duration() + t._rDelay) * t : 0
}, _animationCycle = function(t, r) {
  var a = Math.floor(t /= r);
  return t && a === t ? a - 1 : a
}, _parentToChildTotalTime = function(t, r) {
  return (t - r._start) * r._ts + (r._ts >= 0 ? 0 : r._dirty ? r.totalDuration() : r._tDur)
}, _setEnd = function(t) {
  return t._end = _roundPrecise(t._start + (t._tDur / Math.abs(t._ts || t._rts || _tinyNum) || 0))
}, _alignPlayhead = function(t, r) {
  var a = t._dp;
  return a && a.smoothChildTiming && t._ts && (t._start = _roundPrecise(a._time - (t._ts > 0 ? r / t._ts : ((t._dirty ? t.totalDuration() : t._tDur) - r) / -t._ts)),
  _setEnd(t),
  a._dirty || _uncache(a, t)),
  t
}, _postAddChecks = function(t, r) {
  var a;
  if ((r._time || r._initted && !r._dur) && (a = _parentToChildTotalTime(t.rawTime(), r),
  (!r._dur || _clamp$1(0, r.totalDuration(), a) - r._tTime > _tinyNum) && r.render(a, !0)),
  _uncache(t, r)._dp && t._initted && t._time >= t._dur && t._ts) {
      if (t._dur < t.duration())
          for (a = t; a._dp; )
              a.rawTime() >= 0 && a.totalTime(a._tTime),
              a = a._dp;
      t._zTime = -_tinyNum
  }
}, _addToTimeline = function(t, r, a, o) {
  return r.parent && _removeFromParent(r),
  r._start = _roundPrecise((_isNumber$1(a) ? a : a || t !== _globalTimeline ? _parsePosition$1(t, a, r) : t._time) + r._delay),
  r._end = _roundPrecise(r._start + (r.totalDuration() / Math.abs(r.timeScale()) || 0)),
  _addLinkedListItem(t, r, "_first", "_last", t._sort ? "_start" : 0),
  _isFromOrFromStart(r) || (t._recent = r),
  o || _postAddChecks(t, r),
  t._ts < 0 && _alignPlayhead(t, t._tTime),
  t
}, _scrollTrigger = function(t, r) {
  return (_globals.ScrollTrigger || _missingPlugin("scrollTrigger", r)) && _globals.ScrollTrigger.create(r, t)
}, _attemptInitTween = function(t, r, a, o, l) {
  if (_initTween(t, r, l),
  !t._initted)
      return 1;
  if (!a && t._pt && !_reverting$1 && (t._dur && t.vars.lazy !== !1 || !t._dur && t.vars.lazy) && _lastRenderedFrame !== _ticker.frame)
      return _lazyTweens.push(t),
      t._lazy = [l, o],
      1
}, _parentPlayheadIsBeforeStart = function e(t) {
  var r = t.parent;
  return r && r._ts && r._initted && !r._lock && (r.rawTime() < 0 || e(r))
}, _isFromOrFromStart = function(t) {
  var r = t.data;
  return r === "isFromStart" || r === "isStart"
}, _renderZeroDurationTween = function(t, r, a, o) {
  var l = t.ratio, f = r < 0 || !r && (!t._start && _parentPlayheadIsBeforeStart(t) && !(!t._initted && _isFromOrFromStart(t)) || (t._ts < 0 || t._dp._ts < 0) && !_isFromOrFromStart(t)) ? 0 : 1, d = t._rDelay, g = 0, _, v, S;
  if (d && t._repeat && (g = _clamp$1(0, t._tDur, r),
  v = _animationCycle(g, d),
  t._yoyo && v & 1 && (f = 1 - f),
  v !== _animationCycle(t._tTime, d) && (l = 1 - f,
  t.vars.repeatRefresh && t._initted && t.invalidate())),
  f !== l || _reverting$1 || o || t._zTime === _tinyNum || !r && t._zTime) {
      if (!t._initted && _attemptInitTween(t, r, o, a, g))
          return;
      for (S = t._zTime,
      t._zTime = r || (a ? _tinyNum : 0),
      a || (a = r && !S),
      t.ratio = f,
      t._from && (f = 1 - f),
      t._time = 0,
      t._tTime = g,
      _ = t._pt; _; )
          _.r(f, _.d),
          _ = _._next;
      r < 0 && _rewindStartAt(t, r, a, !0),
      t._onUpdate && !a && _callback$1(t, "onUpdate"),
      g && t._repeat && !a && t.parent && _callback$1(t, "onRepeat"),
      (r >= t._tDur || r < 0) && t.ratio === f && (f && _removeFromParent(t, 1),
      !a && !_reverting$1 && (_callback$1(t, f ? "onComplete" : "onReverseComplete", !0),
      t._prom && t._prom()))
  } else
      t._zTime || (t._zTime = r)
}, _findNextPauseTween = function(t, r, a) {
  var o;
  if (a > r)
      for (o = t._first; o && o._start <= a; ) {
          if (o.data === "isPause" && o._start > r)
              return o;
          o = o._next
      }
  else
      for (o = t._last; o && o._start >= a; ) {
          if (o.data === "isPause" && o._start < r)
              return o;
          o = o._prev
      }
}, _setDuration = function(t, r, a, o) {
  var l = t._repeat
    , f = _roundPrecise(r) || 0
    , d = t._tTime / t._tDur;
  return d && !o && (t._time *= f / t._dur),
  t._dur = f,
  t._tDur = l ? l < 0 ? 1e10 : _roundPrecise(f * (l + 1) + t._rDelay * l) : f,
  d > 0 && !o && _alignPlayhead(t, t._tTime = t._tDur * d),
  t.parent && _setEnd(t),
  a || _uncache(t.parent, t),
  t
}, _onUpdateTotalDuration = function(t) {
  return t instanceof Timeline ? _uncache(t) : _setDuration(t, t._dur)
}, _zeroPosition = {
  _start: 0,
  endTime: _emptyFunc,
  totalDuration: _emptyFunc
}, _parsePosition$1 = function e(t, r, a) {
  var o = t.labels, l = t._recent || _zeroPosition, f = t.duration() >= _bigNum$1 ? l.endTime(!1) : t._dur, d, g, _;
  return _isString$1(r) && (isNaN(r) || r in o) ? (g = r.charAt(0),
  _ = r.substr(-1) === "%",
  d = r.indexOf("="),
  g === "<" || g === ">" ? (d >= 0 && (r = r.replace(/=/, "")),
  (g === "<" ? l._start : l.endTime(l._repeat >= 0)) + (parseFloat(r.substr(1)) || 0) * (_ ? (d < 0 ? l : a).totalDuration() / 100 : 1)) : d < 0 ? (r in o || (o[r] = f),
  o[r]) : (g = parseFloat(r.charAt(d - 1) + r.substr(d + 1)),
  _ && a && (g = g / 100 * (_isArray(a) ? a[0] : a).totalDuration()),
  d > 1 ? e(t, r.substr(0, d - 1), a) + g : f + g)) : r == null ? f : +r
}, _createTweenType = function(t, r, a) {
  var o = _isNumber$1(r[1]), l = (o ? 2 : 1) + (t < 2 ? 0 : 1), f = r[l], d, g;
  if (o && (f.duration = r[1]),
  f.parent = a,
  t) {
      for (d = f,
      g = a; g && !("immediateRender"in d); )
          d = g.vars.defaults || {},
          g = _isNotFalse(g.vars.inherit) && g.parent;
      f.immediateRender = _isNotFalse(d.immediateRender),
      t < 2 ? f.runBackwards = 1 : f.startAt = r[l - 1]
  }
  return new Tween(r[0],f,r[l + 1])
}, _conditionalReturn = function(t, r) {
  return t || t === 0 ? r(t) : r
}, _clamp$1 = function(t, r, a) {
  return a < t ? t : a > r ? r : a
}, getUnit = function(t, r) {
  return !_isString$1(t) || !(r = _unitExp.exec(t)) ? "" : r[1]
}, clamp = function(t, r, a) {
  return _conditionalReturn(a, function(o) {
      return _clamp$1(t, r, o)
  })
}, _slice = [].slice, _isArrayLike = function(t, r) {
  return t && _isObject$1(t) && "length"in t && (!r && !t.length || t.length - 1 in t && _isObject$1(t[0])) && !t.nodeType && t !== _win$3
}, _flatten = function(t, r, a) {
  return a === void 0 && (a = []),
  t.forEach(function(o) {
      var l;
      return _isString$1(o) && !r || _isArrayLike(o, 1) ? (l = a).push.apply(l, toArray(o)) : a.push(o)
  }) || a
}, toArray = function(t, r, a) {
  return _context$2 && !r && _context$2.selector ? _context$2.selector(t) : _isString$1(t) && !a && (_coreInitted$2 || !_wake()) ? _slice.call((r || _doc$3).querySelectorAll(t), 0) : _isArray(t) ? _flatten(t, a) : _isArrayLike(t) ? _slice.call(t, 0) : t ? [t] : []
}, selector = function(t) {
  return t = toArray(t)[0] || _warn("Invalid scope") || {},
  function(r) {
      var a = t.current || t.nativeElement || t;
      return toArray(r, a.querySelectorAll ? a : a === t ? _warn("Invalid scope") || _doc$3.createElement("div") : t)
  }
}, shuffle = function(t) {
  return t.sort(function() {
      return .5 - Math.random()
  })
}, distribute = function(t) {
  if (_isFunction$1(t))
      return t;
  var r = _isObject$1(t) ? t : {
      each: t
  }
    , a = _parseEase(r.ease)
    , o = r.from || 0
    , l = parseFloat(r.base) || 0
    , f = {}
    , d = o > 0 && o < 1
    , g = isNaN(o) || d
    , _ = r.axis
    , v = o
    , S = o;
  return _isString$1(o) ? v = S = {
      center: .5,
      edges: .5,
      end: 1
  }[o] || 0 : !d && g && (v = o[0],
  S = o[1]),
  function(b, P, x) {
      var E = (x || r).length, I = f[E], C, A, T, w, M, F, O, $, j;
      if (!I) {
          if (j = r.grid === "auto" ? 0 : (r.grid || [1, _bigNum$1])[1],
          !j) {
              for (O = -_bigNum$1; O < (O = x[j++].getBoundingClientRect().left) && j < E; )
                  ;
              j--
          }
          for (I = f[E] = [],
          C = g ? Math.min(j, E) * v - .5 : o % j,
          A = j === _bigNum$1 ? 0 : g ? E * S / j - .5 : o / j | 0,
          O = 0,
          $ = _bigNum$1,
          F = 0; F < E; F++)
              T = F % j - C,
              w = A - (F / j | 0),
              I[F] = M = _ ? Math.abs(_ === "y" ? w : T) : _sqrt(T * T + w * w),
              M > O && (O = M),
              M < $ && ($ = M);
          o === "random" && shuffle(I),
          I.max = O - $,
          I.min = $,
          I.v = E = (parseFloat(r.amount) || parseFloat(r.each) * (j > E ? E - 1 : _ ? _ === "y" ? E / j : j : Math.max(j, E / j)) || 0) * (o === "edges" ? -1 : 1),
          I.b = E < 0 ? l - E : l,
          I.u = getUnit(r.amount || r.each) || 0,
          a = a && E < 0 ? _invertEase(a) : a
      }
      return E = (I[b] - I.min) / I.max || 0,
      _roundPrecise(I.b + (a ? a(E) : E) * I.v) + I.u
  }
}, _roundModifier = function(t) {
  var r = Math.pow(10, ((t + "").split(".")[1] || "").length);
  return function(a) {
      var o = _roundPrecise(Math.round(parseFloat(a) / t) * t * r);
      return (o - o % 1) / r + (_isNumber$1(a) ? 0 : getUnit(a))
  }
}, snap = function(t, r) {
  var a = _isArray(t), o, l;
  return !a && _isObject$1(t) && (o = a = t.radius || _bigNum$1,
  t.values ? (t = toArray(t.values),
  (l = !_isNumber$1(t[0])) && (o *= o)) : t = _roundModifier(t.increment)),
  _conditionalReturn(r, a ? _isFunction$1(t) ? function(f) {
      return l = t(f),
      Math.abs(l - f) <= o ? l : f
  }
  : function(f) {
      for (var d = parseFloat(l ? f.x : f), g = parseFloat(l ? f.y : 0), _ = _bigNum$1, v = 0, S = t.length, b, P; S--; )
          l ? (b = t[S].x - d,
          P = t[S].y - g,
          b = b * b + P * P) : b = Math.abs(t[S] - d),
          b < _ && (_ = b,
          v = S);
      return v = !o || _ <= o ? t[v] : f,
      l || v === f || _isNumber$1(f) ? v : v + getUnit(f)
  }
  : _roundModifier(t))
}, random = function(t, r, a, o) {
  return _conditionalReturn(_isArray(t) ? !r : a === !0 ? !!(a = 0) : !o, function() {
      return _isArray(t) ? t[~~(Math.random() * t.length)] : (a = a || 1e-5) && (o = a < 1 ? Math.pow(10, (a + "").length - 2) : 1) && Math.floor(Math.round((t - a / 2 + Math.random() * (r - t + a * .99)) / a) * a * o) / o
  })
}, pipe = function() {
  for (var t = arguments.length, r = new Array(t), a = 0; a < t; a++)
      r[a] = arguments[a];
  return function(o) {
      return r.reduce(function(l, f) {
          return f(l)
      }, o)
  }
}, unitize = function(t, r) {
  return function(a) {
      return t(parseFloat(a)) + (r || getUnit(a))
  }
}, normalize = function(t, r, a) {
  return mapRange(t, r, 0, 1, a)
}, _wrapArray = function(t, r, a) {
  return _conditionalReturn(a, function(o) {
      return t[~~r(o)]
  })
}, wrap = function e(t, r, a) {
  var o = r - t;
  return _isArray(t) ? _wrapArray(t, e(0, t.length), r) : _conditionalReturn(a, function(l) {
      return (o + (l - t) % o) % o + t
  })
}, wrapYoyo = function e(t, r, a) {
  var o = r - t
    , l = o * 2;
  return _isArray(t) ? _wrapArray(t, e(0, t.length - 1), r) : _conditionalReturn(a, function(f) {
      return f = (l + (f - t) % l) % l || 0,
      t + (f > o ? l - f : f)
  })
}, _replaceRandom = function(t) {
  for (var r = 0, a = "", o, l, f, d; ~(o = t.indexOf("random(", r)); )
      f = t.indexOf(")", o),
      d = t.charAt(o + 7) === "[",
      l = t.substr(o + 7, f - o - 7).match(d ? _delimitedValueExp : _strictNumExp),
      a += t.substr(r, o - r) + random(d ? l : +l[0], d ? 0 : +l[1], +l[2] || 1e-5),
      r = f + 1;
  return a + t.substr(r, t.length - r)
}, mapRange = function(t, r, a, o, l) {
  var f = r - t
    , d = o - a;
  return _conditionalReturn(l, function(g) {
      return a + ((g - t) / f * d || 0)
  })
}, interpolate = function e(t, r, a, o) {
  var l = isNaN(t + r) ? 0 : function(P) {
      return (1 - P) * t + P * r
  }
  ;
  if (!l) {
      var f = _isString$1(t), d = {}, g, _, v, S, b;
      if (a === !0 && (o = 1) && (a = null),
      f)
          t = {
              p: t
          },
          r = {
              p: r
          };
      else if (_isArray(t) && !_isArray(r)) {
          for (v = [],
          S = t.length,
          b = S - 2,
          _ = 1; _ < S; _++)
              v.push(e(t[_ - 1], t[_]));
          S--,
          l = function(x) {
              x *= S;
              var E = Math.min(b, ~~x);
              return v[E](x - E)
          }
          ,
          a = r
      } else
          o || (t = _merge(_isArray(t) ? [] : {}, t));
      if (!v) {
          for (g in r)
              _addPropTween.call(d, t, g, "get", r[g]);
          l = function(x) {
              return _renderPropTweens(x, d) || (f ? t.p : t)
          }
      }
  }
  return _conditionalReturn(a, l)
}, _getLabelInDirection = function(t, r, a) {
  var o = t.labels, l = _bigNum$1, f, d, g;
  for (f in o)
      d = o[f] - r,
      d < 0 == !!a && d && l > (d = Math.abs(d)) && (g = f,
      l = d);
  return g
}, _callback$1 = function(t, r, a) {
  var o = t.vars, l = o[r], f = _context$2, d = t._ctx, g, _, v;
  if (l)
      return g = o[r + "Params"],
      _ = o.callbackScope || t,
      a && _lazyTweens.length && _lazyRender(),
      d && (_context$2 = d),
      v = g ? l.apply(_, g) : l.call(_),
      _context$2 = f,
      v
}, _interrupt = function(t) {
  return _removeFromParent(t),
  t.scrollTrigger && t.scrollTrigger.kill(!!_reverting$1),
  t.progress() < 1 && _callback$1(t, "onInterrupt"),
  t
}, _quickTween, _registerPluginQueue = [], _createPlugin = function(t) {
  if (!_windowExists$2()) {
      _registerPluginQueue.push(t);
      return
  }
  t = !t.name && t.default || t;
  var r = t.name
    , a = _isFunction$1(t)
    , o = r && !a && t.init ? function() {
      this._props = []
  }
  : t
    , l = {
      init: _emptyFunc,
      render: _renderPropTweens,
      add: _addPropTween,
      kill: _killPropTweensOf,
      modifier: _addPluginModifier,
      rawVars: 0
  }
    , f = {
      targetTest: 0,
      get: 0,
      getSetter: _getSetter,
      aliases: {},
      register: 0
  };
  if (_wake(),
  t !== o) {
      if (_plugins[r])
          return;
      _setDefaults$1(o, _setDefaults$1(_copyExcluding(t, l), f)),
      _merge(o.prototype, _merge(l, _copyExcluding(t, f))),
      _plugins[o.prop = r] = o,
      t.targetTest && (_harnessPlugins.push(o),
      _reservedProps[r] = 1),
      r = (r === "css" ? "CSS" : r.charAt(0).toUpperCase() + r.substr(1)) + "Plugin"
  }
  _addGlobal(r, o),
  t.register && t.register(gsap$2, o, PropTween)
}, _255 = 255, _colorLookup = {
  aqua: [0, _255, _255],
  lime: [0, _255, 0],
  silver: [192, 192, 192],
  black: [0, 0, 0],
  maroon: [128, 0, 0],
  teal: [0, 128, 128],
  blue: [0, 0, _255],
  navy: [0, 0, 128],
  white: [_255, _255, _255],
  olive: [128, 128, 0],
  yellow: [_255, _255, 0],
  orange: [_255, 165, 0],
  gray: [128, 128, 128],
  purple: [128, 0, 128],
  green: [0, 128, 0],
  red: [_255, 0, 0],
  pink: [_255, 192, 203],
  cyan: [0, _255, _255],
  transparent: [_255, _255, _255, 0]
}, _hue = function(t, r, a) {
  return t += t < 0 ? 1 : t > 1 ? -1 : 0,
  (t * 6 < 1 ? r + (a - r) * t * 6 : t < .5 ? a : t * 3 < 2 ? r + (a - r) * (2 / 3 - t) * 6 : r) * _255 + .5 | 0
}, splitColor = function(t, r, a) {
  var o = t ? _isNumber$1(t) ? [t >> 16, t >> 8 & _255, t & _255] : 0 : _colorLookup.black, l, f, d, g, _, v, S, b, P, x;
  if (!o) {
      if (t.substr(-1) === "," && (t = t.substr(0, t.length - 1)),
      _colorLookup[t])
          o = _colorLookup[t];
      else if (t.charAt(0) === "#") {
          if (t.length < 6 && (l = t.charAt(1),
          f = t.charAt(2),
          d = t.charAt(3),
          t = "#" + l + l + f + f + d + d + (t.length === 5 ? t.charAt(4) + t.charAt(4) : "")),
          t.length === 9)
              return o = parseInt(t.substr(1, 6), 16),
              [o >> 16, o >> 8 & _255, o & _255, parseInt(t.substr(7), 16) / 255];
          t = parseInt(t.substr(1), 16),
          o = [t >> 16, t >> 8 & _255, t & _255]
      } else if (t.substr(0, 3) === "hsl") {
          if (o = x = t.match(_strictNumExp),
          !r)
              g = +o[0] % 360 / 360,
              _ = +o[1] / 100,
              v = +o[2] / 100,
              f = v <= .5 ? v * (_ + 1) : v + _ - v * _,
              l = v * 2 - f,
              o.length > 3 && (o[3] *= 1),
              o[0] = _hue(g + 1 / 3, l, f),
              o[1] = _hue(g, l, f),
              o[2] = _hue(g - 1 / 3, l, f);
          else if (~t.indexOf("="))
              return o = t.match(_numExp),
              a && o.length < 4 && (o[3] = 1),
              o
      } else
          o = t.match(_strictNumExp) || _colorLookup.transparent;
      o = o.map(Number)
  }
  return r && !x && (l = o[0] / _255,
  f = o[1] / _255,
  d = o[2] / _255,
  S = Math.max(l, f, d),
  b = Math.min(l, f, d),
  v = (S + b) / 2,
  S === b ? g = _ = 0 : (P = S - b,
  _ = v > .5 ? P / (2 - S - b) : P / (S + b),
  g = S === l ? (f - d) / P + (f < d ? 6 : 0) : S === f ? (d - l) / P + 2 : (l - f) / P + 4,
  g *= 60),
  o[0] = ~~(g + .5),
  o[1] = ~~(_ * 100 + .5),
  o[2] = ~~(v * 100 + .5)),
  a && o.length < 4 && (o[3] = 1),
  o
}, _colorOrderData = function(t) {
  var r = []
    , a = []
    , o = -1;
  return t.split(_colorExp).forEach(function(l) {
      var f = l.match(_numWithUnitExp) || [];
      r.push.apply(r, f),
      a.push(o += f.length + 1)
  }),
  r.c = a,
  r
}, _formatColors = function(t, r, a) {
  var o = "", l = (t + o).match(_colorExp), f = r ? "hsla(" : "rgba(", d = 0, g, _, v, S;
  if (!l)
      return t;
  if (l = l.map(function(b) {
      return (b = splitColor(b, r, 1)) && f + (r ? b[0] + "," + b[1] + "%," + b[2] + "%," + b[3] : b.join(",")) + ")"
  }),
  a && (v = _colorOrderData(t),
  g = a.c,
  g.join(o) !== v.c.join(o)))
      for (_ = t.replace(_colorExp, "1").split(_numWithUnitExp),
      S = _.length - 1; d < S; d++)
          o += _[d] + (~g.indexOf(d) ? l.shift() || f + "0,0,0,0)" : (v.length ? v : l.length ? l : a).shift());
  if (!_)
      for (_ = t.split(_colorExp),
      S = _.length - 1; d < S; d++)
          o += _[d] + l[d];
  return o + _[S]
}, _colorExp = function() {
  var e = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", t;
  for (t in _colorLookup)
      e += "|" + t + "\\b";
  return new RegExp(e + ")","gi")
}(), _hslExp = /hsl[a]?\(/, _colorStringFilter = function(t) {
  var r = t.join(" "), a;
  if (_colorExp.lastIndex = 0,
  _colorExp.test(r))
      return a = _hslExp.test(r),
      t[1] = _formatColors(t[1], a),
      t[0] = _formatColors(t[0], a, _colorOrderData(t[1])),
      !0
}, _tickerActive, _ticker = function() {
  var e = Date.now, t = 500, r = 33, a = e(), o = a, l = 1e3 / 240, f = l, d = [], g, _, v, S, b, P, x = function E(I) {
      var C = e() - o, A = I === !0, T, w, M, F;
      if (C > t && (a += C - r),
      o += C,
      M = o - a,
      T = M - f,
      (T > 0 || A) && (F = ++S.frame,
      b = M - S.time * 1e3,
      S.time = M = M / 1e3,
      f += T + (T >= l ? 4 : l - T),
      w = 1),
      A || (g = _(E)),
      w)
          for (P = 0; P < d.length; P++)
              d[P](M, b, F, I)
  };
  return S = {
      time: 0,
      frame: 0,
      tick: function() {
          x(!0)
      },
      deltaRatio: function(I) {
          return b / (1e3 / (I || 60))
      },
      wake: function() {
          _coreReady && (!_coreInitted$2 && _windowExists$2() && (_win$3 = _coreInitted$2 = window,
          _doc$3 = _win$3.document || {},
          _globals.gsap = gsap$2,
          (_win$3.gsapVersions || (_win$3.gsapVersions = [])).push(gsap$2.version),
          _install(_installScope || _win$3.GreenSockGlobals || !_win$3.gsap && _win$3 || {}),
          v = _win$3.requestAnimationFrame,
          _registerPluginQueue.forEach(_createPlugin)),
          g && S.sleep(),
          _ = v || function(I) {
              return setTimeout(I, f - S.time * 1e3 + 1 | 0)
          }
          ,
          _tickerActive = 1,
          x(2))
      },
      sleep: function() {
          (v ? _win$3.cancelAnimationFrame : clearTimeout)(g),
          _tickerActive = 0,
          _ = _emptyFunc
      },
      lagSmoothing: function(I, C) {
          t = I || 1 / 0,
          r = Math.min(C || 33, t)
      },
      fps: function(I) {
          l = 1e3 / (I || 240),
          f = S.time * 1e3 + l
      },
      add: function(I, C, A) {
          var T = C ? function(w, M, F, O) {
              I(w, M, F, O),
              S.remove(T)
          }
          : I;
          return S.remove(I),
          d[A ? "unshift" : "push"](T),
          _wake(),
          T
      },
      remove: function(I, C) {
          ~(C = d.indexOf(I)) && d.splice(C, 1) && P >= C && P--
      },
      _listeners: d
  },
  S
}(), _wake = function() {
  return !_tickerActive && _ticker.wake()
}, _easeMap = {}, _customEaseExp = /^[\d.\-M][\d.\-,\s]/, _quotesExp = /["']/g, _parseObjectInString = function(t) {
  for (var r = {}, a = t.substr(1, t.length - 3).split(":"), o = a[0], l = 1, f = a.length, d, g, _; l < f; l++)
      g = a[l],
      d = l !== f - 1 ? g.lastIndexOf(",") : g.length,
      _ = g.substr(0, d),
      r[o] = isNaN(_) ? _.replace(_quotesExp, "").trim() : +_,
      o = g.substr(d + 1).trim();
  return r
}, _valueInParentheses = function(t) {
  var r = t.indexOf("(") + 1
    , a = t.indexOf(")")
    , o = t.indexOf("(", r);
  return t.substring(r, ~o && o < a ? t.indexOf(")", a + 1) : a)
}, _configEaseFromString = function(t) {
  var r = (t + "").split("(")
    , a = _easeMap[r[0]];
  return a && r.length > 1 && a.config ? a.config.apply(null, ~t.indexOf("{") ? [_parseObjectInString(r[1])] : _valueInParentheses(t).split(",").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(t) ? _easeMap._CE("", t) : a
}, _invertEase = function(t) {
  return function(r) {
      return 1 - t(1 - r)
  }
}, _propagateYoyoEase = function e(t, r) {
  for (var a = t._first, o; a; )
      a instanceof Timeline ? e(a, r) : a.vars.yoyoEase && (!a._yoyo || !a._repeat) && a._yoyo !== r && (a.timeline ? e(a.timeline, r) : (o = a._ease,
      a._ease = a._yEase,
      a._yEase = o,
      a._yoyo = r)),
      a = a._next
}, _parseEase = function(t, r) {
  return t && (_isFunction$1(t) ? t : _easeMap[t] || _configEaseFromString(t)) || r
}, _insertEase = function(t, r, a, o) {
  a === void 0 && (a = function(g) {
      return 1 - r(1 - g)
  }
  ),
  o === void 0 && (o = function(g) {
      return g < .5 ? r(g * 2) / 2 : 1 - r((1 - g) * 2) / 2
  }
  );
  var l = {
      easeIn: r,
      easeOut: a,
      easeInOut: o
  }, f;
  return _forEachName(t, function(d) {
      _easeMap[d] = _globals[d] = l,
      _easeMap[f = d.toLowerCase()] = a;
      for (var g in l)
          _easeMap[f + (g === "easeIn" ? ".in" : g === "easeOut" ? ".out" : ".inOut")] = _easeMap[d + "." + g] = l[g]
  }),
  l
}, _easeInOutFromOut = function(t) {
  return function(r) {
      return r < .5 ? (1 - t(1 - r * 2)) / 2 : .5 + t((r - .5) * 2) / 2
  }
}, _configElastic = function e(t, r, a) {
  var o = r >= 1 ? r : 1
    , l = (a || (t ? .3 : .45)) / (r < 1 ? r : 1)
    , f = l / _2PI * (Math.asin(1 / o) || 0)
    , d = function(v) {
      return v === 1 ? 1 : o * Math.pow(2, -10 * v) * _sin((v - f) * l) + 1
  }
    , g = t === "out" ? d : t === "in" ? function(_) {
      return 1 - d(1 - _)
  }
  : _easeInOutFromOut(d);
  return l = _2PI / l,
  g.config = function(_, v) {
      return e(t, _, v)
  }
  ,
  g
}, _configBack = function e(t, r) {
  r === void 0 && (r = 1.70158);
  var a = function(f) {
      return f ? --f * f * ((r + 1) * f + r) + 1 : 0
  }
    , o = t === "out" ? a : t === "in" ? function(l) {
      return 1 - a(1 - l)
  }
  : _easeInOutFromOut(a);
  return o.config = function(l) {
      return e(t, l)
  }
  ,
  o
};
_forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", function(e, t) {
  var r = t < 5 ? t + 1 : t;
  _insertEase(e + ",Power" + (r - 1), t ? function(a) {
      return Math.pow(a, r)
  }
  : function(a) {
      return a
  }
  , function(a) {
      return 1 - Math.pow(1 - a, r)
  }, function(a) {
      return a < .5 ? Math.pow(a * 2, r) / 2 : 1 - Math.pow((1 - a) * 2, r) / 2
  })
});
_easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;
_insertEase("Elastic", _configElastic("in"), _configElastic("out"), _configElastic());
(function(e, t) {
  var r = 1 / t
    , a = 2 * r
    , o = 2.5 * r
    , l = function(d) {
      return d < r ? e * d * d : d < a ? e * Math.pow(d - 1.5 / t, 2) + .75 : d < o ? e * (d -= 2.25 / t) * d + .9375 : e * Math.pow(d - 2.625 / t, 2) + .984375
  };
  _insertEase("Bounce", function(f) {
      return 1 - l(1 - f)
  }, l)
}
)(7.5625, 2.75);
_insertEase("Expo", function(e) {
  return e ? Math.pow(2, 10 * (e - 1)) : 0
});
_insertEase("Circ", function(e) {
  return -(_sqrt(1 - e * e) - 1)
});
_insertEase("Sine", function(e) {
  return e === 1 ? 1 : -_cos(e * _HALF_PI) + 1
});
_insertEase("Back", _configBack("in"), _configBack("out"), _configBack());
_easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {
  config: function(t, r) {
      t === void 0 && (t = 1);
      var a = 1 / t
        , o = t + (r ? 0 : 1)
        , l = r ? 1 : 0
        , f = 1 - _tinyNum;
      return function(d) {
          return ((o * _clamp$1(0, f, d) | 0) + l) * a
      }
  }
};
_defaults$1.ease = _easeMap["quad.out"];
_forEachName("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(e) {
  return _callbackNames += e + "," + e + "Params,"
});
var GSCache = function(t, r) {
  this.id = _gsID++,
  t._gsap = this,
  this.target = t,
  this.harness = r,
  this.get = r ? r.get : _getProperty,
  this.set = r ? r.getSetter : _getSetter
}
, Animation = function() {
  function e(r) {
      this.vars = r,
      this._delay = +r.delay || 0,
      (this._repeat = r.repeat === 1 / 0 ? -2 : r.repeat || 0) && (this._rDelay = r.repeatDelay || 0,
      this._yoyo = !!r.yoyo || !!r.yoyoEase),
      this._ts = 1,
      _setDuration(this, +r.duration, 1, 1),
      this.data = r.data,
      _context$2 && (this._ctx = _context$2,
      _context$2.data.push(this)),
      _tickerActive || _ticker.wake()
  }
  var t = e.prototype;
  return t.delay = function(a) {
      return a || a === 0 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + a - this._delay),
      this._delay = a,
      this) : this._delay
  }
  ,
  t.duration = function(a) {
      return arguments.length ? this.totalDuration(this._repeat > 0 ? a + (a + this._rDelay) * this._repeat : a) : this.totalDuration() && this._dur
  }
  ,
  t.totalDuration = function(a) {
      return arguments.length ? (this._dirty = 0,
      _setDuration(this, this._repeat < 0 ? a : (a - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
  }
  ,
  t.totalTime = function(a, o) {
      if (_wake(),
      !arguments.length)
          return this._tTime;
      var l = this._dp;
      if (l && l.smoothChildTiming && this._ts) {
          for (_alignPlayhead(this, a),
          !l._dp || l.parent || _postAddChecks(l, this); l && l.parent; )
              l.parent._time !== l._start + (l._ts >= 0 ? l._tTime / l._ts : (l.totalDuration() - l._tTime) / -l._ts) && l.totalTime(l._tTime, !0),
              l = l.parent;
          !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && a < this._tDur || this._ts < 0 && a > 0 || !this._tDur && !a) && _addToTimeline(this._dp, this, this._start - this._delay)
      }
      return (this._tTime !== a || !this._dur && !o || this._initted && Math.abs(this._zTime) === _tinyNum || !a && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = a),
      _lazySafeRender(this, a, o)),
      this
  }
  ,
  t.time = function(a, o) {
      return arguments.length ? this.totalTime(Math.min(this.totalDuration(), a + _elapsedCycleDuration(this)) % (this._dur + this._rDelay) || (a ? this._dur : 0), o) : this._time
  }
  ,
  t.totalProgress = function(a, o) {
      return arguments.length ? this.totalTime(this.totalDuration() * a, o) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio
  }
  ,
  t.progress = function(a, o) {
      return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - a : a) + _elapsedCycleDuration(this), o) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio
  }
  ,
  t.iteration = function(a, o) {
      var l = this.duration() + this._rDelay;
      return arguments.length ? this.totalTime(this._time + (a - 1) * l, o) : this._repeat ? _animationCycle(this._tTime, l) + 1 : 1
  }
  ,
  t.timeScale = function(a) {
      if (!arguments.length)
          return this._rts === -_tinyNum ? 0 : this._rts;
      if (this._rts === a)
          return this;
      var o = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime;
      return this._rts = +a || 0,
      this._ts = this._ps || a === -_tinyNum ? 0 : this._rts,
      this.totalTime(_clamp$1(-Math.abs(this._delay), this._tDur, o), !0),
      _setEnd(this),
      _recacheAncestors(this)
  }
  ,
  t.paused = function(a) {
      return arguments.length ? (this._ps !== a && (this._ps = a,
      a ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()),
      this._ts = this._act = 0) : (_wake(),
      this._ts = this._rts,
      this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _tinyNum && (this._tTime -= _tinyNum)))),
      this) : this._ps
  }
  ,
  t.startTime = function(a) {
      if (arguments.length) {
          this._start = a;
          var o = this.parent || this._dp;
          return o && (o._sort || !this.parent) && _addToTimeline(o, this, a - this._delay),
          this
      }
      return this._start
  }
  ,
  t.endTime = function(a) {
      return this._start + (_isNotFalse(a) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1)
  }
  ,
  t.rawTime = function(a) {
      var o = this.parent || this._dp;
      return o ? a && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? _parentToChildTotalTime(o.rawTime(a), this) : this._tTime : this._tTime
  }
  ,
  t.revert = function(a) {
      a === void 0 && (a = _revertConfig);
      var o = _reverting$1;
      return _reverting$1 = a,
      (this._initted || this._startAt) && (this.timeline && this.timeline.revert(a),
      this.totalTime(-.01, a.suppressEvents)),
      this.data !== "nested" && a.kill !== !1 && this.kill(),
      _reverting$1 = o,
      this
  }
  ,
  t.globalTime = function(a) {
      for (var o = this, l = arguments.length ? a : o.rawTime(); o; )
          l = o._start + l / (o._ts || 1),
          o = o._dp;
      return !this.parent && this._sat ? this._sat.vars.immediateRender ? -1 : this._sat.globalTime(a) : l
  }
  ,
  t.repeat = function(a) {
      return arguments.length ? (this._repeat = a === 1 / 0 ? -2 : a,
      _onUpdateTotalDuration(this)) : this._repeat === -2 ? 1 / 0 : this._repeat
  }
  ,
  t.repeatDelay = function(a) {
      if (arguments.length) {
          var o = this._time;
          return this._rDelay = a,
          _onUpdateTotalDuration(this),
          o ? this.time(o) : this
      }
      return this._rDelay
  }
  ,
  t.yoyo = function(a) {
      return arguments.length ? (this._yoyo = a,
      this) : this._yoyo
  }
  ,
  t.seek = function(a, o) {
      return this.totalTime(_parsePosition$1(this, a), _isNotFalse(o))
  }
  ,
  t.restart = function(a, o) {
      return this.play().totalTime(a ? -this._delay : 0, _isNotFalse(o))
  }
  ,
  t.play = function(a, o) {
      return a != null && this.seek(a, o),
      this.reversed(!1).paused(!1)
  }
  ,
  t.reverse = function(a, o) {
      return a != null && this.seek(a || this.totalDuration(), o),
      this.reversed(!0).paused(!1)
  }
  ,
  t.pause = function(a, o) {
      return a != null && this.seek(a, o),
      this.paused(!0)
  }
  ,
  t.resume = function() {
      return this.paused(!1)
  }
  ,
  t.reversed = function(a) {
      return arguments.length ? (!!a !== this.reversed() && this.timeScale(-this._rts || (a ? -_tinyNum : 0)),
      this) : this._rts < 0
  }
  ,
  t.invalidate = function() {
      return this._initted = this._act = 0,
      this._zTime = -_tinyNum,
      this
  }
  ,
  t.isActive = function() {
      var a = this.parent || this._dp, o = this._start, l;
      return !!(!a || this._ts && this._initted && a.isActive() && (l = a.rawTime(!0)) >= o && l < this.endTime(!0) - _tinyNum)
  }
  ,
  t.eventCallback = function(a, o, l) {
      var f = this.vars;
      return arguments.length > 1 ? (o ? (f[a] = o,
      l && (f[a + "Params"] = l),
      a === "onUpdate" && (this._onUpdate = o)) : delete f[a],
      this) : f[a]
  }
  ,
  t.then = function(a) {
      var o = this;
      return new Promise(function(l) {
          var f = _isFunction$1(a) ? a : _passThrough$1
            , d = function() {
              var _ = o.then;
              o.then = null,
              _isFunction$1(f) && (f = f(o)) && (f.then || f === o) && (o.then = _),
              l(f),
              o.then = _
          };
          o._initted && o.totalProgress() === 1 && o._ts >= 0 || !o._tTime && o._ts < 0 ? d() : o._prom = d
      }
      )
  }
  ,
  t.kill = function() {
      _interrupt(this)
  }
  ,
  e
}();
_setDefaults$1(Animation.prototype, {
  _time: 0,
  _start: 0,
  _end: 0,
  _tTime: 0,
  _tDur: 0,
  _dirty: 0,
  _repeat: 0,
  _yoyo: !1,
  parent: null,
  _initted: !1,
  _rDelay: 0,
  _ts: 1,
  _dp: 0,
  ratio: 0,
  _zTime: -_tinyNum,
  _prom: 0,
  _ps: !1,
  _rts: 1
});
var Timeline = function(e) {
  _inheritsLoose(t, e);
  function t(a, o) {
      var l;
      return a === void 0 && (a = {}),
      l = e.call(this, a) || this,
      l.labels = {},
      l.smoothChildTiming = !!a.smoothChildTiming,
      l.autoRemoveChildren = !!a.autoRemoveChildren,
      l._sort = _isNotFalse(a.sortChildren),
      _globalTimeline && _addToTimeline(a.parent || _globalTimeline, _assertThisInitialized(l), o),
      a.reversed && l.reverse(),
      a.paused && l.paused(!0),
      a.scrollTrigger && _scrollTrigger(_assertThisInitialized(l), a.scrollTrigger),
      l
  }
  var r = t.prototype;
  return r.to = function(o, l, f) {
      return _createTweenType(0, arguments, this),
      this
  }
  ,
  r.from = function(o, l, f) {
      return _createTweenType(1, arguments, this),
      this
  }
  ,
  r.fromTo = function(o, l, f, d) {
      return _createTweenType(2, arguments, this),
      this
  }
  ,
  r.set = function(o, l, f) {
      return l.duration = 0,
      l.parent = this,
      _inheritDefaults(l).repeatDelay || (l.repeat = 0),
      l.immediateRender = !!l.immediateRender,
      new Tween(o,l,_parsePosition$1(this, f),1),
      this
  }
  ,
  r.call = function(o, l, f) {
      return _addToTimeline(this, Tween.delayedCall(0, o, l), f)
  }
  ,
  r.staggerTo = function(o, l, f, d, g, _, v) {
      return f.duration = l,
      f.stagger = f.stagger || d,
      f.onComplete = _,
      f.onCompleteParams = v,
      f.parent = this,
      new Tween(o,f,_parsePosition$1(this, g)),
      this
  }
  ,
  r.staggerFrom = function(o, l, f, d, g, _, v) {
      return f.runBackwards = 1,
      _inheritDefaults(f).immediateRender = _isNotFalse(f.immediateRender),
      this.staggerTo(o, l, f, d, g, _, v)
  }
  ,
  r.staggerFromTo = function(o, l, f, d, g, _, v, S) {
      return d.startAt = f,
      _inheritDefaults(d).immediateRender = _isNotFalse(d.immediateRender),
      this.staggerTo(o, l, d, g, _, v, S)
  }
  ,
  r.render = function(o, l, f) {
      var d = this._time, g = this._dirty ? this.totalDuration() : this._tDur, _ = this._dur, v = o <= 0 ? 0 : _roundPrecise(o), S = this._zTime < 0 != o < 0 && (this._initted || !_), b, P, x, E, I, C, A, T, w, M, F, O;
      if (this !== _globalTimeline && v > g && o >= 0 && (v = g),
      v !== this._tTime || f || S) {
          if (d !== this._time && _ && (v += this._time - d,
          o += this._time - d),
          b = v,
          w = this._start,
          T = this._ts,
          C = !T,
          S && (_ || (d = this._zTime),
          (o || !l) && (this._zTime = o)),
          this._repeat) {
              if (F = this._yoyo,
              I = _ + this._rDelay,
              this._repeat < -1 && o < 0)
                  return this.totalTime(I * 100 + o, l, f);
              if (b = _roundPrecise(v % I),
              v === g ? (E = this._repeat,
              b = _) : (E = ~~(v / I),
              E && E === v / I && (b = _,
              E--),
              b > _ && (b = _)),
              M = _animationCycle(this._tTime, I),
              !d && this._tTime && M !== E && this._tTime - M * I - this._dur <= 0 && (M = E),
              F && E & 1 && (b = _ - b,
              O = 1),
              E !== M && !this._lock) {
                  var $ = F && M & 1
                    , j = $ === (F && E & 1);
                  if (E < M && ($ = !$),
                  d = $ ? 0 : _,
                  this._lock = 1,
                  this.render(d || (O ? 0 : _roundPrecise(E * I)), l, !_)._lock = 0,
                  this._tTime = v,
                  !l && this.parent && _callback$1(this, "onRepeat"),
                  this.vars.repeatRefresh && !O && (this.invalidate()._lock = 1),
                  d && d !== this._time || C !== !this._ts || this.vars.onRepeat && !this.parent && !this._act)
                      return this;
                  if (_ = this._dur,
                  g = this._tDur,
                  j && (this._lock = 2,
                  d = $ ? _ : -1e-4,
                  this.render(d, !0),
                  this.vars.repeatRefresh && !O && this.invalidate()),
                  this._lock = 0,
                  !this._ts && !C)
                      return this;
                  _propagateYoyoEase(this, O)
              }
          }
          if (this._hasPause && !this._forcing && this._lock < 2 && (A = _findNextPauseTween(this, _roundPrecise(d), _roundPrecise(b)),
          A && (v -= b - (b = A._start))),
          this._tTime = v,
          this._time = b,
          this._act = !T,
          this._initted || (this._onUpdate = this.vars.onUpdate,
          this._initted = 1,
          this._zTime = o,
          d = 0),
          !d && b && !l && !E && (_callback$1(this, "onStart"),
          this._tTime !== v))
              return this;
          if (b >= d && o >= 0)
              for (P = this._first; P; ) {
                  if (x = P._next,
                  (P._act || b >= P._start) && P._ts && A !== P) {
                      if (P.parent !== this)
                          return this.render(o, l, f);
                      if (P.render(P._ts > 0 ? (b - P._start) * P._ts : (P._dirty ? P.totalDuration() : P._tDur) + (b - P._start) * P._ts, l, f),
                      b !== this._time || !this._ts && !C) {
                          A = 0,
                          x && (v += this._zTime = -_tinyNum);
                          break
                      }
                  }
                  P = x
              }
          else {
              P = this._last;
              for (var K = o < 0 ? o : b; P; ) {
                  if (x = P._prev,
                  (P._act || K <= P._end) && P._ts && A !== P) {
                      if (P.parent !== this)
                          return this.render(o, l, f);
                      if (P.render(P._ts > 0 ? (K - P._start) * P._ts : (P._dirty ? P.totalDuration() : P._tDur) + (K - P._start) * P._ts, l, f || _reverting$1 && (P._initted || P._startAt)),
                      b !== this._time || !this._ts && !C) {
                          A = 0,
                          x && (v += this._zTime = K ? -_tinyNum : _tinyNum);
                          break
                      }
                  }
                  P = x
              }
          }
          if (A && !l && (this.pause(),
          A.render(b >= d ? 0 : -_tinyNum)._zTime = b >= d ? 1 : -1,
          this._ts))
              return this._start = w,
              _setEnd(this),
              this.render(o, l, f);
          this._onUpdate && !l && _callback$1(this, "onUpdate", !0),
          (v === g && this._tTime >= this.totalDuration() || !v && d) && (w === this._start || Math.abs(T) !== Math.abs(this._ts)) && (this._lock || ((o || !_) && (v === g && this._ts > 0 || !v && this._ts < 0) && _removeFromParent(this, 1),
          !l && !(o < 0 && !d) && (v || d || !g) && (_callback$1(this, v === g && o >= 0 ? "onComplete" : "onReverseComplete", !0),
          this._prom && !(v < g && this.timeScale() > 0) && this._prom())))
      }
      return this
  }
  ,
  r.add = function(o, l) {
      var f = this;
      if (_isNumber$1(l) || (l = _parsePosition$1(this, l, o)),
      !(o instanceof Animation)) {
          if (_isArray(o))
              return o.forEach(function(d) {
                  return f.add(d, l)
              }),
              this;
          if (_isString$1(o))
              return this.addLabel(o, l);
          if (_isFunction$1(o))
              o = Tween.delayedCall(0, o);
          else
              return this
      }
      return this !== o ? _addToTimeline(this, o, l) : this
  }
  ,
  r.getChildren = function(o, l, f, d) {
      o === void 0 && (o = !0),
      l === void 0 && (l = !0),
      f === void 0 && (f = !0),
      d === void 0 && (d = -_bigNum$1);
      for (var g = [], _ = this._first; _; )
          _._start >= d && (_ instanceof Tween ? l && g.push(_) : (f && g.push(_),
          o && g.push.apply(g, _.getChildren(!0, l, f)))),
          _ = _._next;
      return g
  }
  ,
  r.getById = function(o) {
      for (var l = this.getChildren(1, 1, 1), f = l.length; f--; )
          if (l[f].vars.id === o)
              return l[f]
  }
  ,
  r.remove = function(o) {
      return _isString$1(o) ? this.removeLabel(o) : _isFunction$1(o) ? this.killTweensOf(o) : (_removeLinkedListItem(this, o),
      o === this._recent && (this._recent = this._last),
      _uncache(this))
  }
  ,
  r.totalTime = function(o, l) {
      return arguments.length ? (this._forcing = 1,
      !this._dp && this._ts && (this._start = _roundPrecise(_ticker.time - (this._ts > 0 ? o / this._ts : (this.totalDuration() - o) / -this._ts))),
      e.prototype.totalTime.call(this, o, l),
      this._forcing = 0,
      this) : this._tTime
  }
  ,
  r.addLabel = function(o, l) {
      return this.labels[o] = _parsePosition$1(this, l),
      this
  }
  ,
  r.removeLabel = function(o) {
      return delete this.labels[o],
      this
  }
  ,
  r.addPause = function(o, l, f) {
      var d = Tween.delayedCall(0, l || _emptyFunc, f);
      return d.data = "isPause",
      this._hasPause = 1,
      _addToTimeline(this, d, _parsePosition$1(this, o))
  }
  ,
  r.removePause = function(o) {
      var l = this._first;
      for (o = _parsePosition$1(this, o); l; )
          l._start === o && l.data === "isPause" && _removeFromParent(l),
          l = l._next
  }
  ,
  r.killTweensOf = function(o, l, f) {
      for (var d = this.getTweensOf(o, f), g = d.length; g--; )
          _overwritingTween !== d[g] && d[g].kill(o, l);
      return this
  }
  ,
  r.getTweensOf = function(o, l) {
      for (var f = [], d = toArray(o), g = this._first, _ = _isNumber$1(l), v; g; )
          g instanceof Tween ? _arrayContainsAny(g._targets, d) && (_ ? (!_overwritingTween || g._initted && g._ts) && g.globalTime(0) <= l && g.globalTime(g.totalDuration()) > l : !l || g.isActive()) && f.push(g) : (v = g.getTweensOf(d, l)).length && f.push.apply(f, v),
          g = g._next;
      return f
  }
  ,
  r.tweenTo = function(o, l) {
      l = l || {};
      var f = this, d = _parsePosition$1(f, o), g = l, _ = g.startAt, v = g.onStart, S = g.onStartParams, b = g.immediateRender, P, x = Tween.to(f, _setDefaults$1({
          ease: l.ease || "none",
          lazy: !1,
          immediateRender: !1,
          time: d,
          overwrite: "auto",
          duration: l.duration || Math.abs((d - (_ && "time"in _ ? _.time : f._time)) / f.timeScale()) || _tinyNum,
          onStart: function() {
              if (f.pause(),
              !P) {
                  var I = l.duration || Math.abs((d - (_ && "time"in _ ? _.time : f._time)) / f.timeScale());
                  x._dur !== I && _setDuration(x, I, 0, 1).render(x._time, !0, !0),
                  P = 1
              }
              v && v.apply(x, S || [])
          }
      }, l));
      return b ? x.render(0) : x
  }
  ,
  r.tweenFromTo = function(o, l, f) {
      return this.tweenTo(l, _setDefaults$1({
          startAt: {
              time: _parsePosition$1(this, o)
          }
      }, f))
  }
  ,
  r.recent = function() {
      return this._recent
  }
  ,
  r.nextLabel = function(o) {
      return o === void 0 && (o = this._time),
      _getLabelInDirection(this, _parsePosition$1(this, o))
  }
  ,
  r.previousLabel = function(o) {
      return o === void 0 && (o = this._time),
      _getLabelInDirection(this, _parsePosition$1(this, o), 1)
  }
  ,
  r.currentLabel = function(o) {
      return arguments.length ? this.seek(o, !0) : this.previousLabel(this._time + _tinyNum)
  }
  ,
  r.shiftChildren = function(o, l, f) {
      f === void 0 && (f = 0);
      for (var d = this._first, g = this.labels, _; d; )
          d._start >= f && (d._start += o,
          d._end += o),
          d = d._next;
      if (l)
          for (_ in g)
              g[_] >= f && (g[_] += o);
      return _uncache(this)
  }
  ,
  r.invalidate = function(o) {
      var l = this._first;
      for (this._lock = 0; l; )
          l.invalidate(o),
          l = l._next;
      return e.prototype.invalidate.call(this, o)
  }
  ,
  r.clear = function(o) {
      o === void 0 && (o = !0);
      for (var l = this._first, f; l; )
          f = l._next,
          this.remove(l),
          l = f;
      return this._dp && (this._time = this._tTime = this._pTime = 0),
      o && (this.labels = {}),
      _uncache(this)
  }
  ,
  r.totalDuration = function(o) {
      var l = 0, f = this, d = f._last, g = _bigNum$1, _, v, S;
      if (arguments.length)
          return f.timeScale((f._repeat < 0 ? f.duration() : f.totalDuration()) / (f.reversed() ? -o : o));
      if (f._dirty) {
          for (S = f.parent; d; )
              _ = d._prev,
              d._dirty && d.totalDuration(),
              v = d._start,
              v > g && f._sort && d._ts && !f._lock ? (f._lock = 1,
              _addToTimeline(f, d, v - d._delay, 1)._lock = 0) : g = v,
              v < 0 && d._ts && (l -= v,
              (!S && !f._dp || S && S.smoothChildTiming) && (f._start += v / f._ts,
              f._time -= v,
              f._tTime -= v),
              f.shiftChildren(-v, !1, -1 / 0),
              g = 0),
              d._end > l && d._ts && (l = d._end),
              d = _;
          _setDuration(f, f === _globalTimeline && f._time > l ? f._time : l, 1, 1),
          f._dirty = 0
      }
      return f._tDur
  }
  ,
  t.updateRoot = function(o) {
      if (_globalTimeline._ts && (_lazySafeRender(_globalTimeline, _parentToChildTotalTime(o, _globalTimeline)),
      _lastRenderedFrame = _ticker.frame),
      _ticker.frame >= _nextGCFrame) {
          _nextGCFrame += _config.autoSleep || 120;
          var l = _globalTimeline._first;
          if ((!l || !l._ts) && _config.autoSleep && _ticker._listeners.length < 2) {
              for (; l && !l._ts; )
                  l = l._next;
              l || _ticker.sleep()
          }
      }
  }
  ,
  t
}(Animation);
_setDefaults$1(Timeline.prototype, {
  _lock: 0,
  _hasPause: 0,
  _forcing: 0
});
var _addComplexStringPropTween = function(t, r, a, o, l, f, d) {
  var g = new PropTween(this._pt,t,r,0,1,_renderComplexString,null,l), _ = 0, v = 0, S, b, P, x, E, I, C, A;
  for (g.b = a,
  g.e = o,
  a += "",
  o += "",
  (C = ~o.indexOf("random(")) && (o = _replaceRandom(o)),
  f && (A = [a, o],
  f(A, t, r),
  a = A[0],
  o = A[1]),
  b = a.match(_complexStringNumExp) || []; S = _complexStringNumExp.exec(o); )
      x = S[0],
      E = o.substring(_, S.index),
      P ? P = (P + 1) % 5 : E.substr(-5) === "rgba(" && (P = 1),
      x !== b[v++] && (I = parseFloat(b[v - 1]) || 0,
      g._pt = {
          _next: g._pt,
          p: E || v === 1 ? E : ",",
          s: I,
          c: x.charAt(1) === "=" ? _parseRelative(I, x) - I : parseFloat(x) - I,
          m: P && P < 4 ? Math.round : 0
      },
      _ = _complexStringNumExp.lastIndex);
  return g.c = _ < o.length ? o.substring(_, o.length) : "",
  g.fp = d,
  (_relExp.test(o) || C) && (g.e = 0),
  this._pt = g,
  g
}, _addPropTween = function(t, r, a, o, l, f, d, g, _, v) {
  _isFunction$1(o) && (o = o(l || 0, t, f));
  var S = t[r], b = a !== "get" ? a : _isFunction$1(S) ? _ ? t[r.indexOf("set") || !_isFunction$1(t["get" + r.substr(3)]) ? r : "get" + r.substr(3)](_) : t[r]() : S, P = _isFunction$1(S) ? _ ? _setterFuncWithParam : _setterFunc : _setterPlain, x;
  if (_isString$1(o) && (~o.indexOf("random(") && (o = _replaceRandom(o)),
  o.charAt(1) === "=" && (x = _parseRelative(b, o) + (getUnit(b) || 0),
  (x || x === 0) && (o = x))),
  !v || b !== o || _forceAllPropTweens)
      return !isNaN(b * o) && o !== "" ? (x = new PropTween(this._pt,t,r,+b || 0,o - (b || 0),typeof S == "boolean" ? _renderBoolean : _renderPlain,0,P),
      _ && (x.fp = _),
      d && x.modifier(d, this, t),
      this._pt = x) : (!S && !(r in t) && _missingPlugin(r, o),
      _addComplexStringPropTween.call(this, t, r, b, o, P, g || _config.stringFilter, _))
}, _processVars = function(t, r, a, o, l) {
  if (_isFunction$1(t) && (t = _parseFuncOrString(t, l, r, a, o)),
  !_isObject$1(t) || t.style && t.nodeType || _isArray(t) || _isTypedArray(t))
      return _isString$1(t) ? _parseFuncOrString(t, l, r, a, o) : t;
  var f = {}, d;
  for (d in t)
      f[d] = _parseFuncOrString(t[d], l, r, a, o);
  return f
}, _checkPlugin = function(t, r, a, o, l, f) {
  var d, g, _, v;
  if (_plugins[t] && (d = new _plugins[t]).init(l, d.rawVars ? r[t] : _processVars(r[t], o, l, f, a), a, o, f) !== !1 && (a._pt = g = new PropTween(a._pt,l,t,0,1,d.render,d,0,d.priority),
  a !== _quickTween))
      for (_ = a._ptLookup[a._targets.indexOf(l)],
      v = d._props.length; v--; )
          _[d._props[v]] = g;
  return d
}, _overwritingTween, _forceAllPropTweens, _initTween = function e(t, r, a) {
  var o = t.vars, l = o.ease, f = o.startAt, d = o.immediateRender, g = o.lazy, _ = o.onUpdate, v = o.onUpdateParams, S = o.callbackScope, b = o.runBackwards, P = o.yoyoEase, x = o.keyframes, E = o.autoRevert, I = t._dur, C = t._startAt, A = t._targets, T = t.parent, w = T && T.data === "nested" ? T.vars.targets : A, M = t._overwrite === "auto" && !_suppressOverwrites$1, F = t.timeline, O, $, j, K, Y, W, Z, ee, X, D, B, R, L;
  if (F && (!x || !l) && (l = "none"),
  t._ease = _parseEase(l, _defaults$1.ease),
  t._yEase = P ? _invertEase(_parseEase(P === !0 ? l : P, _defaults$1.ease)) : 0,
  P && t._yoyo && !t._repeat && (P = t._yEase,
  t._yEase = t._ease,
  t._ease = P),
  t._from = !F && !!o.runBackwards,
  !F || x && !o.stagger) {
      if (ee = A[0] ? _getCache(A[0]).harness : 0,
      R = ee && o[ee.prop],
      O = _copyExcluding(o, _reservedProps),
      C && (C._zTime < 0 && C.progress(1),
      r < 0 && b && d && !E ? C.render(-1, !0) : C.revert(b && I ? _revertConfigNoKill : _startAtRevertConfig),
      C._lazy = 0),
      f) {
          if (_removeFromParent(t._startAt = Tween.set(A, _setDefaults$1({
              data: "isStart",
              overwrite: !1,
              parent: T,
              immediateRender: !0,
              lazy: !C && _isNotFalse(g),
              startAt: null,
              delay: 0,
              onUpdate: _,
              onUpdateParams: v,
              callbackScope: S,
              stagger: 0
          }, f))),
          t._startAt._dp = 0,
          t._startAt._sat = t,
          r < 0 && (_reverting$1 || !d && !E) && t._startAt.revert(_revertConfigNoKill),
          d && I && r <= 0 && a <= 0) {
              r && (t._zTime = r);
              return
          }
      } else if (b && I && !C) {
          if (r && (d = !1),
          j = _setDefaults$1({
              overwrite: !1,
              data: "isFromStart",
              lazy: d && !C && _isNotFalse(g),
              immediateRender: d,
              stagger: 0,
              parent: T
          }, O),
          R && (j[ee.prop] = R),
          _removeFromParent(t._startAt = Tween.set(A, j)),
          t._startAt._dp = 0,
          t._startAt._sat = t,
          r < 0 && (_reverting$1 ? t._startAt.revert(_revertConfigNoKill) : t._startAt.render(-1, !0)),
          t._zTime = r,
          !d)
              e(t._startAt, _tinyNum, _tinyNum);
          else if (!r)
              return
      }
      for (t._pt = t._ptCache = 0,
      g = I && _isNotFalse(g) || g && !I,
      $ = 0; $ < A.length; $++) {
          if (Y = A[$],
          Z = Y._gsap || _harness(A)[$]._gsap,
          t._ptLookup[$] = D = {},
          _lazyLookup[Z.id] && _lazyTweens.length && _lazyRender(),
          B = w === A ? $ : w.indexOf(Y),
          ee && (X = new ee).init(Y, R || O, t, B, w) !== !1 && (t._pt = K = new PropTween(t._pt,Y,X.name,0,1,X.render,X,0,X.priority),
          X._props.forEach(function(V) {
              D[V] = K
          }),
          X.priority && (W = 1)),
          !ee || R)
              for (j in O)
                  _plugins[j] && (X = _checkPlugin(j, O, t, B, Y, w)) ? X.priority && (W = 1) : D[j] = K = _addPropTween.call(t, Y, j, "get", O[j], B, w, 0, o.stringFilter);
          t._op && t._op[$] && t.kill(Y, t._op[$]),
          M && t._pt && (_overwritingTween = t,
          _globalTimeline.killTweensOf(Y, D, t.globalTime(r)),
          L = !t.parent,
          _overwritingTween = 0),
          t._pt && g && (_lazyLookup[Z.id] = 1)
      }
      W && _sortPropTweensByPriority(t),
      t._onInit && t._onInit(t)
  }
  t._onUpdate = _,
  t._initted = (!t._op || t._pt) && !L,
  x && r <= 0 && F.render(_bigNum$1, !0, !0)
}, _updatePropTweens = function(t, r, a, o, l, f, d) {
  var g = (t._pt && t._ptCache || (t._ptCache = {}))[r], _, v, S, b;
  if (!g)
      for (g = t._ptCache[r] = [],
      S = t._ptLookup,
      b = t._targets.length; b--; ) {
          if (_ = S[b][r],
          _ && _.d && _.d._pt)
              for (_ = _.d._pt; _ && _.p !== r && _.fp !== r; )
                  _ = _._next;
          if (!_)
              return _forceAllPropTweens = 1,
              t.vars[r] = "+=0",
              _initTween(t, d),
              _forceAllPropTweens = 0,
              1;
          g.push(_)
      }
  for (b = g.length; b--; )
      v = g[b],
      _ = v._pt || v,
      _.s = (o || o === 0) && !l ? o : _.s + (o || 0) + f * _.c,
      _.c = a - _.s,
      v.e && (v.e = _round$1(a) + getUnit(v.e)),
      v.b && (v.b = _.s + getUnit(v.b))
}, _addAliasesToVars = function(t, r) {
  var a = t[0] ? _getCache(t[0]).harness : 0, o = a && a.aliases, l, f, d, g;
  if (!o)
      return r;
  l = _merge({}, r);
  for (f in o)
      if (f in l)
          for (g = o[f].split(","),
          d = g.length; d--; )
              l[g[d]] = l[f];
  return l
}, _parseKeyframe = function(t, r, a, o) {
  var l = r.ease || o || "power1.inOut", f, d;
  if (_isArray(r))
      d = a[t] || (a[t] = []),
      r.forEach(function(g, _) {
          return d.push({
              t: _ / (r.length - 1) * 100,
              v: g,
              e: l
          })
      });
  else
      for (f in r)
          d = a[f] || (a[f] = []),
          f === "ease" || d.push({
              t: parseFloat(t),
              v: r[f],
              e: l
          })
}, _parseFuncOrString = function(t, r, a, o, l) {
  return _isFunction$1(t) ? t.call(r, a, o, l) : _isString$1(t) && ~t.indexOf("random(") ? _replaceRandom(t) : t
}, _staggerTweenProps = _callbackNames + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", _staggerPropsToSkip = {};
_forEachName(_staggerTweenProps + ",id,stagger,delay,duration,paused,scrollTrigger", function(e) {
  return _staggerPropsToSkip[e] = 1
});
var Tween = function(e) {
  _inheritsLoose(t, e);
  function t(a, o, l, f) {
      var d;
      typeof o == "number" && (l.duration = o,
      o = l,
      l = null),
      d = e.call(this, f ? o : _inheritDefaults(o)) || this;
      var g = d.vars, _ = g.duration, v = g.delay, S = g.immediateRender, b = g.stagger, P = g.overwrite, x = g.keyframes, E = g.defaults, I = g.scrollTrigger, C = g.yoyoEase, A = o.parent || _globalTimeline, T = (_isArray(a) || _isTypedArray(a) ? _isNumber$1(a[0]) : "length"in o) ? [a] : toArray(a), w, M, F, O, $, j, K, Y;
      if (d._targets = T.length ? _harness(T) : _warn("GSAP target " + a + " not found. https://greensock.com", !_config.nullTargetWarn) || [],
      d._ptLookup = [],
      d._overwrite = P,
      x || b || _isFuncOrString(_) || _isFuncOrString(v)) {
          if (o = d.vars,
          w = d.timeline = new Timeline({
              data: "nested",
              defaults: E || {},
              targets: A && A.data === "nested" ? A.vars.targets : T
          }),
          w.kill(),
          w.parent = w._dp = _assertThisInitialized(d),
          w._start = 0,
          b || _isFuncOrString(_) || _isFuncOrString(v)) {
              if (O = T.length,
              K = b && distribute(b),
              _isObject$1(b))
                  for ($ in b)
                      ~_staggerTweenProps.indexOf($) && (Y || (Y = {}),
                      Y[$] = b[$]);
              for (M = 0; M < O; M++)
                  F = _copyExcluding(o, _staggerPropsToSkip),
                  F.stagger = 0,
                  C && (F.yoyoEase = C),
                  Y && _merge(F, Y),
                  j = T[M],
                  F.duration = +_parseFuncOrString(_, _assertThisInitialized(d), M, j, T),
                  F.delay = (+_parseFuncOrString(v, _assertThisInitialized(d), M, j, T) || 0) - d._delay,
                  !b && O === 1 && F.delay && (d._delay = v = F.delay,
                  d._start += v,
                  F.delay = 0),
                  w.to(j, F, K ? K(M, j, T) : 0),
                  w._ease = _easeMap.none;
              w.duration() ? _ = v = 0 : d.timeline = 0
          } else if (x) {
              _inheritDefaults(_setDefaults$1(w.vars.defaults, {
                  ease: "none"
              })),
              w._ease = _parseEase(x.ease || o.ease || "none");
              var W = 0, Z, ee, X;
              if (_isArray(x))
                  x.forEach(function(D) {
                      return w.to(T, D, ">")
                  }),
                  w.duration();
              else {
                  F = {};
                  for ($ in x)
                      $ === "ease" || $ === "easeEach" || _parseKeyframe($, x[$], F, x.easeEach);
                  for ($ in F)
                      for (Z = F[$].sort(function(D, B) {
                          return D.t - B.t
                      }),
                      W = 0,
                      M = 0; M < Z.length; M++)
                          ee = Z[M],
                          X = {
                              ease: ee.e,
                              duration: (ee.t - (M ? Z[M - 1].t : 0)) / 100 * _
                          },
                          X[$] = ee.v,
                          w.to(T, X, W),
                          W += X.duration;
                  w.duration() < _ && w.to({}, {
                      duration: _ - w.duration()
                  })
              }
          }
          _ || d.duration(_ = w.duration())
      } else
          d.timeline = 0;
      return P === !0 && !_suppressOverwrites$1 && (_overwritingTween = _assertThisInitialized(d),
      _globalTimeline.killTweensOf(T),
      _overwritingTween = 0),
      _addToTimeline(A, _assertThisInitialized(d), l),
      o.reversed && d.reverse(),
      o.paused && d.paused(!0),
      (S || !_ && !x && d._start === _roundPrecise(A._time) && _isNotFalse(S) && _hasNoPausedAncestors(_assertThisInitialized(d)) && A.data !== "nested") && (d._tTime = -_tinyNum,
      d.render(Math.max(0, -v) || 0)),
      I && _scrollTrigger(_assertThisInitialized(d), I),
      d
  }
  var r = t.prototype;
  return r.render = function(o, l, f) {
      var d = this._time, g = this._tDur, _ = this._dur, v = o < 0, S = o > g - _tinyNum && !v ? g : o < _tinyNum ? 0 : o, b, P, x, E, I, C, A, T, w;
      if (!_)
          _renderZeroDurationTween(this, o, l, f);
      else if (S !== this._tTime || !o || f || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== v) {
          if (b = S,
          T = this.timeline,
          this._repeat) {
              if (E = _ + this._rDelay,
              this._repeat < -1 && v)
                  return this.totalTime(E * 100 + o, l, f);
              if (b = _roundPrecise(S % E),
              S === g ? (x = this._repeat,
              b = _) : (x = ~~(S / E),
              x && x === S / E && (b = _,
              x--),
              b > _ && (b = _)),
              C = this._yoyo && x & 1,
              C && (w = this._yEase,
              b = _ - b),
              I = _animationCycle(this._tTime, E),
              b === d && !f && this._initted)
                  return this._tTime = S,
                  this;
              x !== I && (T && this._yEase && _propagateYoyoEase(T, C),
              this.vars.repeatRefresh && !C && !this._lock && (this._lock = f = 1,
              this.render(_roundPrecise(E * x), !0).invalidate()._lock = 0))
          }
          if (!this._initted) {
              if (_attemptInitTween(this, v ? o : b, f, l, S))
                  return this._tTime = 0,
                  this;
              if (d !== this._time)
                  return this;
              if (_ !== this._dur)
                  return this.render(o, l, f)
          }
          if (this._tTime = S,
          this._time = b,
          !this._act && this._ts && (this._act = 1,
          this._lazy = 0),
          this.ratio = A = (w || this._ease)(b / _),
          this._from && (this.ratio = A = 1 - A),
          b && !d && !l && !x && (_callback$1(this, "onStart"),
          this._tTime !== S))
              return this;
          for (P = this._pt; P; )
              P.r(A, P.d),
              P = P._next;
          T && T.render(o < 0 ? o : !b && C ? -_tinyNum : T._dur * T._ease(b / this._dur), l, f) || this._startAt && (this._zTime = o),
          this._onUpdate && !l && (v && _rewindStartAt(this, o, l, f),
          _callback$1(this, "onUpdate")),
          this._repeat && x !== I && this.vars.onRepeat && !l && this.parent && _callback$1(this, "onRepeat"),
          (S === this._tDur || !S) && this._tTime === S && (v && !this._onUpdate && _rewindStartAt(this, o, !0, !0),
          (o || !_) && (S === this._tDur && this._ts > 0 || !S && this._ts < 0) && _removeFromParent(this, 1),
          !l && !(v && !d) && (S || d || C) && (_callback$1(this, S === g ? "onComplete" : "onReverseComplete", !0),
          this._prom && !(S < g && this.timeScale() > 0) && this._prom()))
      }
      return this
  }
  ,
  r.targets = function() {
      return this._targets
  }
  ,
  r.invalidate = function(o) {
      return (!o || !this.vars.runBackwards) && (this._startAt = 0),
      this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0,
      this._ptLookup = [],
      this.timeline && this.timeline.invalidate(o),
      e.prototype.invalidate.call(this, o)
  }
  ,
  r.resetTo = function(o, l, f, d) {
      _tickerActive || _ticker.wake(),
      this._ts || this.play();
      var g = Math.min(this._dur, (this._dp._time - this._start) * this._ts), _;
      return this._initted || _initTween(this, g),
      _ = this._ease(g / this._dur),
      _updatePropTweens(this, o, l, f, d, _, g) ? this.resetTo(o, l, f, d) : (_alignPlayhead(this, 0),
      this.parent || _addLinkedListItem(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0),
      this.render(0))
  }
  ,
  r.kill = function(o, l) {
      if (l === void 0 && (l = "all"),
      !o && (!l || l === "all"))
          return this._lazy = this._pt = 0,
          this.parent ? _interrupt(this) : this;
      if (this.timeline) {
          var f = this.timeline.totalDuration();
          return this.timeline.killTweensOf(o, l, _overwritingTween && _overwritingTween.vars.overwrite !== !0)._first || _interrupt(this),
          this.parent && f !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / f, 0, 1),
          this
      }
      var d = this._targets, g = o ? toArray(o) : d, _ = this._ptLookup, v = this._pt, S, b, P, x, E, I, C;
      if ((!l || l === "all") && _arraysMatch(d, g))
          return l === "all" && (this._pt = 0),
          _interrupt(this);
      for (S = this._op = this._op || [],
      l !== "all" && (_isString$1(l) && (E = {},
      _forEachName(l, function(A) {
          return E[A] = 1
      }),
      l = E),
      l = _addAliasesToVars(d, l)),
      C = d.length; C--; )
          if (~g.indexOf(d[C])) {
              b = _[C],
              l === "all" ? (S[C] = l,
              x = b,
              P = {}) : (P = S[C] = S[C] || {},
              x = l);
              for (E in x)
                  I = b && b[E],
                  I && ((!("kill"in I.d) || I.d.kill(E) === !0) && _removeLinkedListItem(this, I, "_pt"),
                  delete b[E]),
                  P !== "all" && (P[E] = 1)
          }
      return this._initted && !this._pt && v && _interrupt(this),
      this
  }
  ,
  t.to = function(o, l) {
      return new t(o,l,arguments[2])
  }
  ,
  t.from = function(o, l) {
      return _createTweenType(1, arguments)
  }
  ,
  t.delayedCall = function(o, l, f, d) {
      return new t(l,0,{
          immediateRender: !1,
          lazy: !1,
          overwrite: !1,
          delay: o,
          onComplete: l,
          onReverseComplete: l,
          onCompleteParams: f,
          onReverseCompleteParams: f,
          callbackScope: d
      })
  }
  ,
  t.fromTo = function(o, l, f) {
      return _createTweenType(2, arguments)
  }
  ,
  t.set = function(o, l) {
      return l.duration = 0,
      l.repeatDelay || (l.repeat = 0),
      new t(o,l)
  }
  ,
  t.killTweensOf = function(o, l, f) {
      return _globalTimeline.killTweensOf(o, l, f)
  }
  ,
  t
}(Animation);
_setDefaults$1(Tween.prototype, {
  _targets: [],
  _lazy: 0,
  _startAt: 0,
  _op: 0,
  _onInit: 0
});
_forEachName("staggerTo,staggerFrom,staggerFromTo", function(e) {
  Tween[e] = function() {
      var t = new Timeline
        , r = _slice.call(arguments, 0);
      return r.splice(e === "staggerFromTo" ? 5 : 4, 0, 0),
      t[e].apply(t, r)
  }
});
var _setterPlain = function(t, r, a) {
  return t[r] = a
}
, _setterFunc = function(t, r, a) {
  return t[r](a)
}
, _setterFuncWithParam = function(t, r, a, o) {
  return t[r](o.fp, a)
}
, _setterAttribute = function(t, r, a) {
  return t.setAttribute(r, a)
}
, _getSetter = function(t, r) {
  return _isFunction$1(t[r]) ? _setterFunc : _isUndefined(t[r]) && t.setAttribute ? _setterAttribute : _setterPlain
}
, _renderPlain = function(t, r) {
  return r.set(r.t, r.p, Math.round((r.s + r.c * t) * 1e6) / 1e6, r)
}
, _renderBoolean = function(t, r) {
  return r.set(r.t, r.p, !!(r.s + r.c * t), r)
}
, _renderComplexString = function(t, r) {
  var a = r._pt
    , o = "";
  if (!t && r.b)
      o = r.b;
  else if (t === 1 && r.e)
      o = r.e;
  else {
      for (; a; )
          o = a.p + (a.m ? a.m(a.s + a.c * t) : Math.round((a.s + a.c * t) * 1e4) / 1e4) + o,
          a = a._next;
      o += r.c
  }
  r.set(r.t, r.p, o, r)
}
, _renderPropTweens = function(t, r) {
  for (var a = r._pt; a; )
      a.r(t, a.d),
      a = a._next
}
, _addPluginModifier = function(t, r, a, o) {
  for (var l = this._pt, f; l; )
      f = l._next,
      l.p === o && l.modifier(t, r, a),
      l = f
}
, _killPropTweensOf = function(t) {
  for (var r = this._pt, a, o; r; )
      o = r._next,
      r.p === t && !r.op || r.op === t ? _removeLinkedListItem(this, r, "_pt") : r.dep || (a = 1),
      r = o;
  return !a
}
, _setterWithModifier = function(t, r, a, o) {
  o.mSet(t, r, o.m.call(o.tween, a, o.mt), o)
}
, _sortPropTweensByPriority = function(t) {
  for (var r = t._pt, a, o, l, f; r; ) {
      for (a = r._next,
      o = l; o && o.pr > r.pr; )
          o = o._next;
      (r._prev = o ? o._prev : f) ? r._prev._next = r : l = r,
      (r._next = o) ? o._prev = r : f = r,
      r = a
  }
  t._pt = l
}
, PropTween = function() {
  function e(r, a, o, l, f, d, g, _, v) {
      this.t = a,
      this.s = l,
      this.c = f,
      this.p = o,
      this.r = d || _renderPlain,
      this.d = g || this,
      this.set = _ || _setterPlain,
      this.pr = v || 0,
      this._next = r,
      r && (r._prev = this)
  }
  var t = e.prototype;
  return t.modifier = function(a, o, l) {
      this.mSet = this.mSet || this.set,
      this.set = _setterWithModifier,
      this.m = a,
      this.mt = l,
      this.tween = o
  }
  ,
  e
}();
_forEachName(_callbackNames + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(e) {
  return _reservedProps[e] = 1
});
_globals.TweenMax = _globals.TweenLite = Tween;
_globals.TimelineLite = _globals.TimelineMax = Timeline;
_globalTimeline = new Timeline({
  sortChildren: !1,
  defaults: _defaults$1,
  autoRemoveChildren: !0,
  id: "root",
  smoothChildTiming: !0
});
_config.stringFilter = _colorStringFilter;
var _media = []
, _listeners$1 = {}
, _emptyArray$1 = []
, _lastMediaTime = 0
, _dispatch$1 = function(t) {
  return (_listeners$1[t] || _emptyArray$1).map(function(r) {
      return r()
  })
}
, _onMediaChange = function() {
  var t = Date.now()
    , r = [];
  t - _lastMediaTime > 2 && (_dispatch$1("matchMediaInit"),
  _media.forEach(function(a) {
      var o = a.queries, l = a.conditions, f, d, g, _;
      for (d in o)
          f = _win$3.matchMedia(o[d]).matches,
          f && (g = 1),
          f !== l[d] && (l[d] = f,
          _ = 1);
      _ && (a.revert(),
      g && r.push(a))
  }),
  _dispatch$1("matchMediaRevert"),
  r.forEach(function(a) {
      return a.onMatch(a)
  }),
  _lastMediaTime = t,
  _dispatch$1("matchMedia"))
}
, Context = function() {
  function e(r, a) {
      this.selector = a && selector(a),
      this.data = [],
      this._r = [],
      this.isReverted = !1,
      r && this.add(r)
  }
  var t = e.prototype;
  return t.add = function(a, o, l) {
      _isFunction$1(a) && (l = o,
      o = a,
      a = _isFunction$1);
      var f = this
        , d = function() {
          var _ = _context$2, v = f.selector, S;
          return _ && _ !== f && _.data.push(f),
          l && (f.selector = selector(l)),
          _context$2 = f,
          S = o.apply(f, arguments),
          _isFunction$1(S) && f._r.push(S),
          _context$2 = _,
          f.selector = v,
          f.isReverted = !1,
          S
      };
      return f.last = d,
      a === _isFunction$1 ? d(f) : a ? f[a] = d : d
  }
  ,
  t.ignore = function(a) {
      var o = _context$2;
      _context$2 = null,
      a(this),
      _context$2 = o
  }
  ,
  t.getTweens = function() {
      var a = [];
      return this.data.forEach(function(o) {
          return o instanceof e ? a.push.apply(a, o.getTweens()) : o instanceof Tween && !(o.parent && o.parent.data === "nested") && a.push(o)
      }),
      a
  }
  ,
  t.clear = function() {
      this._r.length = this.data.length = 0
  }
  ,
  t.kill = function(a, o) {
      var l = this;
      if (a) {
          var f = this.getTweens();
          this.data.forEach(function(g) {
              g.data === "isFlip" && (g.revert(),
              g.getChildren(!0, !0, !1).forEach(function(_) {
                  return f.splice(f.indexOf(_), 1)
              }))
          }),
          f.map(function(g) {
              return {
                  g: g.globalTime(0),
                  t: g
              }
          }).sort(function(g, _) {
              return _.g - g.g || -1
          }).forEach(function(g) {
              return g.t.revert(a)
          }),
          this.data.forEach(function(g) {
              return !(g instanceof Animation) && g.revert && g.revert(a)
          }),
          this._r.forEach(function(g) {
              return g(a, l)
          }),
          this.isReverted = !0
      } else
          this.data.forEach(function(g) {
              return g.kill && g.kill()
          });
      if (this.clear(),
      o) {
          var d = _media.indexOf(this);
          ~d && _media.splice(d, 1)
      }
  }
  ,
  t.revert = function(a) {
      this.kill(a || {})
  }
  ,
  e
}()
, MatchMedia = function() {
  function e(r) {
      this.contexts = [],
      this.scope = r
  }
  var t = e.prototype;
  return t.add = function(a, o, l) {
      _isObject$1(a) || (a = {
          matches: a
      });
      var f = new Context(0,l || this.scope), d = f.conditions = {}, g, _, v;
      this.contexts.push(f),
      o = f.add("onMatch", o),
      f.queries = a;
      for (_ in a)
          _ === "all" ? v = 1 : (g = _win$3.matchMedia(a[_]),
          g && (_media.indexOf(f) < 0 && _media.push(f),
          (d[_] = g.matches) && (v = 1),
          g.addListener ? g.addListener(_onMediaChange) : g.addEventListener("change", _onMediaChange)));
      return v && o(f),
      this
  }
  ,
  t.revert = function(a) {
      this.kill(a || {})
  }
  ,
  t.kill = function(a) {
      this.contexts.forEach(function(o) {
          return o.kill(a, !0)
      })
  }
  ,
  e
}()
, _gsap = {
  registerPlugin: function() {
      for (var t = arguments.length, r = new Array(t), a = 0; a < t; a++)
          r[a] = arguments[a];
      r.forEach(function(o) {
          return _createPlugin(o)
      })
  },
  timeline: function(t) {
      return new Timeline(t)
  },
  getTweensOf: function(t, r) {
      return _globalTimeline.getTweensOf(t, r)
  },
  getProperty: function(t, r, a, o) {
      _isString$1(t) && (t = toArray(t)[0]);
      var l = _getCache(t || {}).get
        , f = a ? _passThrough$1 : _numericIfPossible;
      return a === "native" && (a = ""),
      t && (r ? f((_plugins[r] && _plugins[r].get || l)(t, r, a, o)) : function(d, g, _) {
          return f((_plugins[d] && _plugins[d].get || l)(t, d, g, _))
      }
      )
  },
  quickSetter: function(t, r, a) {
      if (t = toArray(t),
      t.length > 1) {
          var o = t.map(function(v) {
              return gsap$2.quickSetter(v, r, a)
          })
            , l = o.length;
          return function(v) {
              for (var S = l; S--; )
                  o[S](v)
          }
      }
      t = t[0] || {};
      var f = _plugins[r]
        , d = _getCache(t)
        , g = d.harness && (d.harness.aliases || {})[r] || r
        , _ = f ? function(v) {
          var S = new f;
          _quickTween._pt = 0,
          S.init(t, a ? v + a : v, _quickTween, 0, [t]),
          S.render(1, S),
          _quickTween._pt && _renderPropTweens(1, _quickTween)
      }
      : d.set(t, g);
      return f ? _ : function(v) {
          return _(t, g, a ? v + a : v, d, 1)
      }
  },
  quickTo: function(t, r, a) {
      var o, l = gsap$2.to(t, _merge((o = {},
      o[r] = "+=0.1",
      o.paused = !0,
      o), a || {})), f = function(g, _, v) {
          return l.resetTo(r, g, _, v)
      };
      return f.tween = l,
      f
  },
  isTweening: function(t) {
      return _globalTimeline.getTweensOf(t, !0).length > 0
  },
  defaults: function(t) {
      return t && t.ease && (t.ease = _parseEase(t.ease, _defaults$1.ease)),
      _mergeDeep(_defaults$1, t || {})
  },
  config: function(t) {
      return _mergeDeep(_config, t || {})
  },
  registerEffect: function(t) {
      var r = t.name
        , a = t.effect
        , o = t.plugins
        , l = t.defaults
        , f = t.extendTimeline;
      (o || "").split(",").forEach(function(d) {
          return d && !_plugins[d] && !_globals[d] && _warn(r + " effect requires " + d + " plugin.")
      }),
      _effects[r] = function(d, g, _) {
          return a(toArray(d), _setDefaults$1(g || {}, l), _)
      }
      ,
      f && (Timeline.prototype[r] = function(d, g, _) {
          return this.add(_effects[r](d, _isObject$1(g) ? g : (_ = g) && {}, this), _)
      }
      )
  },
  registerEase: function(t, r) {
      _easeMap[t] = _parseEase(r)
  },
  parseEase: function(t, r) {
      return arguments.length ? _parseEase(t, r) : _easeMap
  },
  getById: function(t) {
      return _globalTimeline.getById(t)
  },
  exportRoot: function(t, r) {
      t === void 0 && (t = {});
      var a = new Timeline(t), o, l;
      for (a.smoothChildTiming = _isNotFalse(t.smoothChildTiming),
      _globalTimeline.remove(a),
      a._dp = 0,
      a._time = a._tTime = _globalTimeline._time,
      o = _globalTimeline._first; o; )
          l = o._next,
          (r || !(!o._dur && o instanceof Tween && o.vars.onComplete === o._targets[0])) && _addToTimeline(a, o, o._start - o._delay),
          o = l;
      return _addToTimeline(_globalTimeline, a, 0),
      a
  },
  context: function(t, r) {
      return t ? new Context(t,r) : _context$2
  },
  matchMedia: function(t) {
      return new MatchMedia(t)
  },
  matchMediaRefresh: function() {
      return _media.forEach(function(t) {
          var r = t.conditions, a, o;
          for (o in r)
              r[o] && (r[o] = !1,
              a = 1);
          a && t.revert()
      }) || _onMediaChange()
  },
  addEventListener: function(t, r) {
      var a = _listeners$1[t] || (_listeners$1[t] = []);
      ~a.indexOf(r) || a.push(r)
  },
  removeEventListener: function(t, r) {
      var a = _listeners$1[t]
        , o = a && a.indexOf(r);
      o >= 0 && a.splice(o, 1)
  },
  utils: {
      wrap,
      wrapYoyo,
      distribute,
      random,
      snap,
      normalize,
      getUnit,
      clamp,
      splitColor,
      toArray,
      selector,
      mapRange,
      pipe,
      unitize,
      interpolate,
      shuffle
  },
  install: _install,
  effects: _effects,
  ticker: _ticker,
  updateRoot: Timeline.updateRoot,
  plugins: _plugins,
  globalTimeline: _globalTimeline,
  core: {
      PropTween,
      globals: _addGlobal,
      Tween,
      Timeline,
      Animation,
      getCache: _getCache,
      _removeLinkedListItem,
      reverting: function() {
          return _reverting$1
      },
      context: function(t) {
          return t && _context$2 && (_context$2.data.push(t),
          t._ctx = _context$2),
          _context$2
      },
      suppressOverwrites: function(t) {
          return _suppressOverwrites$1 = t
      }
  }
};
_forEachName("to,from,fromTo,delayedCall,set,killTweensOf", function(e) {
  return _gsap[e] = Tween[e]
});
_ticker.add(Timeline.updateRoot);
_quickTween = _gsap.to({}, {
  duration: 0
});
var _getPluginPropTween = function(t, r) {
  for (var a = t._pt; a && a.p !== r && a.op !== r && a.fp !== r; )
      a = a._next;
  return a
}
, _addModifiers = function(t, r) {
  var a = t._targets, o, l, f;
  for (o in r)
      for (l = a.length; l--; )
          f = t._ptLookup[l][o],
          f && (f = f.d) && (f._pt && (f = _getPluginPropTween(f, o)),
          f && f.modifier && f.modifier(r[o], t, a[l], o))
}
, _buildModifierPlugin = function(t, r) {
  return {
      name: t,
      rawVars: 1,
      init: function(o, l, f) {
          f._onInit = function(d) {
              var g, _;
              if (_isString$1(l) && (g = {},
              _forEachName(l, function(v) {
                  return g[v] = 1
              }),
              l = g),
              r) {
                  g = {};
                  for (_ in l)
                      g[_] = r(l[_]);
                  l = g
              }
              _addModifiers(d, l)
          }
      }
  }
}
, gsap$2 = _gsap.registerPlugin({
  name: "attr",
  init: function(t, r, a, o, l) {
      var f, d, g;
      this.tween = a;
      for (f in r)
          g = t.getAttribute(f) || "",
          d = this.add(t, "setAttribute", (g || 0) + "", r[f], o, l, 0, 0, f),
          d.op = f,
          d.b = g,
          this._props.push(f)
  },
  render: function(t, r) {
      for (var a = r._pt; a; )
          _reverting$1 ? a.set(a.t, a.p, a.b, a) : a.r(t, a.d),
          a = a._next
  }
}, {
  name: "endArray",
  init: function(t, r) {
      for (var a = r.length; a--; )
          this.add(t, a, t[a] || 0, r[a], 0, 0, 0, 0, 0, 1)
  }
}, _buildModifierPlugin("roundProps", _roundModifier), _buildModifierPlugin("modifiers"), _buildModifierPlugin("snap", snap)) || _gsap;
Tween.version = Timeline.version = gsap$2.version = "3.11.5";
_coreReady = 1;
_windowExists$2() && _wake();
_easeMap.Power0;
_easeMap.Power1;
_easeMap.Power2;
_easeMap.Power3;
_easeMap.Power4;
_easeMap.Linear;
_easeMap.Quad;
_easeMap.Cubic;
_easeMap.Quart;
_easeMap.Quint;
_easeMap.Strong;
_easeMap.Elastic;
_easeMap.Back;
_easeMap.SteppedEase;
_easeMap.Bounce;
_easeMap.Sine;
_easeMap.Expo;
_easeMap.Circ;
/*!
* CSSPlugin 3.11.5
* https://greensock.com
*
* Copyright 2008-2023, GreenSock. All rights reserved.
* Subject to the terms at https://greensock.com/standard-license or for
* Club GreenSock members, the agreement issued with that membership.
* @author: Jack Doyle, jack@greensock.com
*/
var _win$2, _doc$2, _docElement, _pluginInitted, _tempDiv, _recentSetterPlugin, _reverting, _windowExists$1 = function() {
  return typeof window < "u"
}, _transformProps = {}, _RAD2DEG = 180 / Math.PI, _DEG2RAD = Math.PI / 180, _atan2 = Math.atan2, _bigNum = 1e8, _capsExp$1 = /([A-Z])/g, _horizontalExp = /(left|right|width|margin|padding|x)/i, _complexExp = /[\s,\(]\S/, _propertyAliases = {
  autoAlpha: "opacity,visibility",
  scale: "scaleX,scaleY",
  alpha: "opacity"
}, _renderCSSProp = function(t, r) {
  return r.set(r.t, r.p, Math.round((r.s + r.c * t) * 1e4) / 1e4 + r.u, r)
}, _renderPropWithEnd = function(t, r) {
  return r.set(r.t, r.p, t === 1 ? r.e : Math.round((r.s + r.c * t) * 1e4) / 1e4 + r.u, r)
}, _renderCSSPropWithBeginning = function(t, r) {
  return r.set(r.t, r.p, t ? Math.round((r.s + r.c * t) * 1e4) / 1e4 + r.u : r.b, r)
}, _renderRoundedCSSProp = function(t, r) {
  var a = r.s + r.c * t;
  r.set(r.t, r.p, ~~(a + (a < 0 ? -.5 : .5)) + r.u, r)
}, _renderNonTweeningValue = function(t, r) {
  return r.set(r.t, r.p, t ? r.e : r.b, r)
}, _renderNonTweeningValueOnlyAtEnd = function(t, r) {
  return r.set(r.t, r.p, t !== 1 ? r.b : r.e, r)
}, _setterCSSStyle = function(t, r, a) {
  return t.style[r] = a
}, _setterCSSProp = function(t, r, a) {
  return t.style.setProperty(r, a)
}, _setterTransform = function(t, r, a) {
  return t._gsap[r] = a
}, _setterScale = function(t, r, a) {
  return t._gsap.scaleX = t._gsap.scaleY = a
}, _setterScaleWithRender = function(t, r, a, o, l) {
  var f = t._gsap;
  f.scaleX = f.scaleY = a,
  f.renderTransform(l, f)
}, _setterTransformWithRender = function(t, r, a, o, l) {
  var f = t._gsap;
  f[r] = a,
  f.renderTransform(l, f)
}, _transformProp$1 = "transform", _transformOriginProp = _transformProp$1 + "Origin", _saveStyle = function e(t, r) {
  var a = this
    , o = this.target
    , l = o.style;
  if (t in _transformProps) {
      if (this.tfm = this.tfm || {},
      t !== "transform")
          t = _propertyAliases[t] || t,
          ~t.indexOf(",") ? t.split(",").forEach(function(f) {
              return a.tfm[f] = _get(o, f)
          }) : this.tfm[t] = o._gsap.x ? o._gsap[t] : _get(o, t);
      else
          return _propertyAliases.transform.split(",").forEach(function(f) {
              return e.call(a, f, r)
          });
      if (this.props.indexOf(_transformProp$1) >= 0)
          return;
      o._gsap.svg && (this.svgo = o.getAttribute("data-svg-origin"),
      this.props.push(_transformOriginProp, r, "")),
      t = _transformProp$1
  }
  (l || r) && this.props.push(t, r, l[t])
}, _removeIndependentTransforms = function(t) {
  t.translate && (t.removeProperty("translate"),
  t.removeProperty("scale"),
  t.removeProperty("rotate"))
}, _revertStyle = function() {
  var t = this.props, r = this.target, a = r.style, o = r._gsap, l, f;
  for (l = 0; l < t.length; l += 3)
      t[l + 1] ? r[t[l]] = t[l + 2] : t[l + 2] ? a[t[l]] = t[l + 2] : a.removeProperty(t[l].substr(0, 2) === "--" ? t[l] : t[l].replace(_capsExp$1, "-$1").toLowerCase());
  if (this.tfm) {
      for (f in this.tfm)
          o[f] = this.tfm[f];
      o.svg && (o.renderTransform(),
      r.setAttribute("data-svg-origin", this.svgo || "")),
      l = _reverting(),
      (!l || !l.isStart) && !a[_transformProp$1] && (_removeIndependentTransforms(a),
      o.uncache = 1)
  }
}, _getStyleSaver = function(t, r) {
  var a = {
      target: t,
      props: [],
      revert: _revertStyle,
      save: _saveStyle
  };
  return t._gsap || gsap$2.core.getCache(t),
  r && r.split(",").forEach(function(o) {
      return a.save(o)
  }),
  a
}, _supports3D, _createElement = function(t, r) {
  var a = _doc$2.createElementNS ? _doc$2.createElementNS((r || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), t) : _doc$2.createElement(t);
  return a.style ? a : _doc$2.createElement(t)
}, _getComputedProperty = function e(t, r, a) {
  var o = getComputedStyle(t);
  return o[r] || o.getPropertyValue(r.replace(_capsExp$1, "-$1").toLowerCase()) || o.getPropertyValue(r) || !a && e(t, _checkPropPrefix(r) || r, 1) || ""
}, _prefixes = "O,Moz,ms,Ms,Webkit".split(","), _checkPropPrefix = function(t, r, a) {
  var o = r || _tempDiv
    , l = o.style
    , f = 5;
  if (t in l && !a)
      return t;
  for (t = t.charAt(0).toUpperCase() + t.substr(1); f-- && !(_prefixes[f] + t in l); )
      ;
  return f < 0 ? null : (f === 3 ? "ms" : f >= 0 ? _prefixes[f] : "") + t
}, _initCore$1 = function() {
  _windowExists$1() && window.document && (_win$2 = window,
  _doc$2 = _win$2.document,
  _docElement = _doc$2.documentElement,
  _tempDiv = _createElement("div") || {
      style: {}
  },
  _createElement("div"),
  _transformProp$1 = _checkPropPrefix(_transformProp$1),
  _transformOriginProp = _transformProp$1 + "Origin",
  _tempDiv.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0",
  _supports3D = !!_checkPropPrefix("perspective"),
  _reverting = gsap$2.core.reverting,
  _pluginInitted = 1)
}, _getBBoxHack = function e(t) {
  var r = _createElement("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), a = this.parentNode, o = this.nextSibling, l = this.style.cssText, f;
  if (_docElement.appendChild(r),
  r.appendChild(this),
  this.style.display = "block",
  t)
      try {
          f = this.getBBox(),
          this._gsapBBox = this.getBBox,
          this.getBBox = e
      } catch {}
  else
      this._gsapBBox && (f = this._gsapBBox());
  return a && (o ? a.insertBefore(this, o) : a.appendChild(this)),
  _docElement.removeChild(r),
  this.style.cssText = l,
  f
}, _getAttributeFallbacks = function(t, r) {
  for (var a = r.length; a--; )
      if (t.hasAttribute(r[a]))
          return t.getAttribute(r[a])
}, _getBBox = function(t) {
  var r;
  try {
      r = t.getBBox()
  } catch {
      r = _getBBoxHack.call(t, !0)
  }
  return r && (r.width || r.height) || t.getBBox === _getBBoxHack || (r = _getBBoxHack.call(t, !0)),
  r && !r.width && !r.x && !r.y ? {
      x: +_getAttributeFallbacks(t, ["x", "cx", "x1"]) || 0,
      y: +_getAttributeFallbacks(t, ["y", "cy", "y1"]) || 0,
      width: 0,
      height: 0
  } : r
}, _isSVG = function(t) {
  return !!(t.getCTM && (!t.parentNode || t.ownerSVGElement) && _getBBox(t))
}, _removeProperty = function(t, r) {
  if (r) {
      var a = t.style;
      r in _transformProps && r !== _transformOriginProp && (r = _transformProp$1),
      a.removeProperty ? ((r.substr(0, 2) === "ms" || r.substr(0, 6) === "webkit") && (r = "-" + r),
      a.removeProperty(r.replace(_capsExp$1, "-$1").toLowerCase())) : a.removeAttribute(r)
  }
}, _addNonTweeningPT = function(t, r, a, o, l, f) {
  var d = new PropTween(t._pt,r,a,0,1,f ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);
  return t._pt = d,
  d.b = o,
  d.e = l,
  t._props.push(a),
  d
}, _nonConvertibleUnits = {
  deg: 1,
  rad: 1,
  turn: 1
}, _nonStandardLayouts = {
  grid: 1,
  flex: 1
}, _convertToUnit = function e(t, r, a, o) {
  var l = parseFloat(a) || 0, f = (a + "").trim().substr((l + "").length) || "px", d = _tempDiv.style, g = _horizontalExp.test(r), _ = t.tagName.toLowerCase() === "svg", v = (_ ? "client" : "offset") + (g ? "Width" : "Height"), S = 100, b = o === "px", P = o === "%", x, E, I, C;
  return o === f || !l || _nonConvertibleUnits[o] || _nonConvertibleUnits[f] ? l : (f !== "px" && !b && (l = e(t, r, a, "px")),
  C = t.getCTM && _isSVG(t),
  (P || f === "%") && (_transformProps[r] || ~r.indexOf("adius")) ? (x = C ? t.getBBox()[g ? "width" : "height"] : t[v],
  _round$1(P ? l / x * S : l / 100 * x)) : (d[g ? "width" : "height"] = S + (b ? f : o),
  E = ~r.indexOf("adius") || o === "em" && t.appendChild && !_ ? t : t.parentNode,
  C && (E = (t.ownerSVGElement || {}).parentNode),
  (!E || E === _doc$2 || !E.appendChild) && (E = _doc$2.body),
  I = E._gsap,
  I && P && I.width && g && I.time === _ticker.time && !I.uncache ? _round$1(l / I.width * S) : ((P || f === "%") && !_nonStandardLayouts[_getComputedProperty(E, "display")] && (d.position = _getComputedProperty(t, "position")),
  E === t && (d.position = "static"),
  E.appendChild(_tempDiv),
  x = _tempDiv[v],
  E.removeChild(_tempDiv),
  d.position = "absolute",
  g && P && (I = _getCache(E),
  I.time = _ticker.time,
  I.width = E[v]),
  _round$1(b ? x * l / S : x && l ? S / x * l : 0))))
}, _get = function(t, r, a, o) {
  var l;
  return _pluginInitted || _initCore$1(),
  r in _propertyAliases && r !== "transform" && (r = _propertyAliases[r],
  ~r.indexOf(",") && (r = r.split(",")[0])),
  _transformProps[r] && r !== "transform" ? (l = _parseTransform(t, o),
  l = r !== "transformOrigin" ? l[r] : l.svg ? l.origin : _firstTwoOnly(_getComputedProperty(t, _transformOriginProp)) + " " + l.zOrigin + "px") : (l = t.style[r],
  (!l || l === "auto" || o || ~(l + "").indexOf("calc(")) && (l = _specialProps[r] && _specialProps[r](t, r, a) || _getComputedProperty(t, r) || _getProperty(t, r) || (r === "opacity" ? 1 : 0))),
  a && !~(l + "").trim().indexOf(" ") ? _convertToUnit(t, r, l, a) + a : l
}, _tweenComplexCSSString = function(t, r, a, o) {
  if (!a || a === "none") {
      var l = _checkPropPrefix(r, t, 1)
        , f = l && _getComputedProperty(t, l, 1);
      f && f !== a ? (r = l,
      a = f) : r === "borderColor" && (a = _getComputedProperty(t, "borderTopColor"))
  }
  var d = new PropTween(this._pt,t.style,r,0,1,_renderComplexString), g = 0, _ = 0, v, S, b, P, x, E, I, C, A, T, w, M;
  if (d.b = a,
  d.e = o,
  a += "",
  o += "",
  o === "auto" && (t.style[r] = o,
  o = _getComputedProperty(t, r) || o,
  t.style[r] = a),
  v = [a, o],
  _colorStringFilter(v),
  a = v[0],
  o = v[1],
  b = a.match(_numWithUnitExp) || [],
  M = o.match(_numWithUnitExp) || [],
  M.length) {
      for (; S = _numWithUnitExp.exec(o); )
          I = S[0],
          A = o.substring(g, S.index),
          x ? x = (x + 1) % 5 : (A.substr(-5) === "rgba(" || A.substr(-5) === "hsla(") && (x = 1),
          I !== (E = b[_++] || "") && (P = parseFloat(E) || 0,
          w = E.substr((P + "").length),
          I.charAt(1) === "=" && (I = _parseRelative(P, I) + w),
          C = parseFloat(I),
          T = I.substr((C + "").length),
          g = _numWithUnitExp.lastIndex - T.length,
          T || (T = T || _config.units[r] || w,
          g === o.length && (o += T,
          d.e += T)),
          w !== T && (P = _convertToUnit(t, r, E, T) || 0),
          d._pt = {
              _next: d._pt,
              p: A || _ === 1 ? A : ",",
              s: P,
              c: C - P,
              m: x && x < 4 || r === "zIndex" ? Math.round : 0
          });
      d.c = g < o.length ? o.substring(g, o.length) : ""
  } else
      d.r = r === "display" && o === "none" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;
  return _relExp.test(o) && (d.e = 0),
  this._pt = d,
  d
}, _keywordToPercent = {
  top: "0%",
  bottom: "100%",
  left: "0%",
  right: "100%",
  center: "50%"
}, _convertKeywordsToPercentages = function(t) {
  var r = t.split(" ")
    , a = r[0]
    , o = r[1] || "50%";
  return (a === "top" || a === "bottom" || o === "left" || o === "right") && (t = a,
  a = o,
  o = t),
  r[0] = _keywordToPercent[a] || a,
  r[1] = _keywordToPercent[o] || o,
  r.join(" ")
}, _renderClearProps = function(t, r) {
  if (r.tween && r.tween._time === r.tween._dur) {
      var a = r.t, o = a.style, l = r.u, f = a._gsap, d, g, _;
      if (l === "all" || l === !0)
          o.cssText = "",
          g = 1;
      else
          for (l = l.split(","),
          _ = l.length; --_ > -1; )
              d = l[_],
              _transformProps[d] && (g = 1,
              d = d === "transformOrigin" ? _transformOriginProp : _transformProp$1),
              _removeProperty(a, d);
      g && (_removeProperty(a, _transformProp$1),
      f && (f.svg && a.removeAttribute("transform"),
      _parseTransform(a, 1),
      f.uncache = 1,
      _removeIndependentTransforms(o)))
  }
}, _specialProps = {
  clearProps: function(t, r, a, o, l) {
      if (l.data !== "isFromStart") {
          var f = t._pt = new PropTween(t._pt,r,a,0,0,_renderClearProps);
          return f.u = o,
          f.pr = -10,
          f.tween = l,
          t._props.push(a),
          1
      }
  }
}, _identity2DMatrix = [1, 0, 0, 1, 0, 0], _rotationalProperties = {}, _isNullTransform = function(t) {
  return t === "matrix(1, 0, 0, 1, 0, 0)" || t === "none" || !t
}, _getComputedTransformMatrixAsArray = function(t) {
  var r = _getComputedProperty(t, _transformProp$1);
  return _isNullTransform(r) ? _identity2DMatrix : r.substr(7).match(_numExp).map(_round$1)
}, _getMatrix = function(t, r) {
  var a = t._gsap || _getCache(t), o = t.style, l = _getComputedTransformMatrixAsArray(t), f, d, g, _;
  return a.svg && t.getAttribute("transform") ? (g = t.transform.baseVal.consolidate().matrix,
  l = [g.a, g.b, g.c, g.d, g.e, g.f],
  l.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : l) : (l === _identity2DMatrix && !t.offsetParent && t !== _docElement && !a.svg && (g = o.display,
  o.display = "block",
  f = t.parentNode,
  (!f || !t.offsetParent) && (_ = 1,
  d = t.nextElementSibling,
  _docElement.appendChild(t)),
  l = _getComputedTransformMatrixAsArray(t),
  g ? o.display = g : _removeProperty(t, "display"),
  _ && (d ? f.insertBefore(t, d) : f ? f.appendChild(t) : _docElement.removeChild(t))),
  r && l.length > 6 ? [l[0], l[1], l[4], l[5], l[12], l[13]] : l)
}, _applySVGOrigin = function(t, r, a, o, l, f) {
  var d = t._gsap, g = l || _getMatrix(t, !0), _ = d.xOrigin || 0, v = d.yOrigin || 0, S = d.xOffset || 0, b = d.yOffset || 0, P = g[0], x = g[1], E = g[2], I = g[3], C = g[4], A = g[5], T = r.split(" "), w = parseFloat(T[0]) || 0, M = parseFloat(T[1]) || 0, F, O, $, j;
  a ? g !== _identity2DMatrix && (O = P * I - x * E) && ($ = w * (I / O) + M * (-E / O) + (E * A - I * C) / O,
  j = w * (-x / O) + M * (P / O) - (P * A - x * C) / O,
  w = $,
  M = j) : (F = _getBBox(t),
  w = F.x + (~T[0].indexOf("%") ? w / 100 * F.width : w),
  M = F.y + (~(T[1] || T[0]).indexOf("%") ? M / 100 * F.height : M)),
  o || o !== !1 && d.smooth ? (C = w - _,
  A = M - v,
  d.xOffset = S + (C * P + A * E) - C,
  d.yOffset = b + (C * x + A * I) - A) : d.xOffset = d.yOffset = 0,
  d.xOrigin = w,
  d.yOrigin = M,
  d.smooth = !!o,
  d.origin = r,
  d.originIsAbsolute = !!a,
  t.style[_transformOriginProp] = "0px 0px",
  f && (_addNonTweeningPT(f, d, "xOrigin", _, w),
  _addNonTweeningPT(f, d, "yOrigin", v, M),
  _addNonTweeningPT(f, d, "xOffset", S, d.xOffset),
  _addNonTweeningPT(f, d, "yOffset", b, d.yOffset)),
  t.setAttribute("data-svg-origin", w + " " + M)
}, _parseTransform = function(t, r) {
  var a = t._gsap || new GSCache(t);
  if ("x"in a && !r && !a.uncache)
      return a;
  var o = t.style, l = a.scaleX < 0, f = "px", d = "deg", g = getComputedStyle(t), _ = _getComputedProperty(t, _transformOriginProp) || "0", v, S, b, P, x, E, I, C, A, T, w, M, F, O, $, j, K, Y, W, Z, ee, X, D, B, R, L, V, q, oe, ye, pe, Pe;
  return v = S = b = E = I = C = A = T = w = 0,
  P = x = 1,
  a.svg = !!(t.getCTM && _isSVG(t)),
  g.translate && ((g.translate !== "none" || g.scale !== "none" || g.rotate !== "none") && (o[_transformProp$1] = (g.translate !== "none" ? "translate3d(" + (g.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (g.rotate !== "none" ? "rotate(" + g.rotate + ") " : "") + (g.scale !== "none" ? "scale(" + g.scale.split(" ").join(",") + ") " : "") + (g[_transformProp$1] !== "none" ? g[_transformProp$1] : "")),
  o.scale = o.rotate = o.translate = "none"),
  O = _getMatrix(t, a.svg),
  a.svg && (a.uncache ? (R = t.getBBox(),
  _ = a.xOrigin - R.x + "px " + (a.yOrigin - R.y) + "px",
  B = "") : B = !r && t.getAttribute("data-svg-origin"),
  _applySVGOrigin(t, B || _, !!B || a.originIsAbsolute, a.smooth !== !1, O)),
  M = a.xOrigin || 0,
  F = a.yOrigin || 0,
  O !== _identity2DMatrix && (Y = O[0],
  W = O[1],
  Z = O[2],
  ee = O[3],
  v = X = O[4],
  S = D = O[5],
  O.length === 6 ? (P = Math.sqrt(Y * Y + W * W),
  x = Math.sqrt(ee * ee + Z * Z),
  E = Y || W ? _atan2(W, Y) * _RAD2DEG : 0,
  A = Z || ee ? _atan2(Z, ee) * _RAD2DEG + E : 0,
  A && (x *= Math.abs(Math.cos(A * _DEG2RAD))),
  a.svg && (v -= M - (M * Y + F * Z),
  S -= F - (M * W + F * ee))) : (Pe = O[6],
  ye = O[7],
  V = O[8],
  q = O[9],
  oe = O[10],
  pe = O[11],
  v = O[12],
  S = O[13],
  b = O[14],
  $ = _atan2(Pe, oe),
  I = $ * _RAD2DEG,
  $ && (j = Math.cos(-$),
  K = Math.sin(-$),
  B = X * j + V * K,
  R = D * j + q * K,
  L = Pe * j + oe * K,
  V = X * -K + V * j,
  q = D * -K + q * j,
  oe = Pe * -K + oe * j,
  pe = ye * -K + pe * j,
  X = B,
  D = R,
  Pe = L),
  $ = _atan2(-Z, oe),
  C = $ * _RAD2DEG,
  $ && (j = Math.cos(-$),
  K = Math.sin(-$),
  B = Y * j - V * K,
  R = W * j - q * K,
  L = Z * j - oe * K,
  pe = ee * K + pe * j,
  Y = B,
  W = R,
  Z = L),
  $ = _atan2(W, Y),
  E = $ * _RAD2DEG,
  $ && (j = Math.cos($),
  K = Math.sin($),
  B = Y * j + W * K,
  R = X * j + D * K,
  W = W * j - Y * K,
  D = D * j - X * K,
  Y = B,
  X = R),
  I && Math.abs(I) + Math.abs(E) > 359.9 && (I = E = 0,
  C = 180 - C),
  P = _round$1(Math.sqrt(Y * Y + W * W + Z * Z)),
  x = _round$1(Math.sqrt(D * D + Pe * Pe)),
  $ = _atan2(X, D),
  A = Math.abs($) > 2e-4 ? $ * _RAD2DEG : 0,
  w = pe ? 1 / (pe < 0 ? -pe : pe) : 0),
  a.svg && (B = t.getAttribute("transform"),
  a.forceCSS = t.setAttribute("transform", "") || !_isNullTransform(_getComputedProperty(t, _transformProp$1)),
  B && t.setAttribute("transform", B))),
  Math.abs(A) > 90 && Math.abs(A) < 270 && (l ? (P *= -1,
  A += E <= 0 ? 180 : -180,
  E += E <= 0 ? 180 : -180) : (x *= -1,
  A += A <= 0 ? 180 : -180)),
  r = r || a.uncache,
  a.x = v - ((a.xPercent = v && (!r && a.xPercent || (Math.round(t.offsetWidth / 2) === Math.round(-v) ? -50 : 0))) ? t.offsetWidth * a.xPercent / 100 : 0) + f,
  a.y = S - ((a.yPercent = S && (!r && a.yPercent || (Math.round(t.offsetHeight / 2) === Math.round(-S) ? -50 : 0))) ? t.offsetHeight * a.yPercent / 100 : 0) + f,
  a.z = b + f,
  a.scaleX = _round$1(P),
  a.scaleY = _round$1(x),
  a.rotation = _round$1(E) + d,
  a.rotationX = _round$1(I) + d,
  a.rotationY = _round$1(C) + d,
  a.skewX = A + d,
  a.skewY = T + d,
  a.transformPerspective = w + f,
  (a.zOrigin = parseFloat(_.split(" ")[2]) || 0) && (o[_transformOriginProp] = _firstTwoOnly(_)),
  a.xOffset = a.yOffset = 0,
  a.force3D = _config.force3D,
  a.renderTransform = a.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms,
  a.uncache = 0,
  a
}, _firstTwoOnly = function(t) {
  return (t = t.split(" "))[0] + " " + t[1]
}, _addPxTranslate = function(t, r, a) {
  var o = getUnit(r);
  return _round$1(parseFloat(r) + parseFloat(_convertToUnit(t, "x", a + "px", o))) + o
}, _renderNon3DTransforms = function(t, r) {
  r.z = "0px",
  r.rotationY = r.rotationX = "0deg",
  r.force3D = 0,
  _renderCSSTransforms(t, r)
}, _zeroDeg = "0deg", _zeroPx = "0px", _endParenthesis = ") ", _renderCSSTransforms = function(t, r) {
  var a = r || this
    , o = a.xPercent
    , l = a.yPercent
    , f = a.x
    , d = a.y
    , g = a.z
    , _ = a.rotation
    , v = a.rotationY
    , S = a.rotationX
    , b = a.skewX
    , P = a.skewY
    , x = a.scaleX
    , E = a.scaleY
    , I = a.transformPerspective
    , C = a.force3D
    , A = a.target
    , T = a.zOrigin
    , w = ""
    , M = C === "auto" && t && t !== 1 || C === !0;
  if (T && (S !== _zeroDeg || v !== _zeroDeg)) {
      var F = parseFloat(v) * _DEG2RAD, O = Math.sin(F), $ = Math.cos(F), j;
      F = parseFloat(S) * _DEG2RAD,
      j = Math.cos(F),
      f = _addPxTranslate(A, f, O * j * -T),
      d = _addPxTranslate(A, d, -Math.sin(F) * -T),
      g = _addPxTranslate(A, g, $ * j * -T + T)
  }
  I !== _zeroPx && (w += "perspective(" + I + _endParenthesis),
  (o || l) && (w += "translate(" + o + "%, " + l + "%) "),
  (M || f !== _zeroPx || d !== _zeroPx || g !== _zeroPx) && (w += g !== _zeroPx || M ? "translate3d(" + f + ", " + d + ", " + g + ") " : "translate(" + f + ", " + d + _endParenthesis),
  _ !== _zeroDeg && (w += "rotate(" + _ + _endParenthesis),
  v !== _zeroDeg && (w += "rotateY(" + v + _endParenthesis),
  S !== _zeroDeg && (w += "rotateX(" + S + _endParenthesis),
  (b !== _zeroDeg || P !== _zeroDeg) && (w += "skew(" + b + ", " + P + _endParenthesis),
  (x !== 1 || E !== 1) && (w += "scale(" + x + ", " + E + _endParenthesis),
  A.style[_transformProp$1] = w || "translate(0, 0)"
}, _renderSVGTransforms = function(t, r) {
  var a = r || this, o = a.xPercent, l = a.yPercent, f = a.x, d = a.y, g = a.rotation, _ = a.skewX, v = a.skewY, S = a.scaleX, b = a.scaleY, P = a.target, x = a.xOrigin, E = a.yOrigin, I = a.xOffset, C = a.yOffset, A = a.forceCSS, T = parseFloat(f), w = parseFloat(d), M, F, O, $, j;
  g = parseFloat(g),
  _ = parseFloat(_),
  v = parseFloat(v),
  v && (v = parseFloat(v),
  _ += v,
  g += v),
  g || _ ? (g *= _DEG2RAD,
  _ *= _DEG2RAD,
  M = Math.cos(g) * S,
  F = Math.sin(g) * S,
  O = Math.sin(g - _) * -b,
  $ = Math.cos(g - _) * b,
  _ && (v *= _DEG2RAD,
  j = Math.tan(_ - v),
  j = Math.sqrt(1 + j * j),
  O *= j,
  $ *= j,
  v && (j = Math.tan(v),
  j = Math.sqrt(1 + j * j),
  M *= j,
  F *= j)),
  M = _round$1(M),
  F = _round$1(F),
  O = _round$1(O),
  $ = _round$1($)) : (M = S,
  $ = b,
  F = O = 0),
  (T && !~(f + "").indexOf("px") || w && !~(d + "").indexOf("px")) && (T = _convertToUnit(P, "x", f, "px"),
  w = _convertToUnit(P, "y", d, "px")),
  (x || E || I || C) && (T = _round$1(T + x - (x * M + E * O) + I),
  w = _round$1(w + E - (x * F + E * $) + C)),
  (o || l) && (j = P.getBBox(),
  T = _round$1(T + o / 100 * j.width),
  w = _round$1(w + l / 100 * j.height)),
  j = "matrix(" + M + "," + F + "," + O + "," + $ + "," + T + "," + w + ")",
  P.setAttribute("transform", j),
  A && (P.style[_transformProp$1] = j)
}, _addRotationalPropTween = function(t, r, a, o, l) {
  var f = 360, d = _isString$1(l), g = parseFloat(l) * (d && ~l.indexOf("rad") ? _RAD2DEG : 1), _ = g - o, v = o + _ + "deg", S, b;
  return d && (S = l.split("_")[1],
  S === "short" && (_ %= f,
  _ !== _ % (f / 2) && (_ += _ < 0 ? f : -f)),
  S === "cw" && _ < 0 ? _ = (_ + f * _bigNum) % f - ~~(_ / f) * f : S === "ccw" && _ > 0 && (_ = (_ - f * _bigNum) % f - ~~(_ / f) * f)),
  t._pt = b = new PropTween(t._pt,r,a,o,_,_renderPropWithEnd),
  b.e = v,
  b.u = "deg",
  t._props.push(a),
  b
}, _assign = function(t, r) {
  for (var a in r)
      t[a] = r[a];
  return t
}, _addRawTransformPTs = function(t, r, a) {
  var o = _assign({}, a._gsap), l = "perspective,force3D,transformOrigin,svgOrigin", f = a.style, d, g, _, v, S, b, P, x;
  o.svg ? (_ = a.getAttribute("transform"),
  a.setAttribute("transform", ""),
  f[_transformProp$1] = r,
  d = _parseTransform(a, 1),
  _removeProperty(a, _transformProp$1),
  a.setAttribute("transform", _)) : (_ = getComputedStyle(a)[_transformProp$1],
  f[_transformProp$1] = r,
  d = _parseTransform(a, 1),
  f[_transformProp$1] = _);
  for (g in _transformProps)
      _ = o[g],
      v = d[g],
      _ !== v && l.indexOf(g) < 0 && (P = getUnit(_),
      x = getUnit(v),
      S = P !== x ? _convertToUnit(a, g, _, x) : parseFloat(_),
      b = parseFloat(v),
      t._pt = new PropTween(t._pt,d,g,S,b - S,_renderCSSProp),
      t._pt.u = x || 0,
      t._props.push(g));
  _assign(d, o)
};
_forEachName("padding,margin,Width,Radius", function(e, t) {
  var r = "Top"
    , a = "Right"
    , o = "Bottom"
    , l = "Left"
    , f = (t < 3 ? [r, a, o, l] : [r + l, r + a, o + a, o + l]).map(function(d) {
      return t < 2 ? e + d : "border" + d + e
  });
  _specialProps[t > 1 ? "border" + e : e] = function(d, g, _, v, S) {
      var b, P;
      if (arguments.length < 4)
          return b = f.map(function(x) {
              return _get(d, x, _)
          }),
          P = b.join(" "),
          P.split(b[0]).length === 5 ? b[0] : P;
      b = (v + "").split(" "),
      P = {},
      f.forEach(function(x, E) {
          return P[x] = b[E] = b[E] || b[(E - 1) / 2 | 0]
      }),
      d.init(g, P, S)
  }
});
var CSSPlugin = {
  name: "css",
  register: _initCore$1,
  targetTest: function(t) {
      return t.style && t.nodeType
  },
  init: function(t, r, a, o, l) {
      var f = this._props, d = t.style, g = a.vars.startAt, _, v, S, b, P, x, E, I, C, A, T, w, M, F, O, $;
      _pluginInitted || _initCore$1(),
      this.styles = this.styles || _getStyleSaver(t),
      $ = this.styles.props,
      this.tween = a;
      for (E in r)
          if (E !== "autoRound" && (v = r[E],
          !(_plugins[E] && _checkPlugin(E, r, a, o, t, l)))) {
              if (P = typeof v,
              x = _specialProps[E],
              P === "function" && (v = v.call(a, o, t, l),
              P = typeof v),
              P === "string" && ~v.indexOf("random(") && (v = _replaceRandom(v)),
              x)
                  x(this, t, E, v, a) && (O = 1);
              else if (E.substr(0, 2) === "--")
                  _ = (getComputedStyle(t).getPropertyValue(E) + "").trim(),
                  v += "",
                  _colorExp.lastIndex = 0,
                  _colorExp.test(_) || (I = getUnit(_),
                  C = getUnit(v)),
                  C ? I !== C && (_ = _convertToUnit(t, E, _, C) + C) : I && (v += I),
                  this.add(d, "setProperty", _, v, o, l, 0, 0, E),
                  f.push(E),
                  $.push(E, 0, d[E]);
              else if (P !== "undefined") {
                  if (g && E in g ? (_ = typeof g[E] == "function" ? g[E].call(a, o, t, l) : g[E],
                  _isString$1(_) && ~_.indexOf("random(") && (_ = _replaceRandom(_)),
                  getUnit(_ + "") || (_ += _config.units[E] || getUnit(_get(t, E)) || ""),
                  (_ + "").charAt(1) === "=" && (_ = _get(t, E))) : _ = _get(t, E),
                  b = parseFloat(_),
                  A = P === "string" && v.charAt(1) === "=" && v.substr(0, 2),
                  A && (v = v.substr(2)),
                  S = parseFloat(v),
                  E in _propertyAliases && (E === "autoAlpha" && (b === 1 && _get(t, "visibility") === "hidden" && S && (b = 0),
                  $.push("visibility", 0, d.visibility),
                  _addNonTweeningPT(this, d, "visibility", b ? "inherit" : "hidden", S ? "inherit" : "hidden", !S)),
                  E !== "scale" && E !== "transform" && (E = _propertyAliases[E],
                  ~E.indexOf(",") && (E = E.split(",")[0]))),
                  T = E in _transformProps,
                  T) {
                      if (this.styles.save(E),
                      w || (M = t._gsap,
                      M.renderTransform && !r.parseTransform || _parseTransform(t, r.parseTransform),
                      F = r.smoothOrigin !== !1 && M.smooth,
                      w = this._pt = new PropTween(this._pt,d,_transformProp$1,0,1,M.renderTransform,M,0,-1),
                      w.dep = 1),
                      E === "scale")
                          this._pt = new PropTween(this._pt,M,"scaleY",M.scaleY,(A ? _parseRelative(M.scaleY, A + S) : S) - M.scaleY || 0,_renderCSSProp),
                          this._pt.u = 0,
                          f.push("scaleY", E),
                          E += "X";
                      else if (E === "transformOrigin") {
                          $.push(_transformOriginProp, 0, d[_transformOriginProp]),
                          v = _convertKeywordsToPercentages(v),
                          M.svg ? _applySVGOrigin(t, v, 0, F, 0, this) : (C = parseFloat(v.split(" ")[2]) || 0,
                          C !== M.zOrigin && _addNonTweeningPT(this, M, "zOrigin", M.zOrigin, C),
                          _addNonTweeningPT(this, d, E, _firstTwoOnly(_), _firstTwoOnly(v)));
                          continue
                      } else if (E === "svgOrigin") {
                          _applySVGOrigin(t, v, 1, F, 0, this);
                          continue
                      } else if (E in _rotationalProperties) {
                          _addRotationalPropTween(this, M, E, b, A ? _parseRelative(b, A + v) : v);
                          continue
                      } else if (E === "smoothOrigin") {
                          _addNonTweeningPT(this, M, "smooth", M.smooth, v);
                          continue
                      } else if (E === "force3D") {
                          M[E] = v;
                          continue
                      } else if (E === "transform") {
                          _addRawTransformPTs(this, v, t);
                          continue
                      }
                  } else
                      E in d || (E = _checkPropPrefix(E) || E);
                  if (T || (S || S === 0) && (b || b === 0) && !_complexExp.test(v) && E in d)
                      I = (_ + "").substr((b + "").length),
                      S || (S = 0),
                      C = getUnit(v) || (E in _config.units ? _config.units[E] : I),
                      I !== C && (b = _convertToUnit(t, E, _, C)),
                      this._pt = new PropTween(this._pt,T ? M : d,E,b,(A ? _parseRelative(b, A + S) : S) - b,!T && (C === "px" || E === "zIndex") && r.autoRound !== !1 ? _renderRoundedCSSProp : _renderCSSProp),
                      this._pt.u = C || 0,
                      I !== C && C !== "%" && (this._pt.b = _,
                      this._pt.r = _renderCSSPropWithBeginning);
                  else if (E in d)
                      _tweenComplexCSSString.call(this, t, E, _, A ? A + v : v);
                  else if (E in t)
                      this.add(t, E, _ || t[E], A ? A + v : v, o, l);
                  else if (E !== "parseTransform") {
                      _missingPlugin(E, v);
                      continue
                  }
                  T || (E in d ? $.push(E, 0, d[E]) : $.push(E, 1, _ || t[E])),
                  f.push(E)
              }
          }
      O && _sortPropTweensByPriority(this)
  },
  render: function(t, r) {
      if (r.tween._time || !_reverting())
          for (var a = r._pt; a; )
              a.r(t, a.d),
              a = a._next;
      else
          r.styles.revert()
  },
  get: _get,
  aliases: _propertyAliases,
  getSetter: function(t, r, a) {
      var o = _propertyAliases[r];
      return o && o.indexOf(",") < 0 && (r = o),
      r in _transformProps && r !== _transformOriginProp && (t._gsap.x || _get(t, "x")) ? a && _recentSetterPlugin === a ? r === "scale" ? _setterScale : _setterTransform : (_recentSetterPlugin = a || {}) && (r === "scale" ? _setterScaleWithRender : _setterTransformWithRender) : t.style && !_isUndefined(t.style[r]) ? _setterCSSStyle : ~r.indexOf("-") ? _setterCSSProp : _getSetter(t, r)
  },
  core: {
      _removeProperty,
      _getMatrix
  }
};
gsap$2.utils.checkPrefix = _checkPropPrefix;
gsap$2.core.getStyleSaver = _getStyleSaver;
(function(e, t, r, a) {
  var o = _forEachName(e + "," + t + "," + r, function(l) {
      _transformProps[l] = 1
  });
  _forEachName(t, function(l) {
      _config.units[l] = "deg",
      _rotationalProperties[l] = 1
  }),
  _propertyAliases[o[13]] = e + "," + t,
  _forEachName(a, function(l) {
      var f = l.split(":");
      _propertyAliases[f[1]] = o[f[0]]
  })
}
)("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
_forEachName("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(e) {
  _config.units[e] = "px"
});
gsap$2.registerPlugin(CSSPlugin);
var gsapWithCSS = gsap$2.registerPlugin(CSSPlugin) || gsap$2;
gsapWithCSS.core.Tween;
const transitionState = reactive({
  transitionComplete: !1
})
, useTransition = ()=>({
  transitionState,
  toggleTransitionComplete: t=>{
      transitionState.transitionComplete = t
  }
})
, {toggleTransitionComplete} = useTransition()
, pageTransition = {
  name: "page-transiton",
  mode: "out-in",
  onEnter: (e,t)=>{
      gsapWithCSS.timeline({
          paused: !0,
          onComplete: ()=>{
              toggleTransitionComplete(!0),
              t()
          }
      }).to(".page-transition > div", {
          autoAlpha: 0,
          pointerEvents: "none"
      }).set(".page-transition > div", {
          height: "0%",
          autoAlpha: 1
      }).play()
  }
  ,
  onLeave: (e,t)=>{
      toggleTransitionComplete(!1),
      gsapWithCSS.timeline({
          paused: !0,
          onComplete: ()=>{
              t()
          }
      }).to(".page-transition > div", {
          height: "100%",
          duration: 1.5,
          ease: "expo.inOut"
      }).play()
  }
}
, __nuxt_page_meta$8 = {
  pageTransition
}
, __nuxt_page_meta$7 = {
  pageTransition
}
, __nuxt_page_meta$6 = {
  pageTransition
}
, __nuxt_page_meta$5 = {
  pageTransition
}
, __nuxt_page_meta$4 = {
  pageTransition
}
, __nuxt_page_meta$3 = {
  pageTransition
}
, __nuxt_page_meta$2 = {
  pageTransition
}
, __nuxt_page_meta$1 = {
  pageTransition
}
, __nuxt_page_meta = {
  pageTransition
}
, _routes = [{
  name: (__nuxt_page_meta$8 == null ? void 0 : __nuxt_page_meta$8.name) ?? "about",
  path: (__nuxt_page_meta$8 == null ? void 0 : __nuxt_page_meta$8.path) ?? "/about",
  meta: __nuxt_page_meta$8 || {},
  alias: (__nuxt_page_meta$8 == null ? void 0 : __nuxt_page_meta$8.alias) || [],
  redirect: __nuxt_page_meta$8 == null ? void 0 : __nuxt_page_meta$8.redirect,
  component: ()=>__vitePreload(()=>import("./Cgt08vL4.js"), __vite__mapDeps([0, 1, 2, 3, 4]), import.meta.url).then(e=>e.default || e)
}, {
  name: (__nuxt_page_meta$7 == null ? void 0 : __nuxt_page_meta$7.name) ?? "careers",
  path: (__nuxt_page_meta$7 == null ? void 0 : __nuxt_page_meta$7.path) ?? "/careers",
  meta: __nuxt_page_meta$7 || {},
  alias: (__nuxt_page_meta$7 == null ? void 0 : __nuxt_page_meta$7.alias) || [],
  redirect: __nuxt_page_meta$7 == null ? void 0 : __nuxt_page_meta$7.redirect,
  component: ()=>__vitePreload(()=>import("./cbUdJWfL.js"), __vite__mapDeps([5, 1, 2, 6, 7, 8, 3, 9]), import.meta.url).then(e=>e.default || e)
}, {
  name: (__nuxt_page_meta$6 == null ? void 0 : __nuxt_page_meta$6.name) ?? "contact",
  path: (__nuxt_page_meta$6 == null ? void 0 : __nuxt_page_meta$6.path) ?? "/contact",
  meta: __nuxt_page_meta$6 || {},
  alias: (__nuxt_page_meta$6 == null ? void 0 : __nuxt_page_meta$6.alias) || [],
  redirect: __nuxt_page_meta$6 == null ? void 0 : __nuxt_page_meta$6.redirect,
  component: ()=>__vitePreload(()=>import("./BzBQ7ZwS.js"), __vite__mapDeps([10, 1, 2, 11, 7, 8, 12]), import.meta.url).then(e=>e.default || e)
}, {
  name: (__nuxt_page_meta$5 == null ? void 0 : __nuxt_page_meta$5.name) ?? "index",
  path: (__nuxt_page_meta$5 == null ? void 0 : __nuxt_page_meta$5.path) ?? "/",
  meta: __nuxt_page_meta$5 || {},
  alias: (__nuxt_page_meta$5 == null ? void 0 : __nuxt_page_meta$5.alias) || [],
  redirect: __nuxt_page_meta$5 == null ? void 0 : __nuxt_page_meta$5.redirect,
  component: ()=>__vitePreload(()=>import("./DoZHCXTn.js"), __vite__mapDeps([13, 14, 2, 6, 7, 8, 15, 16, 1, 3, 17]), import.meta.url).then(e=>e.default || e)
}, {
  name: (__nuxt_page_meta$4 == null ? void 0 : __nuxt_page_meta$4.name) ?? "services",
  path: (__nuxt_page_meta$4 == null ? void 0 : __nuxt_page_meta$4.path) ?? "/services",
  meta: __nuxt_page_meta$4 || {},
  alias: (__nuxt_page_meta$4 == null ? void 0 : __nuxt_page_meta$4.alias) || [],
  redirect: __nuxt_page_meta$4 == null ? void 0 : __nuxt_page_meta$4.redirect,
  component: ()=>__vitePreload(()=>import("./BvtywrCf.js"), __vite__mapDeps([18, 1, 2, 19]), import.meta.url).then(e=>e.default || e)
}, {
  name: (__nuxt_page_meta$3 == null ? void 0 : __nuxt_page_meta$3.name) ?? "thoughts-slug",
  path: (__nuxt_page_meta$3 == null ? void 0 : __nuxt_page_meta$3.path) ?? "/thoughts/:slug()",
  meta: __nuxt_page_meta$3 || {},
  alias: (__nuxt_page_meta$3 == null ? void 0 : __nuxt_page_meta$3.alias) || [],
  redirect: __nuxt_page_meta$3 == null ? void 0 : __nuxt_page_meta$3.redirect,
  component: ()=>__vitePreload(()=>import("./Cye3HFxU.js"), __vite__mapDeps([20, 21, 22, 23, 1, 2, 6, 7, 8, 11, 24, 25]), import.meta.url).then(e=>e.default || e)
}, {
  name: (__nuxt_page_meta$2 == null ? void 0 : __nuxt_page_meta$2.name) ?? "thoughts",
  path: (__nuxt_page_meta$2 == null ? void 0 : __nuxt_page_meta$2.path) ?? "/thoughts",
  meta: __nuxt_page_meta$2 || {},
  alias: (__nuxt_page_meta$2 == null ? void 0 : __nuxt_page_meta$2.alias) || [],
  redirect: __nuxt_page_meta$2 == null ? void 0 : __nuxt_page_meta$2.redirect,
  component: ()=>__vitePreload(()=>import("./C1iqj4lt.js"), __vite__mapDeps([26, 24, 7, 8, 6, 21, 1, 2, 16, 11, 27]), import.meta.url).then(e=>e.default || e)
}, {
  name: (__nuxt_page_meta$1 == null ? void 0 : __nuxt_page_meta$1.name) ?? "work-slug",
  path: (__nuxt_page_meta$1 == null ? void 0 : __nuxt_page_meta$1.path) ?? "/work/:slug()",
  meta: __nuxt_page_meta$1 || {},
  alias: (__nuxt_page_meta$1 == null ? void 0 : __nuxt_page_meta$1.alias) || [],
  redirect: __nuxt_page_meta$1 == null ? void 0 : __nuxt_page_meta$1.redirect,
  component: ()=>__vitePreload(()=>import("./DmtyMaM0.js"), __vite__mapDeps([28, 22, 23, 1, 2, 6, 7, 8, 3, 29]), import.meta.url).then(e=>e.default || e)
}, {
  name: (__nuxt_page_meta == null ? void 0 : __nuxt_page_meta.name) ?? "work",
  path: (__nuxt_page_meta == null ? void 0 : __nuxt_page_meta.path) ?? "/work",
  meta: __nuxt_page_meta || {},
  alias: (__nuxt_page_meta == null ? void 0 : __nuxt_page_meta.alias) || [],
  redirect: __nuxt_page_meta == null ? void 0 : __nuxt_page_meta.redirect,
  component: ()=>__vitePreload(()=>import("./DLIuzo_Q.js"), __vite__mapDeps([30, 14, 2, 6, 7, 8, 15, 21, 1, 16]), import.meta.url).then(e=>e.default || e)
}]
, _wrapIf = (e,t,r)=>(t = t === !0 ? {} : t,
{
  default: ()=>{
      var a;
      return t ? h(e, t, r) : (a = r.default) == null ? void 0 : a.call(r)
  }
});
function generateRouteKey(e) {
  const t = (e == null ? void 0 : e.meta.key) ?? e.path.replace(/(:\w+)\([^)]+\)/g, "$1").replace(/(:\w+)[?+*]/g, "$1").replace(/:\w+/g, r=>{
      var a;
      return ((a = e.params[r.slice(1)]) == null ? void 0 : a.toString()) || ""
  }
  );
  return typeof t == "function" ? t(e) : t
}
function isChangingPage(e, t) {
  return e === t || t === START_LOCATION_NORMALIZED ? !1 : generateRouteKey(e) !== generateRouteKey(t) ? !0 : !e.matched.every((a,o)=>{
      var l, f;
      return a.components && a.components.default === ((f = (l = t.matched[o]) == null ? void 0 : l.components) == null ? void 0 : f.default)
  }
  )
}
const routerOptions0 = {
  scrollBehavior(e, t, r) {
      var _;
      const a = useNuxtApp()
        , o = ((_ = useRouter().options) == null ? void 0 : _.scrollBehaviorType) ?? "auto";
      let l = r || void 0;
      const f = typeof e.meta.scrollToTop == "function" ? e.meta.scrollToTop(e, t) : e.meta.scrollToTop;
      if (!l && t && e && f !== !1 && isChangingPage(e, t) && (l = {
          left: 0,
          top: 0
      }),
      e.path === t.path)
          return t.hash && !e.hash ? {
              left: 0,
              top: 0
          } : e.hash ? {
              el: e.hash,
              top: _getHashElementScrollMarginTop(e.hash),
              behavior: o
          } : !1;
      const d = v=>!!(v.meta.pageTransition ?? appPageTransition)
        , g = d(t) && d(e) ? "page:transition:finish" : "page:finish";
      return new Promise(v=>{
          a.hooks.hookOnce(g, async()=>{
              await new Promise(S=>setTimeout(S, 0)),
              e.hash && (l = {
                  el: e.hash,
                  top: _getHashElementScrollMarginTop(e.hash),
                  behavior: o
              }),
              v(l)
          }
          )
      }
      )
  }
};
function _getHashElementScrollMarginTop(e) {
  try {
      const t = document.querySelector(e);
      if (t)
          return parseFloat(getComputedStyle(t).scrollMarginTop)
  } catch {}
  return 0
}
const configRouterOptions = {
  hashMode: !1,
  scrollBehaviorType: "auto"
}
, routerOptions = {
  ...configRouterOptions,
  ...routerOptions0
}
, validate = async e=>{
  var g;
  let t, r;
  if (!((g = e.meta) != null && g.validate))
      return;
  const a = useNuxtApp()
    , o = useRouter();
  if (([t,r] = executeAsync(()=>Promise.resolve(e.meta.validate(e))),
  t = await t,
  r(),
  t) === !0)
      return;
  const f = createError({
      statusCode: 404,
      statusMessage: `Page Not Found: ${e.fullPath}`,
      data: {
          path: e.fullPath
      }
  })
    , d = o.beforeResolve(_=>{
      if (d(),
      _ === e) {
          const v = o.afterEach(async()=>{
              v(),
              await a.runWithContext(()=>showError(f)),
              window.history.pushState({}, "", e.fullPath)
          }
          );
          return !1
      }
  }
  )
}
, _01_45states_45global = ()=>{}
, useStateKeyPrefix = "$s";
function useState(...e) {
  const t = typeof e[e.length - 1] == "string" ? e.pop() : void 0;
  typeof e[0] != "string" && e.unshift(t);
  const [r,a] = e;
  if (!r || typeof r != "string")
      throw new TypeError("[nuxt] [useState] key must be a string: " + r);
  if (a !== void 0 && typeof a != "function")
      throw new Error("[nuxt] [useState] init must be a function: " + a);
  const o = useStateKeyPrefix + r
    , l = useNuxtApp()
    , f = toRef(l.payload.state, o);
  if (f.value === void 0 && a) {
      const d = a();
      if (isRef(d))
          return l.payload.state[o] = d,
          d;
      f.value = d
  }
  return f
}
const _02_45analytics_45global = (e,t)=>{
  useState("sampleFromState", ()=>t.path),
  useState("sampleToState", ()=>e.path)
}
, manifest_45route_45rule = async e=>{
  let t, r;
  const a = ([t,r] = executeAsync(()=>getRouteRules(e.path)),
  t = await t,
  r(),
  t);
  if (a.redirect)
      return hasProtocol(a.redirect, {
          acceptRelative: !0
      }) ? (window.location.href = a.redirect,
      !1) : a.redirect
}
, globalMiddleware = [validate, _01_45states_45global, _02_45analytics_45global, manifest_45route_45rule]
, namedMiddleware = {
  "auth-page": ()=>__vitePreload(()=>import("./CZp8jUjT.js"), __vite__mapDeps([31, 8, 11, 7]), import.meta.url),
  auth: ()=>__vitePreload(()=>import("./HKGoNIjM.js"), __vite__mapDeps([32, 8]), import.meta.url)
};
function createCurrentLocation(e, t, r) {
  const {pathname: a, search: o, hash: l} = t
    , f = e.indexOf("#");
  if (f > -1) {
      const _ = l.includes(e.slice(f)) ? e.slice(f).length : 1;
      let v = l.slice(_);
      return v[0] !== "/" && (v = "/" + v),
      withoutBase(v, "")
  }
  const d = withoutBase(a, e)
    , g = !r || isEqual(d, r, {
      trailingSlash: !0
  }) ? d : r;
  return g + (g.includes("?") ? "" : o) + l
}
const plugin = defineNuxtPlugin({
  name: "nuxt:router",
  enforce: "pre",
  async setup(e) {
      var E, I;
      let t, r, a = useRuntimeConfig().app.baseURL;
      routerOptions.hashMode && !a.includes("#") && (a += "#");
      const o = ((E = routerOptions.history) == null ? void 0 : E.call(routerOptions, a)) ?? (routerOptions.hashMode ? createWebHashHistory(a) : createWebHistory(a))
        , l = ((I = routerOptions.routes) == null ? void 0 : I.call(routerOptions, _routes)) ?? _routes;
      let f;
      const d = createCurrentLocation(a, window.location, e.payload.path)
        , g = createRouter({
          ...routerOptions,
          scrollBehavior: (C,A,T)=>{
              if (A === START_LOCATION_NORMALIZED) {
                  f = T;
                  return
              }
              if (routerOptions.scrollBehavior) {
                  if (g.options.scrollBehavior = routerOptions.scrollBehavior,
                  "scrollRestoration"in window.history) {
                      const w = g.beforeEach(()=>{
                          w(),
                          window.history.scrollRestoration = "manual"
                      }
                      )
                  }
                  return routerOptions.scrollBehavior(C, START_LOCATION_NORMALIZED, f || T)
              }
          }
          ,
          history: o,
          routes: l
      });
      "scrollRestoration"in window.history && (window.history.scrollRestoration = "auto"),
      e.vueApp.use(g);
      const _ = shallowRef(g.currentRoute.value);
      g.afterEach((C,A)=>{
          _.value = A
      }
      ),
      Object.defineProperty(e.vueApp.config.globalProperties, "previousRoute", {
          get: ()=>_.value
      });
      const v = shallowRef(g.resolve(d))
        , S = ()=>{
          v.value = g.currentRoute.value
      }
      ;
      e.hook("page:finish", S),
      g.afterEach((C,A)=>{
          var T, w, M, F;
          ((w = (T = C.matched[0]) == null ? void 0 : T.components) == null ? void 0 : w.default) === ((F = (M = A.matched[0]) == null ? void 0 : M.components) == null ? void 0 : F.default) && S()
      }
      );
      const b = {};
      for (const C in v.value)
          Object.defineProperty(b, C, {
              get: ()=>v.value[C]
          });
      e._route = shallowReactive(b),
      e._middleware = e._middleware || {
          global: [],
          named: {}
      };
      const P = useError();
      try {
          [t,r] = executeAsync(()=>g.isReady()),
          await t,
          r()
      } catch (C) {
          [t,r] = executeAsync(()=>e.runWithContext(()=>showError(C))),
          await t,
          r()
      }
      const x = e.payload.state._layout;
      return g.beforeEach(async(C,A)=>{
          var T;
          await e.callHook("page:loading:start"),
          C.meta = reactive(C.meta),
          e.isHydrating && x && !isReadonly(C.meta.layout) && (C.meta.layout = x),
          e._processingMiddleware = !0;
          {
              const w = new Set([...globalMiddleware, ...e._middleware.global]);
              for (const M of C.matched) {
                  const F = M.meta.middleware;
                  if (F)
                      for (const O of toArray$1(F))
                          w.add(O)
              }
              {
                  const M = await e.runWithContext(()=>getRouteRules(C.path));
                  if (M.appMiddleware)
                      for (const F in M.appMiddleware)
                          M.appMiddleware[F] ? w.add(F) : w.delete(F)
              }
              for (const M of w) {
                  const F = typeof M == "string" ? e._middleware.named[M] || await ((T = namedMiddleware[M]) == null ? void 0 : T.call(namedMiddleware).then($=>$.default || $)) : M;
                  if (!F)
                      throw new Error(`Unknown route middleware: '${M}'.`);
                  const O = await e.runWithContext(()=>F(C, A));
                  if (!e.payload.serverRendered && e.isHydrating && (O === !1 || O instanceof Error)) {
                      const $ = O || createError$1({
                          statusCode: 404,
                          statusMessage: `Page Not Found: ${d}`
                      });
                      return await e.runWithContext(()=>showError($)),
                      !1
                  }
                  if (O !== !0 && (O || O === !1))
                      return O
              }
          }
      }
      ),
      g.onError(async()=>{
          delete e._processingMiddleware,
          await e.callHook("page:loading:end")
      }
      ),
      g.afterEach(async(C,A,T)=>{
          delete e._processingMiddleware,
          !e.isHydrating && P.value && await e.runWithContext(clearError),
          T && await e.callHook("page:loading:end"),
          C.matched.length === 0 && await e.runWithContext(()=>showError(createError$1({
              statusCode: 404,
              fatal: !1,
              statusMessage: `Page not found: ${C.fullPath}`,
              data: {
                  path: C.fullPath
              }
          })))
      }
      ),
      e.hooks.hookOnce("app:created", async()=>{
          try {
              const C = g.resolve(d);
              "name"in C && (C.name = void 0),
              await g.replace({
                  ...C,
                  force: !0
              }),
              g.options.scrollBehavior = routerOptions.scrollBehavior
          } catch (C) {
              await e.runWithContext(()=>showError(C))
          }
      }
      ),
      {
          provide: {
              router: g
          }
      }
  }
})
, requestIdleCallback = globalThis.requestIdleCallback || (e=>{
  const t = Date.now()
    , r = {
      didTimeout: !1,
      timeRemaining: ()=>Math.max(0, 50 - (Date.now() - t))
  };
  return setTimeout(()=>{
      e(r)
  }
  , 1)
}
)
, cancelIdleCallback = globalThis.cancelIdleCallback || (e=>{
  clearTimeout(e)
}
)
, onNuxtReady = e=>{
  const t = useNuxtApp();
  t.isHydrating ? t.hooks.hookOnce("app:suspense:resolve", ()=>{
      requestIdleCallback(e)
  }
  ) : requestIdleCallback(e)
}
, payload_client_b5dW29Gs9J = defineNuxtPlugin({
  name: "nuxt:payload",
  setup(e) {
      useRouter().beforeResolve(async(t,r)=>{
          if (t.path === r.path)
              return;
          const a = await loadPayload(t.path);
          a && Object.assign(e.static.data, a.data)
      }
      ),
      onNuxtReady(()=>{
          var t;
          e.hooks.hook("link:prefetch", async r=>{
              parseURL$1(r).protocol || await loadPayload(r)
          }
          ),
          ((t = navigator.connection) == null ? void 0 : t.effectiveType) !== "slow-2g" && setTimeout(getAppManifest, 1e3)
      }
      )
  }
})
, check_outdated_build_client_9zpfJQa9VH = defineNuxtPlugin(e=>{
  let t;
  async function r() {
      const a = await getAppManifest();
      t && clearTimeout(t),
      t = setTimeout(r, 1e3 * 60 * 60);
      const o = await $fetch(buildAssetsURL("builds/latest.json") + `?${Date.now()}`);
      o.id !== a.id && e.hooks.callHook("app:manifest:update", o)
  }
  onNuxtReady(()=>{
      t = setTimeout(r, 1e3 * 60 * 60)
  }
  )
}
)
, components_plugin_KR1HBZs4kY = defineNuxtPlugin({
  name: "nuxt:global-components"
})
, layouts = {
  default: ()=>__vitePreload(()=>import("./D_jCLv_g.js"), __vite__mapDeps([33, 2, 16, 11, 7, 8, 34]), import.meta.url).then(e=>e.default || e)
}
, prefetch_client_n7DwbozCHE = defineNuxtPlugin({
  name: "nuxt:prefetch",
  setup(e) {
      const t = useRouter();
      e.hooks.hook("app:mounted", ()=>{
          t.beforeEach(async r=>{
              var o;
              const a = (o = r == null ? void 0 : r.meta) == null ? void 0 : o.layout;
              a && typeof layouts[a] == "function" && await layouts[a]()
          }
          )
      }
      ),
      e.hooks.hook("link:prefetch", r=>{
          if (hasProtocol(r))
              return;
          const a = t.resolve(r);
          if (!a)
              return;
          const o = a.meta.layout;
          let l = toArray$1(a.meta.middleware);
          l = l.filter(f=>typeof f == "string");
          for (const f of l)
              typeof namedMiddleware[f] == "function" && namedMiddleware[f]();
          o && typeof layouts[o] == "function" && layouts[o]()
      }
      )
  }
});
async function preloadRouteComponents(e, t=useRouter()) {
  const {path: r, matched: a} = t.resolve(e);
  if (!a.length || (t._routePreloaded || (t._routePreloaded = new Set),
  t._routePreloaded.has(r)))
      return;
  const o = t._preloadPromises = t._preloadPromises || [];
  if (o.length > 4)
      return Promise.all(o).then(()=>preloadRouteComponents(e, t));
  t._routePreloaded.add(r);
  const l = a.map(f=>{
      var d;
      return (d = f.components) == null ? void 0 : d.default
  }
  ).filter(f=>typeof f == "function");
  for (const f of l) {
      const d = Promise.resolve(f()).catch(()=>{}
      ).finally(()=>o.splice(o.indexOf(d)));
      o.push(d)
  }
  await Promise.all(o)
}
function reloadNuxtApp(e={}) {
  const t = e.path || window.location.pathname;
  let r = {};
  try {
      r = destr(sessionStorage.getItem("nuxt:reload") || "{}")
  } catch {}
  if (e.force || (r == null ? void 0 : r.path) !== t || (r == null ? void 0 : r.expires) < Date.now()) {
      try {
          sessionStorage.setItem("nuxt:reload", JSON.stringify({
              path: t,
              expires: Date.now() + (e.ttl ?? 1e4)
          }))
      } catch {}
      if (e.persistState)
          try {
              sessionStorage.setItem("nuxt:reload:state", JSON.stringify({
                  state: useNuxtApp().payload.state
              }))
          } catch {}
      window.location.pathname !== t ? window.location.href = t : window.location.reload()
  }
}
const firstNonUndefined = (...e)=>e.find(t=>t !== void 0);
function defineNuxtLink(e) {
  const t = e.componentName || "NuxtLink";
  function r(a, o) {
      if (!a || e.trailingSlash !== "append" && e.trailingSlash !== "remove")
          return a;
      if (typeof a == "string")
          return applyTrailingSlashBehavior(a, e.trailingSlash);
      const l = "path"in a && a.path !== void 0 ? a.path : o(a).path;
      return {
          ...a,
          name: void 0,
          path: applyTrailingSlashBehavior(l, e.trailingSlash)
      }
  }
  return defineComponent({
      name: t,
      props: {
          to: {
              type: [String, Object],
              default: void 0,
              required: !1
          },
          href: {
              type: [String, Object],
              default: void 0,
              required: !1
          },
          target: {
              type: String,
              default: void 0,
              required: !1
          },
          rel: {
              type: String,
              default: void 0,
              required: !1
          },
          noRel: {
              type: Boolean,
              default: void 0,
              required: !1
          },
          prefetch: {
              type: Boolean,
              default: void 0,
              required: !1
          },
          noPrefetch: {
              type: Boolean,
              default: void 0,
              required: !1
          },
          activeClass: {
              type: String,
              default: void 0,
              required: !1
          },
          exactActiveClass: {
              type: String,
              default: void 0,
              required: !1
          },
          prefetchedClass: {
              type: String,
              default: void 0,
              required: !1
          },
          replace: {
              type: Boolean,
              default: void 0,
              required: !1
          },
          ariaCurrentValue: {
              type: String,
              default: void 0,
              required: !1
          },
          external: {
              type: Boolean,
              default: void 0,
              required: !1
          },
          custom: {
              type: Boolean,
              default: void 0,
              required: !1
          }
      },
      setup(a, {slots: o}) {
          const l = useRouter()
            , f = useRuntimeConfig()
            , d = computed(()=>{
              const x = a.to || a.href || "";
              return r(x, l.resolve)
          }
          )
            , g = computed(()=>typeof d.value == "string" && hasProtocol(d.value, {
              acceptRelative: !0
          }))
            , _ = computed(()=>a.target && a.target !== "_self")
            , v = computed(()=>a.external || _.value ? !0 : typeof d.value == "object" ? !1 : d.value === "" || g.value)
            , S = ref(!1)
            , b = ref(null)
            , P = x=>{
              var E;
              b.value = a.custom ? (E = x == null ? void 0 : x.$el) == null ? void 0 : E.nextElementSibling : x == null ? void 0 : x.$el
          }
          ;
          if (a.prefetch !== !1 && a.noPrefetch !== !0 && a.target !== "_blank" && !isSlowConnection()) {
              const E = useNuxtApp();
              let I, C = null;
              onMounted(()=>{
                  const A = useObserver();
                  onNuxtReady(()=>{
                      I = requestIdleCallback(()=>{
                          var T;
                          (T = b == null ? void 0 : b.value) != null && T.tagName && (C = A.observe(b.value, async()=>{
                              C == null || C(),
                              C = null;
                              const w = typeof d.value == "string" ? d.value : l.resolve(d.value).fullPath;
                              await Promise.all([E.hooks.callHook("link:prefetch", w).catch(()=>{}
                              ), !v.value && preloadRouteComponents(d.value, l).catch(()=>{}
                              )]),
                              S.value = !0
                          }
                          ))
                      }
                      )
                  }
                  )
              }
              ),
              onBeforeUnmount(()=>{
                  I && cancelIdleCallback(I),
                  C == null || C(),
                  C = null
              }
              )
          }
          return ()=>{
              var C, A;
              if (!v.value) {
                  const T = {
                      ref: P,
                      to: d.value,
                      activeClass: a.activeClass || e.activeClass,
                      exactActiveClass: a.exactActiveClass || e.exactActiveClass,
                      replace: a.replace,
                      ariaCurrentValue: a.ariaCurrentValue,
                      custom: a.custom
                  };
                  return a.custom || (S.value && (T.class = a.prefetchedClass || e.prefetchedClass),
                  T.rel = a.rel || void 0),
                  h(resolveComponent("RouterLink"), T, o.default)
              }
              const x = typeof d.value == "object" ? ((C = l.resolve(d.value)) == null ? void 0 : C.href) ?? null : d.value && !a.external && !g.value ? r(joinURL(f.app.baseURL, d.value), l.resolve) : d.value || null
                , E = a.target || null
                , I = firstNonUndefined(a.noRel ? "" : a.rel, e.externalRelAttribute, g.value || _.value ? "noopener noreferrer" : "") || null;
              if (a.custom) {
                  if (!o.default)
                      return null;
                  const T = ()=>navigateTo(x, {
                      replace: a.replace,
                      external: a.external
                  });
                  return o.default({
                      href: x,
                      navigate: T,
                      get route() {
                          if (!x)
                              return;
                          const w = parseURL$1(x);
                          return {
                              path: w.pathname,
                              fullPath: w.pathname,
                              get query() {
                                  return parseQuery$1(w.search)
                              },
                              hash: w.hash,
                              params: {},
                              name: void 0,
                              matched: [],
                              redirectedFrom: void 0,
                              meta: {},
                              href: x
                          }
                      },
                      rel: I,
                      target: E,
                      isExternal: v.value,
                      isActive: !1,
                      isExactActive: !1
                  })
              }
              return h("a", {
                  ref: b,
                  href: x,
                  rel: I,
                  target: E
              }, (A = o.default) == null ? void 0 : A.call(o))
          }
      }
  })
}
const __nuxt_component_0$1 = defineNuxtLink(nuxtLinkDefaults);
function applyTrailingSlashBehavior(e, t) {
  const r = t === "append" ? withTrailingSlash : withoutTrailingSlash;
  return hasProtocol(e) && !e.startsWith("http") ? e : r(e, !0)
}
function useObserver() {
  const e = useNuxtApp();
  if (e._observer)
      return e._observer;
  let t = null;
  const r = new Map
    , a = (l,f)=>(t || (t = new IntersectionObserver(d=>{
      for (const g of d) {
          const _ = r.get(g.target);
          (g.isIntersecting || g.intersectionRatio > 0) && _ && _()
      }
  }
  )),
  r.set(l, f),
  t.observe(l),
  ()=>{
      r.delete(l),
      t.unobserve(l),
      r.size === 0 && (t.disconnect(),
      t = null)
  }
  );
  return e._observer = {
      observe: a
  }
}
function isSlowConnection() {
  const e = navigator.connection;
  return !!(e && (e.saveData || /2g/.test(e.effectiveType)))
}
var m = /^GTM-[0-9A-Z]+$/;
function s(e) {
  if (typeof e != "string" || !m.test(e)) {
      let t = String(e).toUpperCase().replace(/.*-|[^0-9A-Z]/g, "")
        , r = t.length === 0 ? "" : ` Did you mean 'GTM-${t}'?`;
      throw new Error(`'${e}' is not a valid GTM-ID (${m}).${r}`)
  }
}
function n(e, t="dataLayer") {
  return e[t] || (e[t] = []),
  e[t]
}
function p(e, t) {
  let r = document
    , a = r.createElement("script")
    , o = _=>{
      var v;
      (v = t.onReady) == null || v.call(t, {
          id: e,
          script: a
      }),
      a.removeEventListener("load", o)
  }
  ;
  a.addEventListener("load", o);
  let l = t.dataLayerName ?? "dataLayer";
  if (n(window, l).push({
      event: "gtm.js",
      "gtm.start": new Date().getTime()
  }),
  !e)
      return a;
  a.async = !t.defer,
  a.defer = !!(t.defer || t.compatibility),
  t.nonce && a.setAttribute("nonce", t.nonce),
  t.scriptType && (a.type = t.scriptType);
  let f = new URLSearchParams({
      id: e,
      ...t.dataLayerName ? {
          l: t.dataLayerName
      } : {},
      ...t.queryParams ?? {}
  })
    , d = t.source ?? "https://www.googletagmanager.com/gtm.js";
  a.src = `${d}?${f}`;
  let g = t.parentElement ?? r.body;
  if (typeof (g == null ? void 0 : g.appendChild) != "function")
      throw new Error("parentElement must be a DOM element");
  return g.appendChild(a),
  a
}
function y(e="https://www.googletagmanager.com/gtm.js") {
  return Array.from(document.getElementsByTagName("script")).some(t=>t.src.includes(e))
}
var u = class {
  constructor(e) {
      pt(this, "id");
      pt(this, "options");
      pt(this, "scriptElements", []);
      pt(this, "isInBrowserContext", ()=>typeof window < "u");
      if (Array.isArray(e.id))
          for (let t of e.id)
              s(typeof t == "string" ? t : t.id);
      else
          s(e.id);
      this.id = e.id,
      this.options = {
          enabled: !0,
          debug: !1,
          loadScript: !0,
          defer: !1,
          compatibility: !1,
          dataLayerName: "dataLayer",
          ...e
      },
      delete this.options.id
  }
  enabled() {
      return this.options.enabled ?? !0
  }
  enable(e=!0, t) {
      if (this.options.enabled = e,
      this.isInBrowserContext() && e && !y(t) && this.options.loadScript)
          if (Array.isArray(this.id))
              this.id.forEach(r=>{
                  let a;
                  typeof r == "string" ? a = p(r, {
                      ...this.options
                  }) : a = p(r.id, {
                      ...this.options,
                      queryParams: r.queryParams
                  }),
                  this.scriptElements.push(a)
              }
              );
          else {
              let r = p(this.id, {
                  ...this.options
              });
              this.scriptElements.push(r)
          }
  }
  debugEnabled() {
      return this.options.debug ?? !1
  }
  debug(e) {
      this.options.debug = e
  }
  dataLayer() {
      return this.isInBrowserContext() && this.options.enabled ? n(window, this.options.dataLayerName) : !1
  }
  trackView(e, t, r={}) {
      let a = this.isInBrowserContext() && (this.options.enabled ?? !1);
      this.options.debug && console.log(`[GTM-Support${a ? "" : "(disabled)"}]: Dispatching TrackView`, {
          screenName: e,
          path: t
      }),
      a && n(window, this.options.dataLayerName).push({
          ...r,
          event: this.options.trackViewEventProperty ?? "content-view",
          "content-name": t,
          "content-view-name": e
      })
  }
  trackEvent({event: e, category: t=null, action: r=null, label: a=null, value: o=null, noninteraction: l=!1, ...f}={}) {
      let d = this.isInBrowserContext() && (this.options.enabled ?? !1);
      this.options.debug && console.log(`[GTM-Support${d ? "" : "(disabled)"}]: Dispatching event`, {
          event: e,
          category: t,
          action: r,
          label: a,
          value: o,
          ...f
      }),
      d && n(window, this.options.dataLayerName).push({
          event: e ?? "interaction",
          target: t,
          action: r,
          "target-properties": a,
          value: o,
          "interaction-type": l,
          ...f
      })
  }
  push(e) {
      let t = this.isInBrowserContext() && (this.options.enabled ?? !1);
      this.options.debug && console.log(`[GTM-Support${t ? "" : "(disabled)"}]: Dispatching event`, e),
      t && n(window, this.options.dataLayerName).push(e)
  }
}
, i;
function c(e, t={
  id: ""
}) {
  t = {
      trackOnNextTick: !1,
      ...t
  },
  i = new u(t),
  e.config.globalProperties.$gtm = i,
  i.isInBrowserContext() && (t.vueRouter && G(e, t.vueRouter, t.ignoredViews, t.trackOnNextTick, t.vueRouterAdditionalEventData),
  i.options.enabled && i.options.loadScript && (Array.isArray(t.id) ? t.id.forEach(r=>{
      if (typeof r == "string")
          p(r, t);
      else {
          let a = {
              ...t
          };
          r.queryParams != null && (a.queryParams = {
              ...a.queryParams,
              ...r.queryParams
          }),
          p(r.id, a)
      }
  }
  ) : p(t.id, t))),
  e.provide("gtm", t)
}
function G(e, t, r=[], a, o=()=>({})) {
  function l(f, d) {
      return f instanceof Error ? !!(f.type & d) : !1
  }
  t.afterEach(async(f,d,g)=>{
      var b, P, x;
      if (typeof f.name != "string" || Array.isArray(r) && r.includes(f.name) || typeof r == "function" && r(f, d))
          return;
      let _ = f.meta && typeof f.meta.gtm == "string" && f.meta.gtm ? f.meta.gtm : f.name;
      l(g, 4) ? i != null && i.debugEnabled() && console.log(`[VueGtm]: '${_}' not tracked due to navigation aborted`) : l(g, 8) && (i != null && i.debugEnabled()) && console.log(`[VueGtm]: '${_}' not tracked due to navigation cancelled`);
      let v = {
          ...await o(f, d),
          ...(b = f.meta) == null ? void 0 : b.gtmAdditionalEventData
      }
        , S = ((x = (P = t.options) == null ? void 0 : P.history) == null ? void 0 : x.base) ?? "";
      S.endsWith("/") || (S += "/"),
      S += f.fullPath.startsWith("/") ? f.fullPath.substring(1) : f.fullPath,
      a ? nextTick(()=>{
          i == null || i.trackView(_, S, v)
      }
      ) : i == null || i.trackView(_, S, v)
  }
  )
}
function N(e) {
  return {
      install: t=>c(t, e)
  }
}
const plugin_KGfaXjLYE1 = defineNuxtPlugin(e=>{
  {
      const t = e.$config.public.gtm
        , r = useRouter()
        , a = {
          ...t,
          vueRouter: t.enableRouterSync && r ? r : void 0
      };
      e.vueApp.use(N(a))
  }
}
);
function gtag(...e) {
  var t;
  (t = window.dataLayer) == null || t.push(arguments)
}
function initGtag({tags: e}) {
  window.dataLayer = window.dataLayer || [];
  for (const t of e)
      for (const r of t.initCommands ?? [])
          gtag(...r);
  gtag("js", new Date);
  for (const t of e)
      gtag("config", t.id, t.config)
}
function resolveTags(e) {
  const t = toRaw(e)
    , r = t.tags.filter(Boolean).map(a=>typeof a == "string" ? {
      id: a
  } : a);
  if (e.id) {
      const {id: a, config: o, initCommands: l} = t;
      r.unshift({
          id: a,
          config: o,
          initCommands: l
      })
  }
  return r
}
const plugin_client_VfNkkwGPj6 = defineNuxtPlugin({
  parallel: !0,
  setup() {
      const e = useRuntimeConfig().public.gtag
        , t = resolveTags(e);
      if (!t.length || (initGtag({
          tags: t
      }),
      !e.enabled))
          return;
      const r = e.loadingStrategy === "async" ? "async" : "defer";
      useHead({
          script: [{
              src: withQuery(e.url, {
                  id: t[0].id
              }),
              [r]: !0,
              "data-gtag": ""
          }]
      })
  }
})
, chunk_reload_client_gju9pz4YE3 = defineNuxtPlugin({
  name: "nuxt:chunk-reload",
  setup(e) {
      const t = useRouter()
        , r = useRuntimeConfig()
        , a = new Set;
      t.beforeEach(()=>{
          a.clear()
      }
      ),
      e.hook("app:chunkError", ({error: l})=>{
          a.add(l)
      }
      );
      function o(l) {
          const d = "href"in l && l.href[0] === "#" ? r.app.baseURL + l.href : joinURL(r.app.baseURL, l.fullPath);
          reloadNuxtApp({
              path: d,
              persistState: !0
          })
      }
      e.hook("app:manifest:update", ()=>{
          t.beforeResolve(o)
      }
      ),
      t.onError((l,f)=>{
          a.has(l) && o(f)
      }
      )
  }
});
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
}
var lottie$1 = {
  exports: {}
};
(function(module, exports) {
  typeof navigator < "u" && function(e, t) {
      module.exports = t()
  }(commonjsGlobal, function() {
      var svgNS = "http://www.w3.org/2000/svg"
        , locationHref = ""
        , _useWebWorker = !1
        , initialDefaultFrame = -999999
        , setWebWorker = function(t) {
          _useWebWorker = !!t
      }
        , getWebWorker = function() {
          return _useWebWorker
      }
        , setLocationHref = function(t) {
          locationHref = t
      }
        , getLocationHref = function() {
          return locationHref
      };
      function createTag(e) {
          return document.createElement(e)
      }
      function extendPrototype(e, t) {
          var r, a = e.length, o;
          for (r = 0; r < a; r += 1) {
              o = e[r].prototype;
              for (var l in o)
                  Object.prototype.hasOwnProperty.call(o, l) && (t.prototype[l] = o[l])
          }
      }
      function getDescriptor(e, t) {
          return Object.getOwnPropertyDescriptor(e, t)
      }
      function createProxyFunction(e) {
          function t() {}
          return t.prototype = e,
          t
      }
      var audioControllerFactory = function() {
          function e(t) {
              this.audios = [],
              this.audioFactory = t,
              this._volume = 1,
              this._isMuted = !1
          }
          return e.prototype = {
              addAudio: function(r) {
                  this.audios.push(r)
              },
              pause: function() {
                  var r, a = this.audios.length;
                  for (r = 0; r < a; r += 1)
                      this.audios[r].pause()
              },
              resume: function() {
                  var r, a = this.audios.length;
                  for (r = 0; r < a; r += 1)
                      this.audios[r].resume()
              },
              setRate: function(r) {
                  var a, o = this.audios.length;
                  for (a = 0; a < o; a += 1)
                      this.audios[a].setRate(r)
              },
              createAudio: function(r) {
                  return this.audioFactory ? this.audioFactory(r) : window.Howl ? new window.Howl({
                      src: [r]
                  }) : {
                      isPlaying: !1,
                      play: function() {
                          this.isPlaying = !0
                      },
                      seek: function() {
                          this.isPlaying = !1
                      },
                      playing: function() {},
                      rate: function() {},
                      setVolume: function() {}
                  }
              },
              setAudioFactory: function(r) {
                  this.audioFactory = r
              },
              setVolume: function(r) {
                  this._volume = r,
                  this._updateVolume()
              },
              mute: function() {
                  this._isMuted = !0,
                  this._updateVolume()
              },
              unmute: function() {
                  this._isMuted = !1,
                  this._updateVolume()
              },
              getVolume: function() {
                  return this._volume
              },
              _updateVolume: function() {
                  var r, a = this.audios.length;
                  for (r = 0; r < a; r += 1)
                      this.audios[r].volume(this._volume * (this._isMuted ? 0 : 1))
              }
          },
          function() {
              return new e
          }
      }()
        , createTypedArray = function() {
          function e(r, a) {
              var o = 0, l = [], f;
              switch (r) {
              case "int16":
              case "uint8c":
                  f = 1;
                  break;
              default:
                  f = 1.1;
                  break
              }
              for (o = 0; o < a; o += 1)
                  l.push(f);
              return l
          }
          function t(r, a) {
              return r === "float32" ? new Float32Array(a) : r === "int16" ? new Int16Array(a) : r === "uint8c" ? new Uint8ClampedArray(a) : e(r, a)
          }
          return typeof Uint8ClampedArray == "function" && typeof Float32Array == "function" ? t : e
      }();
      function createSizedArray(e) {
          return Array.apply(null, {
              length: e
          })
      }
      function _typeof$6(e) {
          "@babel/helpers - typeof";
          return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$6 = function(r) {
              return typeof r
          }
          : _typeof$6 = function(r) {
              return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r
          }
          ,
          _typeof$6(e)
      }
      var subframeEnabled = !0
        , expressionsPlugin = null
        , expressionsInterfaces = null
        , idPrefix$1 = ""
        , isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent)
        , bmPow = Math.pow
        , bmSqrt = Math.sqrt
        , bmFloor = Math.floor
        , bmMax = Math.max
        , bmMin = Math.min
        , BMMath = {};
      (function() {
          var e = ["abs", "acos", "acosh", "asin", "asinh", "atan", "atanh", "atan2", "ceil", "cbrt", "expm1", "clz32", "cos", "cosh", "exp", "floor", "fround", "hypot", "imul", "log", "log1p", "log2", "log10", "max", "min", "pow", "random", "round", "sign", "sin", "sinh", "sqrt", "tan", "tanh", "trunc", "E", "LN10", "LN2", "LOG10E", "LOG2E", "PI", "SQRT1_2", "SQRT2"], t, r = e.length;
          for (t = 0; t < r; t += 1)
              BMMath[e[t]] = Math[e[t]]
      }
      )(),
      BMMath.random = Math.random,
      BMMath.abs = function(e) {
          var t = _typeof$6(e);
          if (t === "object" && e.length) {
              var r = createSizedArray(e.length), a, o = e.length;
              for (a = 0; a < o; a += 1)
                  r[a] = Math.abs(e[a]);
              return r
          }
          return Math.abs(e)
      }
      ;
      var defaultCurveSegments = 150
        , degToRads = Math.PI / 180
        , roundCorner = .5519;
      function styleDiv(e) {
          e.style.position = "absolute",
          e.style.top = 0,
          e.style.left = 0,
          e.style.display = "block",
          e.style.transformOrigin = "0 0",
          e.style.webkitTransformOrigin = "0 0",
          e.style.backfaceVisibility = "visible",
          e.style.webkitBackfaceVisibility = "visible",
          e.style.transformStyle = "preserve-3d",
          e.style.webkitTransformStyle = "preserve-3d",
          e.style.mozTransformStyle = "preserve-3d"
      }
      function BMEnterFrameEvent(e, t, r, a) {
          this.type = e,
          this.currentTime = t,
          this.totalTime = r,
          this.direction = a < 0 ? -1 : 1
      }
      function BMCompleteEvent(e, t) {
          this.type = e,
          this.direction = t < 0 ? -1 : 1
      }
      function BMCompleteLoopEvent(e, t, r, a) {
          this.type = e,
          this.currentLoop = r,
          this.totalLoops = t,
          this.direction = a < 0 ? -1 : 1
      }
      function BMSegmentStartEvent(e, t, r) {
          this.type = e,
          this.firstFrame = t,
          this.totalFrames = r
      }
      function BMDestroyEvent(e, t) {
          this.type = e,
          this.target = t
      }
      function BMRenderFrameErrorEvent(e, t) {
          this.type = "renderFrameError",
          this.nativeError = e,
          this.currentTime = t
      }
      function BMConfigErrorEvent(e) {
          this.type = "configError",
          this.nativeError = e
      }
      var createElementID = function() {
          var e = 0;
          return function() {
              return e += 1,
              idPrefix$1 + "__lottie_element_" + e
          }
      }();
      function HSVtoRGB(e, t, r) {
          var a, o, l, f, d, g, _, v;
          switch (f = Math.floor(e * 6),
          d = e * 6 - f,
          g = r * (1 - t),
          _ = r * (1 - d * t),
          v = r * (1 - (1 - d) * t),
          f % 6) {
          case 0:
              a = r,
              o = v,
              l = g;
              break;
          case 1:
              a = _,
              o = r,
              l = g;
              break;
          case 2:
              a = g,
              o = r,
              l = v;
              break;
          case 3:
              a = g,
              o = _,
              l = r;
              break;
          case 4:
              a = v,
              o = g,
              l = r;
              break;
          case 5:
              a = r,
              o = g,
              l = _;
              break
          }
          return [a, o, l]
      }
      function RGBtoHSV(e, t, r) {
          var a = Math.max(e, t, r), o = Math.min(e, t, r), l = a - o, f, d = a === 0 ? 0 : l / a, g = a / 255;
          switch (a) {
          case o:
              f = 0;
              break;
          case e:
              f = t - r + l * (t < r ? 6 : 0),
              f /= 6 * l;
              break;
          case t:
              f = r - e + l * 2,
              f /= 6 * l;
              break;
          case r:
              f = e - t + l * 4,
              f /= 6 * l;
              break
          }
          return [f, d, g]
      }
      function addSaturationToRGB(e, t) {
          var r = RGBtoHSV(e[0] * 255, e[1] * 255, e[2] * 255);
          return r[1] += t,
          r[1] > 1 ? r[1] = 1 : r[1] <= 0 && (r[1] = 0),
          HSVtoRGB(r[0], r[1], r[2])
      }
      function addBrightnessToRGB(e, t) {
          var r = RGBtoHSV(e[0] * 255, e[1] * 255, e[2] * 255);
          return r[2] += t,
          r[2] > 1 ? r[2] = 1 : r[2] < 0 && (r[2] = 0),
          HSVtoRGB(r[0], r[1], r[2])
      }
      function addHueToRGB(e, t) {
          var r = RGBtoHSV(e[0] * 255, e[1] * 255, e[2] * 255);
          return r[0] += t / 360,
          r[0] > 1 ? r[0] -= 1 : r[0] < 0 && (r[0] += 1),
          HSVtoRGB(r[0], r[1], r[2])
      }
      var rgbToHex = function() {
          var e = [], t, r;
          for (t = 0; t < 256; t += 1)
              r = t.toString(16),
              e[t] = r.length === 1 ? "0" + r : r;
          return function(a, o, l) {
              return a < 0 && (a = 0),
              o < 0 && (o = 0),
              l < 0 && (l = 0),
              "#" + e[a] + e[o] + e[l]
          }
      }()
        , setSubframeEnabled = function(t) {
          subframeEnabled = !!t
      }
        , getSubframeEnabled = function() {
          return subframeEnabled
      }
        , setExpressionsPlugin = function(t) {
          expressionsPlugin = t
      }
        , getExpressionsPlugin = function() {
          return expressionsPlugin
      }
        , setExpressionInterfaces = function(t) {
          expressionsInterfaces = t
      }
        , getExpressionInterfaces = function() {
          return expressionsInterfaces
      }
        , setDefaultCurveSegments = function(t) {
          defaultCurveSegments = t
      }
        , getDefaultCurveSegments = function() {
          return defaultCurveSegments
      }
        , setIdPrefix = function(t) {
          idPrefix$1 = t
      };
      function createNS(e) {
          return document.createElementNS(svgNS, e)
      }
      function _typeof$5(e) {
          "@babel/helpers - typeof";
          return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$5 = function(r) {
              return typeof r
          }
          : _typeof$5 = function(r) {
              return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r
          }
          ,
          _typeof$5(e)
      }
      var dataManager = function() {
          var e = 1, t = [], r, a, o = {
              onmessage: function() {},
              postMessage: function(P) {
                  r({
                      data: P
                  })
              }
          }, l = {
              postMessage: function(P) {
                  o.onmessage({
                      data: P
                  })
              }
          };
          function f(b) {
              if (window.Worker && window.Blob && getWebWorker()) {
                  var P = new Blob(["var _workerSelf = self; self.onmessage = ", b.toString()],{
                      type: "text/javascript"
                  })
                    , x = URL.createObjectURL(P);
                  return new Worker(x)
              }
              return r = b,
              o
          }
          function d() {
              a || (a = f(function(P) {
                  function x() {
                      function I(X, D) {
                          var B, R, L = X.length, V, q, oe, ye;
                          for (R = 0; R < L; R += 1)
                              if (B = X[R],
                              "ks"in B && !B.completed) {
                                  if (B.completed = !0,
                                  B.hasMask) {
                                      var pe = B.masksProperties;
                                      for (q = pe.length,
                                      V = 0; V < q; V += 1)
                                          if (pe[V].pt.k.i)
                                              M(pe[V].pt.k);
                                          else
                                              for (ye = pe[V].pt.k.length,
                                              oe = 0; oe < ye; oe += 1)
                                                  pe[V].pt.k[oe].s && M(pe[V].pt.k[oe].s[0]),
                                                  pe[V].pt.k[oe].e && M(pe[V].pt.k[oe].e[0])
                                  }
                                  B.ty === 0 ? (B.layers = T(B.refId, D),
                                  I(B.layers, D)) : B.ty === 4 ? w(B.shapes) : B.ty === 5 && Z(B)
                              }
                      }
                      function C(X, D) {
                          if (X) {
                              var B = 0
                                , R = X.length;
                              for (B = 0; B < R; B += 1)
                                  X[B].t === 1 && (X[B].data.layers = T(X[B].data.refId, D),
                                  I(X[B].data.layers, D))
                          }
                      }
                      function A(X, D) {
                          for (var B = 0, R = D.length; B < R; ) {
                              if (D[B].id === X)
                                  return D[B];
                              B += 1
                          }
                          return null
                      }
                      function T(X, D) {
                          var B = A(X, D);
                          return B ? B.layers.__used ? JSON.parse(JSON.stringify(B.layers)) : (B.layers.__used = !0,
                          B.layers) : null
                      }
                      function w(X) {
                          var D, B = X.length, R, L;
                          for (D = B - 1; D >= 0; D -= 1)
                              if (X[D].ty === "sh")
                                  if (X[D].ks.k.i)
                                      M(X[D].ks.k);
                                  else
                                      for (L = X[D].ks.k.length,
                                      R = 0; R < L; R += 1)
                                          X[D].ks.k[R].s && M(X[D].ks.k[R].s[0]),
                                          X[D].ks.k[R].e && M(X[D].ks.k[R].e[0]);
                              else
                                  X[D].ty === "gr" && w(X[D].it)
                      }
                      function M(X) {
                          var D, B = X.i.length;
                          for (D = 0; D < B; D += 1)
                              X.i[D][0] += X.v[D][0],
                              X.i[D][1] += X.v[D][1],
                              X.o[D][0] += X.v[D][0],
                              X.o[D][1] += X.v[D][1]
                      }
                      function F(X, D) {
                          var B = D ? D.split(".") : [100, 100, 100];
                          return X[0] > B[0] ? !0 : B[0] > X[0] ? !1 : X[1] > B[1] ? !0 : B[1] > X[1] ? !1 : X[2] > B[2] ? !0 : B[2] > X[2] ? !1 : null
                      }
                      var O = function() {
                          var X = [4, 4, 14];
                          function D(R) {
                              var L = R.t.d;
                              R.t.d = {
                                  k: [{
                                      s: L,
                                      t: 0
                                  }]
                              }
                          }
                          function B(R) {
                              var L, V = R.length;
                              for (L = 0; L < V; L += 1)
                                  R[L].ty === 5 && D(R[L])
                          }
                          return function(R) {
                              if (F(X, R.v) && (B(R.layers),
                              R.assets)) {
                                  var L, V = R.assets.length;
                                  for (L = 0; L < V; L += 1)
                                      R.assets[L].layers && B(R.assets[L].layers)
                              }
                          }
                      }()
                        , $ = function() {
                          var X = [4, 7, 99];
                          return function(D) {
                              if (D.chars && !F(X, D.v)) {
                                  var B, R = D.chars.length;
                                  for (B = 0; B < R; B += 1) {
                                      var L = D.chars[B];
                                      L.data && L.data.shapes && (w(L.data.shapes),
                                      L.data.ip = 0,
                                      L.data.op = 99999,
                                      L.data.st = 0,
                                      L.data.sr = 1,
                                      L.data.ks = {
                                          p: {
                                              k: [0, 0],
                                              a: 0
                                          },
                                          s: {
                                              k: [100, 100],
                                              a: 0
                                          },
                                          a: {
                                              k: [0, 0],
                                              a: 0
                                          },
                                          r: {
                                              k: 0,
                                              a: 0
                                          },
                                          o: {
                                              k: 100,
                                              a: 0
                                          }
                                      },
                                      D.chars[B].t || (L.data.shapes.push({
                                          ty: "no"
                                      }),
                                      L.data.shapes[0].it.push({
                                          p: {
                                              k: [0, 0],
                                              a: 0
                                          },
                                          s: {
                                              k: [100, 100],
                                              a: 0
                                          },
                                          a: {
                                              k: [0, 0],
                                              a: 0
                                          },
                                          r: {
                                              k: 0,
                                              a: 0
                                          },
                                          o: {
                                              k: 100,
                                              a: 0
                                          },
                                          sk: {
                                              k: 0,
                                              a: 0
                                          },
                                          sa: {
                                              k: 0,
                                              a: 0
                                          },
                                          ty: "tr"
                                      })))
                                  }
                              }
                          }
                      }()
                        , j = function() {
                          var X = [5, 7, 15];
                          function D(R) {
                              var L = R.t.p;
                              typeof L.a == "number" && (L.a = {
                                  a: 0,
                                  k: L.a
                              }),
                              typeof L.p == "number" && (L.p = {
                                  a: 0,
                                  k: L.p
                              }),
                              typeof L.r == "number" && (L.r = {
                                  a: 0,
                                  k: L.r
                              })
                          }
                          function B(R) {
                              var L, V = R.length;
                              for (L = 0; L < V; L += 1)
                                  R[L].ty === 5 && D(R[L])
                          }
                          return function(R) {
                              if (F(X, R.v) && (B(R.layers),
                              R.assets)) {
                                  var L, V = R.assets.length;
                                  for (L = 0; L < V; L += 1)
                                      R.assets[L].layers && B(R.assets[L].layers)
                              }
                          }
                      }()
                        , K = function() {
                          var X = [4, 1, 9];
                          function D(R) {
                              var L, V = R.length, q, oe;
                              for (L = 0; L < V; L += 1)
                                  if (R[L].ty === "gr")
                                      D(R[L].it);
                                  else if (R[L].ty === "fl" || R[L].ty === "st")
                                      if (R[L].c.k && R[L].c.k[0].i)
                                          for (oe = R[L].c.k.length,
                                          q = 0; q < oe; q += 1)
                                              R[L].c.k[q].s && (R[L].c.k[q].s[0] /= 255,
                                              R[L].c.k[q].s[1] /= 255,
                                              R[L].c.k[q].s[2] /= 255,
                                              R[L].c.k[q].s[3] /= 255),
                                              R[L].c.k[q].e && (R[L].c.k[q].e[0] /= 255,
                                              R[L].c.k[q].e[1] /= 255,
                                              R[L].c.k[q].e[2] /= 255,
                                              R[L].c.k[q].e[3] /= 255);
                                      else
                                          R[L].c.k[0] /= 255,
                                          R[L].c.k[1] /= 255,
                                          R[L].c.k[2] /= 255,
                                          R[L].c.k[3] /= 255
                          }
                          function B(R) {
                              var L, V = R.length;
                              for (L = 0; L < V; L += 1)
                                  R[L].ty === 4 && D(R[L].shapes)
                          }
                          return function(R) {
                              if (F(X, R.v) && (B(R.layers),
                              R.assets)) {
                                  var L, V = R.assets.length;
                                  for (L = 0; L < V; L += 1)
                                      R.assets[L].layers && B(R.assets[L].layers)
                              }
                          }
                      }()
                        , Y = function() {
                          var X = [4, 4, 18];
                          function D(R) {
                              var L, V = R.length, q, oe;
                              for (L = V - 1; L >= 0; L -= 1)
                                  if (R[L].ty === "sh")
                                      if (R[L].ks.k.i)
                                          R[L].ks.k.c = R[L].closed;
                                      else
                                          for (oe = R[L].ks.k.length,
                                          q = 0; q < oe; q += 1)
                                              R[L].ks.k[q].s && (R[L].ks.k[q].s[0].c = R[L].closed),
                                              R[L].ks.k[q].e && (R[L].ks.k[q].e[0].c = R[L].closed);
                                  else
                                      R[L].ty === "gr" && D(R[L].it)
                          }
                          function B(R) {
                              var L, V, q = R.length, oe, ye, pe, Pe;
                              for (V = 0; V < q; V += 1) {
                                  if (L = R[V],
                                  L.hasMask) {
                                      var me = L.masksProperties;
                                      for (ye = me.length,
                                      oe = 0; oe < ye; oe += 1)
                                          if (me[oe].pt.k.i)
                                              me[oe].pt.k.c = me[oe].cl;
                                          else
                                              for (Pe = me[oe].pt.k.length,
                                              pe = 0; pe < Pe; pe += 1)
                                                  me[oe].pt.k[pe].s && (me[oe].pt.k[pe].s[0].c = me[oe].cl),
                                                  me[oe].pt.k[pe].e && (me[oe].pt.k[pe].e[0].c = me[oe].cl)
                                  }
                                  L.ty === 4 && D(L.shapes)
                              }
                          }
                          return function(R) {
                              if (F(X, R.v) && (B(R.layers),
                              R.assets)) {
                                  var L, V = R.assets.length;
                                  for (L = 0; L < V; L += 1)
                                      R.assets[L].layers && B(R.assets[L].layers)
                              }
                          }
                      }();
                      function W(X) {
                          X.__complete || (K(X),
                          O(X),
                          $(X),
                          j(X),
                          Y(X),
                          I(X.layers, X.assets),
                          C(X.chars, X.assets),
                          X.__complete = !0)
                      }
                      function Z(X) {
                          X.t.a.length === 0 && "m"in X.t.p
                      }
                      var ee = {};
                      return ee.completeData = W,
                      ee.checkColors = K,
                      ee.checkChars = $,
                      ee.checkPathProperties = j,
                      ee.checkShapes = Y,
                      ee.completeLayers = I,
                      ee
                  }
                  if (l.dataManager || (l.dataManager = x()),
                  l.assetLoader || (l.assetLoader = function() {
                      function I(A) {
                          var T = A.getResponseHeader("content-type");
                          return T && A.responseType === "json" && T.indexOf("json") !== -1 || A.response && _typeof$5(A.response) === "object" ? A.response : A.response && typeof A.response == "string" ? JSON.parse(A.response) : A.responseText ? JSON.parse(A.responseText) : null
                      }
                      function C(A, T, w, M) {
                          var F, O = new XMLHttpRequest;
                          try {
                              O.responseType = "json"
                          } catch {}
                          O.onreadystatechange = function() {
                              if (O.readyState === 4)
                                  if (O.status === 200)
                                      F = I(O),
                                      w(F);
                                  else
                                      try {
                                          F = I(O),
                                          w(F)
                                      } catch ($) {
                                          M && M($)
                                      }
                          }
                          ;
                          try {
                              O.open(["G", "E", "T"].join(""), A, !0)
                          } catch {
                              O.open(["G", "E", "T"].join(""), T + "/" + A, !0)
                          }
                          O.send()
                      }
                      return {
                          load: C
                      }
                  }()),
                  P.data.type === "loadAnimation")
                      l.assetLoader.load(P.data.path, P.data.fullPath, function(I) {
                          l.dataManager.completeData(I),
                          l.postMessage({
                              id: P.data.id,
                              payload: I,
                              status: "success"
                          })
                      }, function() {
                          l.postMessage({
                              id: P.data.id,
                              status: "error"
                          })
                      });
                  else if (P.data.type === "complete") {
                      var E = P.data.animation;
                      l.dataManager.completeData(E),
                      l.postMessage({
                          id: P.data.id,
                          payload: E,
                          status: "success"
                      })
                  } else
                      P.data.type === "loadData" && l.assetLoader.load(P.data.path, P.data.fullPath, function(I) {
                          l.postMessage({
                              id: P.data.id,
                              payload: I,
                              status: "success"
                          })
                      }, function() {
                          l.postMessage({
                              id: P.data.id,
                              status: "error"
                          })
                      })
              }),
              a.onmessage = function(b) {
                  var P = b.data
                    , x = P.id
                    , E = t[x];
                  t[x] = null,
                  P.status === "success" ? E.onComplete(P.payload) : E.onError && E.onError()
              }
              )
          }
          function g(b, P) {
              e += 1;
              var x = "processId_" + e;
              return t[x] = {
                  onComplete: b,
                  onError: P
              },
              x
          }
          function _(b, P, x) {
              d();
              var E = g(P, x);
              a.postMessage({
                  type: "loadAnimation",
                  path: b,
                  fullPath: window.location.origin + window.location.pathname,
                  id: E
              })
          }
          function v(b, P, x) {
              d();
              var E = g(P, x);
              a.postMessage({
                  type: "loadData",
                  path: b,
                  fullPath: window.location.origin + window.location.pathname,
                  id: E
              })
          }
          function S(b, P, x) {
              d();
              var E = g(P, x);
              a.postMessage({
                  type: "complete",
                  animation: b,
                  id: E
              })
          }
          return {
              loadAnimation: _,
              loadData: v,
              completeAnimation: S
          }
      }()
        , ImagePreloader = function() {
          var e = function() {
              var C = createTag("canvas");
              C.width = 1,
              C.height = 1;
              var A = C.getContext("2d");
              return A.fillStyle = "rgba(0,0,0,0)",
              A.fillRect(0, 0, 1, 1),
              C
          }();
          function t() {
              this.loadedAssets += 1,
              this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages && this.imagesLoadedCb && this.imagesLoadedCb(null)
          }
          function r() {
              this.loadedFootagesCount += 1,
              this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages && this.imagesLoadedCb && this.imagesLoadedCb(null)
          }
          function a(C, A, T) {
              var w = "";
              if (C.e)
                  w = C.p;
              else if (A) {
                  var M = C.p;
                  M.indexOf("images/") !== -1 && (M = M.split("/")[1]),
                  w = A + M
              } else
                  w = T,
                  w += C.u ? C.u : "",
                  w += C.p;
              return w
          }
          function o(C) {
              var A = 0
                , T = setInterval((function() {
                  var w = C.getBBox();
                  (w.width || A > 500) && (this._imageLoaded(),
                  clearInterval(T)),
                  A += 1
              }
              ).bind(this), 50)
          }
          function l(C) {
              var A = a(C, this.assetsPath, this.path)
                , T = createNS("image");
              isSafari ? this.testImageLoaded(T) : T.addEventListener("load", this._imageLoaded, !1),
              T.addEventListener("error", (function() {
                  w.img = e,
                  this._imageLoaded()
              }
              ).bind(this), !1),
              T.setAttributeNS("http://www.w3.org/1999/xlink", "href", A),
              this._elementHelper.append ? this._elementHelper.append(T) : this._elementHelper.appendChild(T);
              var w = {
                  img: T,
                  assetData: C
              };
              return w
          }
          function f(C) {
              var A = a(C, this.assetsPath, this.path)
                , T = createTag("img");
              T.crossOrigin = "anonymous",
              T.addEventListener("load", this._imageLoaded, !1),
              T.addEventListener("error", (function() {
                  w.img = e,
                  this._imageLoaded()
              }
              ).bind(this), !1),
              T.src = A;
              var w = {
                  img: T,
                  assetData: C
              };
              return w
          }
          function d(C) {
              var A = {
                  assetData: C
              }
                , T = a(C, this.assetsPath, this.path);
              return dataManager.loadData(T, (function(w) {
                  A.img = w,
                  this._footageLoaded()
              }
              ).bind(this), (function() {
                  A.img = {},
                  this._footageLoaded()
              }
              ).bind(this)),
              A
          }
          function g(C, A) {
              this.imagesLoadedCb = A;
              var T, w = C.length;
              for (T = 0; T < w; T += 1)
                  C[T].layers || (!C[T].t || C[T].t === "seq" ? (this.totalImages += 1,
                  this.images.push(this._createImageData(C[T]))) : C[T].t === 3 && (this.totalFootages += 1,
                  this.images.push(this.createFootageData(C[T]))))
          }
          function _(C) {
              this.path = C || ""
          }
          function v(C) {
              this.assetsPath = C || ""
          }
          function S(C) {
              for (var A = 0, T = this.images.length; A < T; ) {
                  if (this.images[A].assetData === C)
                      return this.images[A].img;
                  A += 1
              }
              return null
          }
          function b() {
              this.imagesLoadedCb = null,
              this.images.length = 0
          }
          function P() {
              return this.totalImages === this.loadedAssets
          }
          function x() {
              return this.totalFootages === this.loadedFootagesCount
          }
          function E(C, A) {
              C === "svg" ? (this._elementHelper = A,
              this._createImageData = this.createImageData.bind(this)) : this._createImageData = this.createImgData.bind(this)
          }
          function I() {
              this._imageLoaded = t.bind(this),
              this._footageLoaded = r.bind(this),
              this.testImageLoaded = o.bind(this),
              this.createFootageData = d.bind(this),
              this.assetsPath = "",
              this.path = "",
              this.totalImages = 0,
              this.totalFootages = 0,
              this.loadedAssets = 0,
              this.loadedFootagesCount = 0,
              this.imagesLoadedCb = null,
              this.images = []
          }
          return I.prototype = {
              loadAssets: g,
              setAssetsPath: v,
              setPath: _,
              loadedImages: P,
              loadedFootages: x,
              destroy: b,
              getAsset: S,
              createImgData: f,
              createImageData: l,
              imageLoaded: t,
              footageLoaded: r,
              setCacheType: E
          },
          I
      }();
      function BaseEvent() {}
      BaseEvent.prototype = {
          triggerEvent: function(t, r) {
              if (this._cbs[t])
                  for (var a = this._cbs[t], o = 0; o < a.length; o += 1)
                      a[o](r)
          },
          addEventListener: function(t, r) {
              return this._cbs[t] || (this._cbs[t] = []),
              this._cbs[t].push(r),
              (function() {
                  this.removeEventListener(t, r)
              }
              ).bind(this)
          },
          removeEventListener: function(t, r) {
              if (!r)
                  this._cbs[t] = null;
              else if (this._cbs[t]) {
                  for (var a = 0, o = this._cbs[t].length; a < o; )
                      this._cbs[t][a] === r && (this._cbs[t].splice(a, 1),
                      a -= 1,
                      o -= 1),
                      a += 1;
                  this._cbs[t].length || (this._cbs[t] = null)
              }
          }
      };
      var markerParser = function() {
          function e(t) {
              for (var r = t.split(`\r
`), a = {}, o, l = 0, f = 0; f < r.length; f += 1)
                  o = r[f].split(":"),
                  o.length === 2 && (a[o[0]] = o[1].trim(),
                  l += 1);
              if (l === 0)
                  throw new Error;
              return a
          }
          return function(t) {
              for (var r = [], a = 0; a < t.length; a += 1) {
                  var o = t[a]
                    , l = {
                      time: o.tm,
                      duration: o.dr
                  };
                  try {
                      l.payload = JSON.parse(t[a].cm)
                  } catch {
                      try {
                          l.payload = e(t[a].cm)
                      } catch {
                          l.payload = {
                              name: t[a].cm
                          }
                      }
                  }
                  r.push(l)
              }
              return r
          }
      }()
        , ProjectInterface = function() {
          function e(t) {
              this.compositions.push(t)
          }
          return function() {
              function t(r) {
                  for (var a = 0, o = this.compositions.length; a < o; ) {
                      if (this.compositions[a].data && this.compositions[a].data.nm === r)
                          return this.compositions[a].prepareFrame && this.compositions[a].data.xt && this.compositions[a].prepareFrame(this.currentFrame),
                          this.compositions[a].compInterface;
                      a += 1
                  }
                  return null
              }
              return t.compositions = [],
              t.currentFrame = 0,
              t.registerComposition = e,
              t
          }
      }()
        , renderers = {}
        , registerRenderer = function(t, r) {
          renderers[t] = r
      };
      function getRenderer(e) {
          return renderers[e]
      }
      function getRegisteredRenderer() {
          if (renderers.canvas)
              return "canvas";
          for (var e in renderers)
              if (renderers[e])
                  return e;
          return ""
      }
      function _typeof$4(e) {
          "@babel/helpers - typeof";
          return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$4 = function(r) {
              return typeof r
          }
          : _typeof$4 = function(r) {
              return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r
          }
          ,
          _typeof$4(e)
      }
      var AnimationItem = function() {
          this._cbs = [],
          this.name = "",
          this.path = "",
          this.isLoaded = !1,
          this.currentFrame = 0,
          this.currentRawFrame = 0,
          this.firstFrame = 0,
          this.totalFrames = 0,
          this.frameRate = 0,
          this.frameMult = 0,
          this.playSpeed = 1,
          this.playDirection = 1,
          this.playCount = 0,
          this.animationData = {},
          this.assets = [],
          this.isPaused = !0,
          this.autoplay = !1,
          this.loop = !0,
          this.renderer = null,
          this.animationID = createElementID(),
          this.assetsPath = "",
          this.timeCompleted = 0,
          this.segmentPos = 0,
          this.isSubframeEnabled = getSubframeEnabled(),
          this.segments = [],
          this._idle = !0,
          this._completedLoop = !1,
          this.projectInterface = ProjectInterface(),
          this.imagePreloader = new ImagePreloader,
          this.audioController = audioControllerFactory(),
          this.markers = [],
          this.configAnimation = this.configAnimation.bind(this),
          this.onSetupError = this.onSetupError.bind(this),
          this.onSegmentComplete = this.onSegmentComplete.bind(this),
          this.drawnFrameEvent = new BMEnterFrameEvent("drawnFrame",0,0,0),
          this.expressionsPlugin = getExpressionsPlugin()
      };
      extendPrototype([BaseEvent], AnimationItem),
      AnimationItem.prototype.setParams = function(e) {
          (e.wrapper || e.container) && (this.wrapper = e.wrapper || e.container);
          var t = "svg";
          e.animType ? t = e.animType : e.renderer && (t = e.renderer);
          var r = getRenderer(t);
          this.renderer = new r(this,e.rendererSettings),
          this.imagePreloader.setCacheType(t, this.renderer.globalData.defs),
          this.renderer.setProjectInterface(this.projectInterface),
          this.animType = t,
          e.loop === "" || e.loop === null || e.loop === void 0 || e.loop === !0 ? this.loop = !0 : e.loop === !1 ? this.loop = !1 : this.loop = parseInt(e.loop, 10),
          this.autoplay = "autoplay"in e ? e.autoplay : !0,
          this.name = e.name ? e.name : "",
          this.autoloadSegments = Object.prototype.hasOwnProperty.call(e, "autoloadSegments") ? e.autoloadSegments : !0,
          this.assetsPath = e.assetsPath,
          this.initialSegment = e.initialSegment,
          e.audioFactory && this.audioController.setAudioFactory(e.audioFactory),
          e.animationData ? this.setupAnimation(e.animationData) : e.path && (e.path.lastIndexOf("\\") !== -1 ? this.path = e.path.substr(0, e.path.lastIndexOf("\\") + 1) : this.path = e.path.substr(0, e.path.lastIndexOf("/") + 1),
          this.fileName = e.path.substr(e.path.lastIndexOf("/") + 1),
          this.fileName = this.fileName.substr(0, this.fileName.lastIndexOf(".json")),
          dataManager.loadAnimation(e.path, this.configAnimation, this.onSetupError))
      }
      ,
      AnimationItem.prototype.onSetupError = function() {
          this.trigger("data_failed")
      }
      ,
      AnimationItem.prototype.setupAnimation = function(e) {
          dataManager.completeAnimation(e, this.configAnimation)
      }
      ,
      AnimationItem.prototype.setData = function(e, t) {
          t && _typeof$4(t) !== "object" && (t = JSON.parse(t));
          var r = {
              wrapper: e,
              animationData: t
          }
            , a = e.attributes;
          r.path = a.getNamedItem("data-animation-path") ? a.getNamedItem("data-animation-path").value : a.getNamedItem("data-bm-path") ? a.getNamedItem("data-bm-path").value : a.getNamedItem("bm-path") ? a.getNamedItem("bm-path").value : "",
          r.animType = a.getNamedItem("data-anim-type") ? a.getNamedItem("data-anim-type").value : a.getNamedItem("data-bm-type") ? a.getNamedItem("data-bm-type").value : a.getNamedItem("bm-type") ? a.getNamedItem("bm-type").value : a.getNamedItem("data-bm-renderer") ? a.getNamedItem("data-bm-renderer").value : a.getNamedItem("bm-renderer") ? a.getNamedItem("bm-renderer").value : getRegisteredRenderer() || "canvas";
          var o = a.getNamedItem("data-anim-loop") ? a.getNamedItem("data-anim-loop").value : a.getNamedItem("data-bm-loop") ? a.getNamedItem("data-bm-loop").value : a.getNamedItem("bm-loop") ? a.getNamedItem("bm-loop").value : "";
          o === "false" ? r.loop = !1 : o === "true" ? r.loop = !0 : o !== "" && (r.loop = parseInt(o, 10));
          var l = a.getNamedItem("data-anim-autoplay") ? a.getNamedItem("data-anim-autoplay").value : a.getNamedItem("data-bm-autoplay") ? a.getNamedItem("data-bm-autoplay").value : a.getNamedItem("bm-autoplay") ? a.getNamedItem("bm-autoplay").value : !0;
          r.autoplay = l !== "false",
          r.name = a.getNamedItem("data-name") ? a.getNamedItem("data-name").value : a.getNamedItem("data-bm-name") ? a.getNamedItem("data-bm-name").value : a.getNamedItem("bm-name") ? a.getNamedItem("bm-name").value : "";
          var f = a.getNamedItem("data-anim-prerender") ? a.getNamedItem("data-anim-prerender").value : a.getNamedItem("data-bm-prerender") ? a.getNamedItem("data-bm-prerender").value : a.getNamedItem("bm-prerender") ? a.getNamedItem("bm-prerender").value : "";
          f === "false" && (r.prerender = !1),
          r.path ? this.setParams(r) : this.trigger("destroy")
      }
      ,
      AnimationItem.prototype.includeLayers = function(e) {
          e.op > this.animationData.op && (this.animationData.op = e.op,
          this.totalFrames = Math.floor(e.op - this.animationData.ip));
          var t = this.animationData.layers, r, a = t.length, o = e.layers, l, f = o.length;
          for (l = 0; l < f; l += 1)
              for (r = 0; r < a; ) {
                  if (t[r].id === o[l].id) {
                      t[r] = o[l];
                      break
                  }
                  r += 1
              }
          if ((e.chars || e.fonts) && (this.renderer.globalData.fontManager.addChars(e.chars),
          this.renderer.globalData.fontManager.addFonts(e.fonts, this.renderer.globalData.defs)),
          e.assets)
              for (a = e.assets.length,
              r = 0; r < a; r += 1)
                  this.animationData.assets.push(e.assets[r]);
          this.animationData.__complete = !1,
          dataManager.completeAnimation(this.animationData, this.onSegmentComplete)
      }
      ,
      AnimationItem.prototype.onSegmentComplete = function(e) {
          this.animationData = e;
          var t = getExpressionsPlugin();
          t && t.initExpressions(this),
          this.loadNextSegment()
      }
      ,
      AnimationItem.prototype.loadNextSegment = function() {
          var e = this.animationData.segments;
          if (!e || e.length === 0 || !this.autoloadSegments) {
              this.trigger("data_ready"),
              this.timeCompleted = this.totalFrames;
              return
          }
          var t = e.shift();
          this.timeCompleted = t.time * this.frameRate;
          var r = this.path + this.fileName + "_" + this.segmentPos + ".json";
          this.segmentPos += 1,
          dataManager.loadData(r, this.includeLayers.bind(this), (function() {
              this.trigger("data_failed")
          }
          ).bind(this))
      }
      ,
      AnimationItem.prototype.loadSegments = function() {
          var e = this.animationData.segments;
          e || (this.timeCompleted = this.totalFrames),
          this.loadNextSegment()
      }
      ,
      AnimationItem.prototype.imagesLoaded = function() {
          this.trigger("loaded_images"),
          this.checkLoaded()
      }
      ,
      AnimationItem.prototype.preloadImages = function() {
          this.imagePreloader.setAssetsPath(this.assetsPath),
          this.imagePreloader.setPath(this.path),
          this.imagePreloader.loadAssets(this.animationData.assets, this.imagesLoaded.bind(this))
      }
      ,
      AnimationItem.prototype.configAnimation = function(e) {
          if (this.renderer)
              try {
                  this.animationData = e,
                  this.initialSegment ? (this.totalFrames = Math.floor(this.initialSegment[1] - this.initialSegment[0]),
                  this.firstFrame = Math.round(this.initialSegment[0])) : (this.totalFrames = Math.floor(this.animationData.op - this.animationData.ip),
                  this.firstFrame = Math.round(this.animationData.ip)),
                  this.renderer.configAnimation(e),
                  e.assets || (e.assets = []),
                  this.assets = this.animationData.assets,
                  this.frameRate = this.animationData.fr,
                  this.frameMult = this.animationData.fr / 1e3,
                  this.renderer.searchExtraCompositions(e.assets),
                  this.markers = markerParser(e.markers || []),
                  this.trigger("config_ready"),
                  this.preloadImages(),
                  this.loadSegments(),
                  this.updaFrameModifier(),
                  this.waitForFontsLoaded(),
                  this.isPaused && this.audioController.pause()
              } catch (t) {
                  this.triggerConfigError(t)
              }
      }
      ,
      AnimationItem.prototype.waitForFontsLoaded = function() {
          this.renderer && (this.renderer.globalData.fontManager.isLoaded ? this.checkLoaded() : setTimeout(this.waitForFontsLoaded.bind(this), 20))
      }
      ,
      AnimationItem.prototype.checkLoaded = function() {
          if (!this.isLoaded && this.renderer.globalData.fontManager.isLoaded && (this.imagePreloader.loadedImages() || this.renderer.rendererType !== "canvas") && this.imagePreloader.loadedFootages()) {
              this.isLoaded = !0;
              var e = getExpressionsPlugin();
              e && e.initExpressions(this),
              this.renderer.initItems(),
              setTimeout((function() {
                  this.trigger("DOMLoaded")
              }
              ).bind(this), 0),
              this.gotoFrame(),
              this.autoplay && this.play()
          }
      }
      ,
      AnimationItem.prototype.resize = function(e, t) {
          var r = typeof e == "number" ? e : void 0
            , a = typeof t == "number" ? t : void 0;
          this.renderer.updateContainerSize(r, a)
      }
      ,
      AnimationItem.prototype.setSubframe = function(e) {
          this.isSubframeEnabled = !!e
      }
      ,
      AnimationItem.prototype.gotoFrame = function() {
          this.currentFrame = this.isSubframeEnabled ? this.currentRawFrame : ~~this.currentRawFrame,
          this.timeCompleted !== this.totalFrames && this.currentFrame > this.timeCompleted && (this.currentFrame = this.timeCompleted),
          this.trigger("enterFrame"),
          this.renderFrame(),
          this.trigger("drawnFrame")
      }
      ,
      AnimationItem.prototype.renderFrame = function() {
          if (!(this.isLoaded === !1 || !this.renderer))
              try {
                  this.expressionsPlugin && this.expressionsPlugin.resetFrame(),
                  this.renderer.renderFrame(this.currentFrame + this.firstFrame)
              } catch (e) {
                  this.triggerRenderFrameError(e)
              }
      }
      ,
      AnimationItem.prototype.play = function(e) {
          e && this.name !== e || this.isPaused === !0 && (this.isPaused = !1,
          this.trigger("_play"),
          this.audioController.resume(),
          this._idle && (this._idle = !1,
          this.trigger("_active")))
      }
      ,
      AnimationItem.prototype.pause = function(e) {
          e && this.name !== e || this.isPaused === !1 && (this.isPaused = !0,
          this.trigger("_pause"),
          this._idle = !0,
          this.trigger("_idle"),
          this.audioController.pause())
      }
      ,
      AnimationItem.prototype.togglePause = function(e) {
          e && this.name !== e || (this.isPaused === !0 ? this.play() : this.pause())
      }
      ,
      AnimationItem.prototype.stop = function(e) {
          e && this.name !== e || (this.pause(),
          this.playCount = 0,
          this._completedLoop = !1,
          this.setCurrentRawFrameValue(0))
      }
      ,
      AnimationItem.prototype.getMarkerData = function(e) {
          for (var t, r = 0; r < this.markers.length; r += 1)
              if (t = this.markers[r],
              t.payload && t.payload.name === e)
                  return t;
          return null
      }
      ,
      AnimationItem.prototype.goToAndStop = function(e, t, r) {
          if (!(r && this.name !== r)) {
              var a = Number(e);
              if (isNaN(a)) {
                  var o = this.getMarkerData(e);
                  o && this.goToAndStop(o.time, !0)
              } else
                  t ? this.setCurrentRawFrameValue(e) : this.setCurrentRawFrameValue(e * this.frameModifier);
              this.pause()
          }
      }
      ,
      AnimationItem.prototype.goToAndPlay = function(e, t, r) {
          if (!(r && this.name !== r)) {
              var a = Number(e);
              if (isNaN(a)) {
                  var o = this.getMarkerData(e);
                  o && (o.duration ? this.playSegments([o.time, o.time + o.duration], !0) : this.goToAndStop(o.time, !0))
              } else
                  this.goToAndStop(a, t, r);
              this.play()
          }
      }
      ,
      AnimationItem.prototype.advanceTime = function(e) {
          if (!(this.isPaused === !0 || this.isLoaded === !1)) {
              var t = this.currentRawFrame + e * this.frameModifier
                , r = !1;
              t >= this.totalFrames - 1 && this.frameModifier > 0 ? !this.loop || this.playCount === this.loop ? this.checkSegments(t > this.totalFrames ? t % this.totalFrames : 0) || (r = !0,
              t = this.totalFrames - 1) : t >= this.totalFrames ? (this.playCount += 1,
              this.checkSegments(t % this.totalFrames) || (this.setCurrentRawFrameValue(t % this.totalFrames),
              this._completedLoop = !0,
              this.trigger("loopComplete"))) : this.setCurrentRawFrameValue(t) : t < 0 ? this.checkSegments(t % this.totalFrames) || (this.loop && !(this.playCount-- <= 0 && this.loop !== !0) ? (this.setCurrentRawFrameValue(this.totalFrames + t % this.totalFrames),
              this._completedLoop ? this.trigger("loopComplete") : this._completedLoop = !0) : (r = !0,
              t = 0)) : this.setCurrentRawFrameValue(t),
              r && (this.setCurrentRawFrameValue(t),
              this.pause(),
              this.trigger("complete"))
          }
      }
      ,
      AnimationItem.prototype.adjustSegment = function(e, t) {
          this.playCount = 0,
          e[1] < e[0] ? (this.frameModifier > 0 && (this.playSpeed < 0 ? this.setSpeed(-this.playSpeed) : this.setDirection(-1)),
          this.totalFrames = e[0] - e[1],
          this.timeCompleted = this.totalFrames,
          this.firstFrame = e[1],
          this.setCurrentRawFrameValue(this.totalFrames - .001 - t)) : e[1] > e[0] && (this.frameModifier < 0 && (this.playSpeed < 0 ? this.setSpeed(-this.playSpeed) : this.setDirection(1)),
          this.totalFrames = e[1] - e[0],
          this.timeCompleted = this.totalFrames,
          this.firstFrame = e[0],
          this.setCurrentRawFrameValue(.001 + t)),
          this.trigger("segmentStart")
      }
      ,
      AnimationItem.prototype.setSegment = function(e, t) {
          var r = -1;
          this.isPaused && (this.currentRawFrame + this.firstFrame < e ? r = e : this.currentRawFrame + this.firstFrame > t && (r = t - e)),
          this.firstFrame = e,
          this.totalFrames = t - e,
          this.timeCompleted = this.totalFrames,
          r !== -1 && this.goToAndStop(r, !0)
      }
      ,
      AnimationItem.prototype.playSegments = function(e, t) {
          if (t && (this.segments.length = 0),
          _typeof$4(e[0]) === "object") {
              var r, a = e.length;
              for (r = 0; r < a; r += 1)
                  this.segments.push(e[r])
          } else
              this.segments.push(e);
          this.segments.length && t && this.adjustSegment(this.segments.shift(), 0),
          this.isPaused && this.play()
      }
      ,
      AnimationItem.prototype.resetSegments = function(e) {
          this.segments.length = 0,
          this.segments.push([this.animationData.ip, this.animationData.op]),
          e && this.checkSegments(0)
      }
      ,
      AnimationItem.prototype.checkSegments = function(e) {
          return this.segments.length ? (this.adjustSegment(this.segments.shift(), e),
          !0) : !1
      }
      ,
      AnimationItem.prototype.destroy = function(e) {
          e && this.name !== e || !this.renderer || (this.renderer.destroy(),
          this.imagePreloader.destroy(),
          this.trigger("destroy"),
          this._cbs = null,
          this.onEnterFrame = null,
          this.onLoopComplete = null,
          this.onComplete = null,
          this.onSegmentStart = null,
          this.onDestroy = null,
          this.renderer = null,
          this.expressionsPlugin = null,
          this.imagePreloader = null,
          this.projectInterface = null)
      }
      ,
      AnimationItem.prototype.setCurrentRawFrameValue = function(e) {
          this.currentRawFrame = e,
          this.gotoFrame()
      }
      ,
      AnimationItem.prototype.setSpeed = function(e) {
          this.playSpeed = e,
          this.updaFrameModifier()
      }
      ,
      AnimationItem.prototype.setDirection = function(e) {
          this.playDirection = e < 0 ? -1 : 1,
          this.updaFrameModifier()
      }
      ,
      AnimationItem.prototype.setLoop = function(e) {
          this.loop = e
      }
      ,
      AnimationItem.prototype.setVolume = function(e, t) {
          t && this.name !== t || this.audioController.setVolume(e)
      }
      ,
      AnimationItem.prototype.getVolume = function() {
          return this.audioController.getVolume()
      }
      ,
      AnimationItem.prototype.mute = function(e) {
          e && this.name !== e || this.audioController.mute()
      }
      ,
      AnimationItem.prototype.unmute = function(e) {
          e && this.name !== e || this.audioController.unmute()
      }
      ,
      AnimationItem.prototype.updaFrameModifier = function() {
          this.frameModifier = this.frameMult * this.playSpeed * this.playDirection,
          this.audioController.setRate(this.playSpeed * this.playDirection)
      }
      ,
      AnimationItem.prototype.getPath = function() {
          return this.path
      }
      ,
      AnimationItem.prototype.getAssetsPath = function(e) {
          var t = "";
          if (e.e)
              t = e.p;
          else if (this.assetsPath) {
              var r = e.p;
              r.indexOf("images/") !== -1 && (r = r.split("/")[1]),
              t = this.assetsPath + r
          } else
              t = this.path,
              t += e.u ? e.u : "",
              t += e.p;
          return t
      }
      ,
      AnimationItem.prototype.getAssetData = function(e) {
          for (var t = 0, r = this.assets.length; t < r; ) {
              if (e === this.assets[t].id)
                  return this.assets[t];
              t += 1
          }
          return null
      }
      ,
      AnimationItem.prototype.hide = function() {
          this.renderer.hide()
      }
      ,
      AnimationItem.prototype.show = function() {
          this.renderer.show()
      }
      ,
      AnimationItem.prototype.getDuration = function(e) {
          return e ? this.totalFrames : this.totalFrames / this.frameRate
      }
      ,
      AnimationItem.prototype.updateDocumentData = function(e, t, r) {
          try {
              var a = this.renderer.getElementByPath(e);
              a.updateDocumentData(t, r)
          } catch {}
      }
      ,
      AnimationItem.prototype.trigger = function(e) {
          if (this._cbs && this._cbs[e])
              switch (e) {
              case "enterFrame":
                  this.triggerEvent(e, new BMEnterFrameEvent(e,this.currentFrame,this.totalFrames,this.frameModifier));
                  break;
              case "drawnFrame":
                  this.drawnFrameEvent.currentTime = this.currentFrame,
                  this.drawnFrameEvent.totalTime = this.totalFrames,
                  this.drawnFrameEvent.direction = this.frameModifier,
                  this.triggerEvent(e, this.drawnFrameEvent);
                  break;
              case "loopComplete":
                  this.triggerEvent(e, new BMCompleteLoopEvent(e,this.loop,this.playCount,this.frameMult));
                  break;
              case "complete":
                  this.triggerEvent(e, new BMCompleteEvent(e,this.frameMult));
                  break;
              case "segmentStart":
                  this.triggerEvent(e, new BMSegmentStartEvent(e,this.firstFrame,this.totalFrames));
                  break;
              case "destroy":
                  this.triggerEvent(e, new BMDestroyEvent(e,this));
                  break;
              default:
                  this.triggerEvent(e)
              }
          e === "enterFrame" && this.onEnterFrame && this.onEnterFrame.call(this, new BMEnterFrameEvent(e,this.currentFrame,this.totalFrames,this.frameMult)),
          e === "loopComplete" && this.onLoopComplete && this.onLoopComplete.call(this, new BMCompleteLoopEvent(e,this.loop,this.playCount,this.frameMult)),
          e === "complete" && this.onComplete && this.onComplete.call(this, new BMCompleteEvent(e,this.frameMult)),
          e === "segmentStart" && this.onSegmentStart && this.onSegmentStart.call(this, new BMSegmentStartEvent(e,this.firstFrame,this.totalFrames)),
          e === "destroy" && this.onDestroy && this.onDestroy.call(this, new BMDestroyEvent(e,this))
      }
      ,
      AnimationItem.prototype.triggerRenderFrameError = function(e) {
          var t = new BMRenderFrameErrorEvent(e,this.currentFrame);
          this.triggerEvent("error", t),
          this.onError && this.onError.call(this, t)
      }
      ,
      AnimationItem.prototype.triggerConfigError = function(e) {
          var t = new BMConfigErrorEvent(e,this.currentFrame);
          this.triggerEvent("error", t),
          this.onError && this.onError.call(this, t)
      }
      ;
      var animationManager = function() {
          var e = {}
            , t = []
            , r = 0
            , a = 0
            , o = 0
            , l = !0
            , f = !1;
          function d(D) {
              for (var B = 0, R = D.target; B < a; )
                  t[B].animation === R && (t.splice(B, 1),
                  B -= 1,
                  a -= 1,
                  R.isPaused || S()),
                  B += 1
          }
          function g(D, B) {
              if (!D)
                  return null;
              for (var R = 0; R < a; ) {
                  if (t[R].elem === D && t[R].elem !== null)
                      return t[R].animation;
                  R += 1
              }
              var L = new AnimationItem;
              return b(L, D),
              L.setData(D, B),
              L
          }
          function _() {
              var D, B = t.length, R = [];
              for (D = 0; D < B; D += 1)
                  R.push(t[D].animation);
              return R
          }
          function v() {
              o += 1,
              K()
          }
          function S() {
              o -= 1
          }
          function b(D, B) {
              D.addEventListener("destroy", d),
              D.addEventListener("_active", v),
              D.addEventListener("_idle", S),
              t.push({
                  elem: B,
                  animation: D
              }),
              a += 1
          }
          function P(D) {
              var B = new AnimationItem;
              return b(B, null),
              B.setParams(D),
              B
          }
          function x(D, B) {
              var R;
              for (R = 0; R < a; R += 1)
                  t[R].animation.setSpeed(D, B)
          }
          function E(D, B) {
              var R;
              for (R = 0; R < a; R += 1)
                  t[R].animation.setDirection(D, B)
          }
          function I(D) {
              var B;
              for (B = 0; B < a; B += 1)
                  t[B].animation.play(D)
          }
          function C(D) {
              var B = D - r, R;
              for (R = 0; R < a; R += 1)
                  t[R].animation.advanceTime(B);
              r = D,
              o && !f ? window.requestAnimationFrame(C) : l = !0
          }
          function A(D) {
              r = D,
              window.requestAnimationFrame(C)
          }
          function T(D) {
              var B;
              for (B = 0; B < a; B += 1)
                  t[B].animation.pause(D)
          }
          function w(D, B, R) {
              var L;
              for (L = 0; L < a; L += 1)
                  t[L].animation.goToAndStop(D, B, R)
          }
          function M(D) {
              var B;
              for (B = 0; B < a; B += 1)
                  t[B].animation.stop(D)
          }
          function F(D) {
              var B;
              for (B = 0; B < a; B += 1)
                  t[B].animation.togglePause(D)
          }
          function O(D) {
              var B;
              for (B = a - 1; B >= 0; B -= 1)
                  t[B].animation.destroy(D)
          }
          function $(D, B, R) {
              var L = [].concat([].slice.call(document.getElementsByClassName("lottie")), [].slice.call(document.getElementsByClassName("bodymovin"))), V, q = L.length;
              for (V = 0; V < q; V += 1)
                  R && L[V].setAttribute("data-bm-type", R),
                  g(L[V], D);
              if (B && q === 0) {
                  R || (R = "svg");
                  var oe = document.getElementsByTagName("body")[0];
                  oe.innerText = "";
                  var ye = createTag("div");
                  ye.style.width = "100%",
                  ye.style.height = "100%",
                  ye.setAttribute("data-bm-type", R),
                  oe.appendChild(ye),
                  g(ye, D)
              }
          }
          function j() {
              var D;
              for (D = 0; D < a; D += 1)
                  t[D].animation.resize()
          }
          function K() {
              !f && o && l && (window.requestAnimationFrame(A),
              l = !1)
          }
          function Y() {
              f = !0
          }
          function W() {
              f = !1,
              K()
          }
          function Z(D, B) {
              var R;
              for (R = 0; R < a; R += 1)
                  t[R].animation.setVolume(D, B)
          }
          function ee(D) {
              var B;
              for (B = 0; B < a; B += 1)
                  t[B].animation.mute(D)
          }
          function X(D) {
              var B;
              for (B = 0; B < a; B += 1)
                  t[B].animation.unmute(D)
          }
          return e.registerAnimation = g,
          e.loadAnimation = P,
          e.setSpeed = x,
          e.setDirection = E,
          e.play = I,
          e.pause = T,
          e.stop = M,
          e.togglePause = F,
          e.searchAnimations = $,
          e.resize = j,
          e.goToAndStop = w,
          e.destroy = O,
          e.freeze = Y,
          e.unfreeze = W,
          e.setVolume = Z,
          e.mute = ee,
          e.unmute = X,
          e.getRegisteredAnimations = _,
          e
      }()
        , BezierFactory = function() {
          var e = {};
          e.getBezierEasing = r;
          var t = {};
          function r(A, T, w, M, F) {
              var O = F || ("bez_" + A + "_" + T + "_" + w + "_" + M).replace(/\./g, "p");
              if (t[O])
                  return t[O];
              var $ = new C([A, T, w, M]);
              return t[O] = $,
              $
          }
          var a = 4
            , o = .001
            , l = 1e-7
            , f = 10
            , d = 11
            , g = 1 / (d - 1)
            , _ = typeof Float32Array == "function";
          function v(A, T) {
              return 1 - 3 * T + 3 * A
          }
          function S(A, T) {
              return 3 * T - 6 * A
          }
          function b(A) {
              return 3 * A
          }
          function P(A, T, w) {
              return ((v(T, w) * A + S(T, w)) * A + b(T)) * A
          }
          function x(A, T, w) {
              return 3 * v(T, w) * A * A + 2 * S(T, w) * A + b(T)
          }
          function E(A, T, w, M, F) {
              var O, $, j = 0;
              do
                  $ = T + (w - T) / 2,
                  O = P($, M, F) - A,
                  O > 0 ? w = $ : T = $;
              while (Math.abs(O) > l && ++j < f);
              return $
          }
          function I(A, T, w, M) {
              for (var F = 0; F < a; ++F) {
                  var O = x(T, w, M);
                  if (O === 0)
                      return T;
                  var $ = P(T, w, M) - A;
                  T -= $ / O
              }
              return T
          }
          function C(A) {
              this._p = A,
              this._mSampleValues = _ ? new Float32Array(d) : new Array(d),
              this._precomputed = !1,
              this.get = this.get.bind(this)
          }
          return C.prototype = {
              get: function(T) {
                  var w = this._p[0]
                    , M = this._p[1]
                    , F = this._p[2]
                    , O = this._p[3];
                  return this._precomputed || this._precompute(),
                  w === M && F === O ? T : T === 0 ? 0 : T === 1 ? 1 : P(this._getTForX(T), M, O)
              },
              _precompute: function() {
                  var T = this._p[0]
                    , w = this._p[1]
                    , M = this._p[2]
                    , F = this._p[3];
                  this._precomputed = !0,
                  (T !== w || M !== F) && this._calcSampleValues()
              },
              _calcSampleValues: function() {
                  for (var T = this._p[0], w = this._p[2], M = 0; M < d; ++M)
                      this._mSampleValues[M] = P(M * g, T, w)
              },
              _getTForX: function(T) {
                  for (var w = this._p[0], M = this._p[2], F = this._mSampleValues, O = 0, $ = 1, j = d - 1; $ !== j && F[$] <= T; ++$)
                      O += g;
                  --$;
                  var K = (T - F[$]) / (F[$ + 1] - F[$])
                    , Y = O + K * g
                    , W = x(Y, w, M);
                  return W >= o ? I(T, Y, w, M) : W === 0 ? Y : E(T, O, O + g, w, M)
              }
          },
          e
      }()
        , pooling = function() {
          function e(t) {
              return t.concat(createSizedArray(t.length))
          }
          return {
              double: e
          }
      }()
        , poolFactory = function() {
          return function(e, t, r) {
              var a = 0
                , o = e
                , l = createSizedArray(o)
                , f = {
                  newElement: d,
                  release: g
              };
              function d() {
                  var _;
                  return a ? (a -= 1,
                  _ = l[a]) : _ = t(),
                  _
              }
              function g(_) {
                  a === o && (l = pooling.double(l),
                  o *= 2),
                  r && r(_),
                  l[a] = _,
                  a += 1
              }
              return f
          }
      }()
        , bezierLengthPool = function() {
          function e() {
              return {
                  addedLength: 0,
                  percents: createTypedArray("float32", getDefaultCurveSegments()),
                  lengths: createTypedArray("float32", getDefaultCurveSegments())
              }
          }
          return poolFactory(8, e)
      }()
        , segmentsLengthPool = function() {
          function e() {
              return {
                  lengths: [],
                  totalLength: 0
              }
          }
          function t(r) {
              var a, o = r.lengths.length;
              for (a = 0; a < o; a += 1)
                  bezierLengthPool.release(r.lengths[a]);
              r.lengths.length = 0
          }
          return poolFactory(8, e, t)
      }();
      function bezFunction() {
          var e = Math;
          function t(b, P, x, E, I, C) {
              var A = b * E + P * I + x * C - I * E - C * b - x * P;
              return A > -.001 && A < .001
          }
          function r(b, P, x, E, I, C, A, T, w) {
              if (x === 0 && C === 0 && w === 0)
                  return t(b, P, E, I, A, T);
              var M = e.sqrt(e.pow(E - b, 2) + e.pow(I - P, 2) + e.pow(C - x, 2)), F = e.sqrt(e.pow(A - b, 2) + e.pow(T - P, 2) + e.pow(w - x, 2)), O = e.sqrt(e.pow(A - E, 2) + e.pow(T - I, 2) + e.pow(w - C, 2)), $;
              return M > F ? M > O ? $ = M - F - O : $ = O - F - M : O > F ? $ = O - F - M : $ = F - M - O,
              $ > -1e-4 && $ < 1e-4
          }
          var a = function() {
              return function(b, P, x, E) {
                  var I = getDefaultCurveSegments(), C, A, T, w, M, F = 0, O, $ = [], j = [], K = bezierLengthPool.newElement();
                  for (T = x.length,
                  C = 0; C < I; C += 1) {
                      for (M = C / (I - 1),
                      O = 0,
                      A = 0; A < T; A += 1)
                          w = bmPow(1 - M, 3) * b[A] + 3 * bmPow(1 - M, 2) * M * x[A] + 3 * (1 - M) * bmPow(M, 2) * E[A] + bmPow(M, 3) * P[A],
                          $[A] = w,
                          j[A] !== null && (O += bmPow($[A] - j[A], 2)),
                          j[A] = $[A];
                      O && (O = bmSqrt(O),
                      F += O),
                      K.percents[C] = M,
                      K.lengths[C] = F
                  }
                  return K.addedLength = F,
                  K
              }
          }();
          function o(b) {
              var P = segmentsLengthPool.newElement(), x = b.c, E = b.v, I = b.o, C = b.i, A, T = b._length, w = P.lengths, M = 0;
              for (A = 0; A < T - 1; A += 1)
                  w[A] = a(E[A], E[A + 1], I[A], C[A + 1]),
                  M += w[A].addedLength;
              return x && T && (w[A] = a(E[A], E[0], I[A], C[0]),
              M += w[A].addedLength),
              P.totalLength = M,
              P
          }
          function l(b) {
              this.segmentLength = 0,
              this.points = new Array(b)
          }
          function f(b, P) {
              this.partialLength = b,
              this.point = P
          }
          var d = function() {
              var b = {};
              return function(P, x, E, I) {
                  var C = (P[0] + "_" + P[1] + "_" + x[0] + "_" + x[1] + "_" + E[0] + "_" + E[1] + "_" + I[0] + "_" + I[1]).replace(/\./g, "p");
                  if (!b[C]) {
                      var A = getDefaultCurveSegments(), T, w, M, F, O, $ = 0, j, K, Y = null;
                      P.length === 2 && (P[0] !== x[0] || P[1] !== x[1]) && t(P[0], P[1], x[0], x[1], P[0] + E[0], P[1] + E[1]) && t(P[0], P[1], x[0], x[1], x[0] + I[0], x[1] + I[1]) && (A = 2);
                      var W = new l(A);
                      for (M = E.length,
                      T = 0; T < A; T += 1) {
                          for (K = createSizedArray(M),
                          O = T / (A - 1),
                          j = 0,
                          w = 0; w < M; w += 1)
                              F = bmPow(1 - O, 3) * P[w] + 3 * bmPow(1 - O, 2) * O * (P[w] + E[w]) + 3 * (1 - O) * bmPow(O, 2) * (x[w] + I[w]) + bmPow(O, 3) * x[w],
                              K[w] = F,
                              Y !== null && (j += bmPow(K[w] - Y[w], 2));
                          j = bmSqrt(j),
                          $ += j,
                          W.points[T] = new f(j,K),
                          Y = K
                      }
                      W.segmentLength = $,
                      b[C] = W
                  }
                  return b[C]
              }
          }();
          function g(b, P) {
              var x = P.percents
                , E = P.lengths
                , I = x.length
                , C = bmFloor((I - 1) * b)
                , A = b * P.addedLength
                , T = 0;
              if (C === I - 1 || C === 0 || A === E[C])
                  return x[C];
              for (var w = E[C] > A ? -1 : 1, M = !0; M; )
                  if (E[C] <= A && E[C + 1] > A ? (T = (A - E[C]) / (E[C + 1] - E[C]),
                  M = !1) : C += w,
                  C < 0 || C >= I - 1) {
                      if (C === I - 1)
                          return x[C];
                      M = !1
                  }
              return x[C] + (x[C + 1] - x[C]) * T
          }
          function _(b, P, x, E, I, C) {
              var A = g(I, C)
                , T = 1 - A
                , w = e.round((T * T * T * b[0] + (A * T * T + T * A * T + T * T * A) * x[0] + (A * A * T + T * A * A + A * T * A) * E[0] + A * A * A * P[0]) * 1e3) / 1e3
                , M = e.round((T * T * T * b[1] + (A * T * T + T * A * T + T * T * A) * x[1] + (A * A * T + T * A * A + A * T * A) * E[1] + A * A * A * P[1]) * 1e3) / 1e3;
              return [w, M]
          }
          var v = createTypedArray("float32", 8);
          function S(b, P, x, E, I, C, A) {
              I < 0 ? I = 0 : I > 1 && (I = 1);
              var T = g(I, A);
              C = C > 1 ? 1 : C;
              var w = g(C, A), M, F = b.length, O = 1 - T, $ = 1 - w, j = O * O * O, K = T * O * O * 3, Y = T * T * O * 3, W = T * T * T, Z = O * O * $, ee = T * O * $ + O * T * $ + O * O * w, X = T * T * $ + O * T * w + T * O * w, D = T * T * w, B = O * $ * $, R = T * $ * $ + O * w * $ + O * $ * w, L = T * w * $ + O * w * w + T * $ * w, V = T * w * w, q = $ * $ * $, oe = w * $ * $ + $ * w * $ + $ * $ * w, ye = w * w * $ + $ * w * w + w * $ * w, pe = w * w * w;
              for (M = 0; M < F; M += 1)
                  v[M * 4] = e.round((j * b[M] + K * x[M] + Y * E[M] + W * P[M]) * 1e3) / 1e3,
                  v[M * 4 + 1] = e.round((Z * b[M] + ee * x[M] + X * E[M] + D * P[M]) * 1e3) / 1e3,
                  v[M * 4 + 2] = e.round((B * b[M] + R * x[M] + L * E[M] + V * P[M]) * 1e3) / 1e3,
                  v[M * 4 + 3] = e.round((q * b[M] + oe * x[M] + ye * E[M] + pe * P[M]) * 1e3) / 1e3;
              return v
          }
          return {
              getSegmentsLength: o,
              getNewSegment: S,
              getPointInSegment: _,
              buildBezierData: d,
              pointOnLine2D: t,
              pointOnLine3D: r
          }
      }
      var bez = bezFunction()
        , initFrame = initialDefaultFrame
        , mathAbs = Math.abs;
      function interpolateValue(e, t) {
          var r = this.offsetTime, a;
          this.propType === "multidimensional" && (a = createTypedArray("float32", this.pv.length));
          for (var o = t.lastIndex, l = o, f = this.keyframes.length - 1, d = !0, g, _, v; d; ) {
              if (g = this.keyframes[l],
              _ = this.keyframes[l + 1],
              l === f - 1 && e >= _.t - r) {
                  g.h && (g = _),
                  o = 0;
                  break
              }
              if (_.t - r > e) {
                  o = l;
                  break
              }
              l < f - 1 ? l += 1 : (o = 0,
              d = !1)
          }
          v = this.keyframesMetadata[l] || {};
          var S, b, P, x, E, I, C = _.t - r, A = g.t - r, T;
          if (g.to) {
              v.bezierData || (v.bezierData = bez.buildBezierData(g.s, _.s || g.e, g.to, g.ti));
              var w = v.bezierData;
              if (e >= C || e < A) {
                  var M = e >= C ? w.points.length - 1 : 0;
                  for (b = w.points[M].point.length,
                  S = 0; S < b; S += 1)
                      a[S] = w.points[M].point[S]
              } else {
                  v.__fnct ? I = v.__fnct : (I = BezierFactory.getBezierEasing(g.o.x, g.o.y, g.i.x, g.i.y, g.n).get,
                  v.__fnct = I),
                  P = I((e - A) / (C - A));
                  var F = w.segmentLength * P, O, $ = t.lastFrame < e && t._lastKeyframeIndex === l ? t._lastAddedLength : 0;
                  for (E = t.lastFrame < e && t._lastKeyframeIndex === l ? t._lastPoint : 0,
                  d = !0,
                  x = w.points.length; d; ) {
                      if ($ += w.points[E].partialLength,
                      F === 0 || P === 0 || E === w.points.length - 1) {
                          for (b = w.points[E].point.length,
                          S = 0; S < b; S += 1)
                              a[S] = w.points[E].point[S];
                          break
                      } else if (F >= $ && F < $ + w.points[E + 1].partialLength) {
                          for (O = (F - $) / w.points[E + 1].partialLength,
                          b = w.points[E].point.length,
                          S = 0; S < b; S += 1)
                              a[S] = w.points[E].point[S] + (w.points[E + 1].point[S] - w.points[E].point[S]) * O;
                          break
                      }
                      E < x - 1 ? E += 1 : d = !1
                  }
                  t._lastPoint = E,
                  t._lastAddedLength = $ - w.points[E].partialLength,
                  t._lastKeyframeIndex = l
              }
          } else {
              var j, K, Y, W, Z;
              if (f = g.s.length,
              T = _.s || g.e,
              this.sh && g.h !== 1)
                  if (e >= C)
                      a[0] = T[0],
                      a[1] = T[1],
                      a[2] = T[2];
                  else if (e <= A)
                      a[0] = g.s[0],
                      a[1] = g.s[1],
                      a[2] = g.s[2];
                  else {
                      var ee = createQuaternion(g.s)
                        , X = createQuaternion(T)
                        , D = (e - A) / (C - A);
                      quaternionToEuler(a, slerp(ee, X, D))
                  }
              else
                  for (l = 0; l < f; l += 1)
                      g.h !== 1 && (e >= C ? P = 1 : e < A ? P = 0 : (g.o.x.constructor === Array ? (v.__fnct || (v.__fnct = []),
                      v.__fnct[l] ? I = v.__fnct[l] : (j = g.o.x[l] === void 0 ? g.o.x[0] : g.o.x[l],
                      K = g.o.y[l] === void 0 ? g.o.y[0] : g.o.y[l],
                      Y = g.i.x[l] === void 0 ? g.i.x[0] : g.i.x[l],
                      W = g.i.y[l] === void 0 ? g.i.y[0] : g.i.y[l],
                      I = BezierFactory.getBezierEasing(j, K, Y, W).get,
                      v.__fnct[l] = I)) : v.__fnct ? I = v.__fnct : (j = g.o.x,
                      K = g.o.y,
                      Y = g.i.x,
                      W = g.i.y,
                      I = BezierFactory.getBezierEasing(j, K, Y, W).get,
                      g.keyframeMetadata = I),
                      P = I((e - A) / (C - A)))),
                      T = _.s || g.e,
                      Z = g.h === 1 ? g.s[l] : g.s[l] + (T[l] - g.s[l]) * P,
                      this.propType === "multidimensional" ? a[l] = Z : a = Z
          }
          return t.lastIndex = o,
          a
      }
      function slerp(e, t, r) {
          var a = [], o = e[0], l = e[1], f = e[2], d = e[3], g = t[0], _ = t[1], v = t[2], S = t[3], b, P, x, E, I;
          return P = o * g + l * _ + f * v + d * S,
          P < 0 && (P = -P,
          g = -g,
          _ = -_,
          v = -v,
          S = -S),
          1 - P > 1e-6 ? (b = Math.acos(P),
          x = Math.sin(b),
          E = Math.sin((1 - r) * b) / x,
          I = Math.sin(r * b) / x) : (E = 1 - r,
          I = r),
          a[0] = E * o + I * g,
          a[1] = E * l + I * _,
          a[2] = E * f + I * v,
          a[3] = E * d + I * S,
          a
      }
      function quaternionToEuler(e, t) {
          var r = t[0]
            , a = t[1]
            , o = t[2]
            , l = t[3]
            , f = Math.atan2(2 * a * l - 2 * r * o, 1 - 2 * a * a - 2 * o * o)
            , d = Math.asin(2 * r * a + 2 * o * l)
            , g = Math.atan2(2 * r * l - 2 * a * o, 1 - 2 * r * r - 2 * o * o);
          e[0] = f / degToRads,
          e[1] = d / degToRads,
          e[2] = g / degToRads
      }
      function createQuaternion(e) {
          var t = e[0] * degToRads
            , r = e[1] * degToRads
            , a = e[2] * degToRads
            , o = Math.cos(t / 2)
            , l = Math.cos(r / 2)
            , f = Math.cos(a / 2)
            , d = Math.sin(t / 2)
            , g = Math.sin(r / 2)
            , _ = Math.sin(a / 2)
            , v = o * l * f - d * g * _
            , S = d * g * f + o * l * _
            , b = d * l * f + o * g * _
            , P = o * g * f - d * l * _;
          return [S, b, P, v]
      }
      function getValueAtCurrentTime() {
          var e = this.comp.renderedFrame - this.offsetTime
            , t = this.keyframes[0].t - this.offsetTime
            , r = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
          if (!(e === this._caching.lastFrame || this._caching.lastFrame !== initFrame && (this._caching.lastFrame >= r && e >= r || this._caching.lastFrame < t && e < t))) {
              this._caching.lastFrame >= e && (this._caching._lastKeyframeIndex = -1,
              this._caching.lastIndex = 0);
              var a = this.interpolateValue(e, this._caching);
              this.pv = a
          }
          return this._caching.lastFrame = e,
          this.pv
      }
      function setVValue(e) {
          var t;
          if (this.propType === "unidimensional")
              t = e * this.mult,
              mathAbs(this.v - t) > 1e-5 && (this.v = t,
              this._mdf = !0);
          else
              for (var r = 0, a = this.v.length; r < a; )
                  t = e[r] * this.mult,
                  mathAbs(this.v[r] - t) > 1e-5 && (this.v[r] = t,
                  this._mdf = !0),
                  r += 1
      }
      function processEffectsSequence() {
          if (!(this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length)) {
              if (this.lock) {
                  this.setVValue(this.pv);
                  return
              }
              this.lock = !0,
              this._mdf = this._isFirstFrame;
              var e, t = this.effectsSequence.length, r = this.kf ? this.pv : this.data.k;
              for (e = 0; e < t; e += 1)
                  r = this.effectsSequence[e](r);
              this.setVValue(r),
              this._isFirstFrame = !1,
              this.lock = !1,
              this.frameId = this.elem.globalData.frameId
          }
      }
      function addEffect(e) {
          this.effectsSequence.push(e),
          this.container.addDynamicProperty(this)
      }
      function ValueProperty(e, t, r, a) {
          this.propType = "unidimensional",
          this.mult = r || 1,
          this.data = t,
          this.v = r ? t.k * r : t.k,
          this.pv = t.k,
          this._mdf = !1,
          this.elem = e,
          this.container = a,
          this.comp = e.comp,
          this.k = !1,
          this.kf = !1,
          this.vel = 0,
          this.effectsSequence = [],
          this._isFirstFrame = !0,
          this.getValue = processEffectsSequence,
          this.setVValue = setVValue,
          this.addEffect = addEffect
      }
      function MultiDimensionalProperty(e, t, r, a) {
          this.propType = "multidimensional",
          this.mult = r || 1,
          this.data = t,
          this._mdf = !1,
          this.elem = e,
          this.container = a,
          this.comp = e.comp,
          this.k = !1,
          this.kf = !1,
          this.frameId = -1;
          var o, l = t.k.length;
          for (this.v = createTypedArray("float32", l),
          this.pv = createTypedArray("float32", l),
          this.vel = createTypedArray("float32", l),
          o = 0; o < l; o += 1)
              this.v[o] = t.k[o] * this.mult,
              this.pv[o] = t.k[o];
          this._isFirstFrame = !0,
          this.effectsSequence = [],
          this.getValue = processEffectsSequence,
          this.setVValue = setVValue,
          this.addEffect = addEffect
      }
      function KeyframedValueProperty(e, t, r, a) {
          this.propType = "unidimensional",
          this.keyframes = t.k,
          this.keyframesMetadata = [],
          this.offsetTime = e.data.st,
          this.frameId = -1,
          this._caching = {
              lastFrame: initFrame,
              lastIndex: 0,
              value: 0,
              _lastKeyframeIndex: -1
          },
          this.k = !0,
          this.kf = !0,
          this.data = t,
          this.mult = r || 1,
          this.elem = e,
          this.container = a,
          this.comp = e.comp,
          this.v = initFrame,
          this.pv = initFrame,
          this._isFirstFrame = !0,
          this.getValue = processEffectsSequence,
          this.setVValue = setVValue,
          this.interpolateValue = interpolateValue,
          this.effectsSequence = [getValueAtCurrentTime.bind(this)],
          this.addEffect = addEffect
      }
      function KeyframedMultidimensionalProperty(e, t, r, a) {
          this.propType = "multidimensional";
          var o, l = t.k.length, f, d, g, _;
          for (o = 0; o < l - 1; o += 1)
              t.k[o].to && t.k[o].s && t.k[o + 1] && t.k[o + 1].s && (f = t.k[o].s,
              d = t.k[o + 1].s,
              g = t.k[o].to,
              _ = t.k[o].ti,
              (f.length === 2 && !(f[0] === d[0] && f[1] === d[1]) && bez.pointOnLine2D(f[0], f[1], d[0], d[1], f[0] + g[0], f[1] + g[1]) && bez.pointOnLine2D(f[0], f[1], d[0], d[1], d[0] + _[0], d[1] + _[1]) || f.length === 3 && !(f[0] === d[0] && f[1] === d[1] && f[2] === d[2]) && bez.pointOnLine3D(f[0], f[1], f[2], d[0], d[1], d[2], f[0] + g[0], f[1] + g[1], f[2] + g[2]) && bez.pointOnLine3D(f[0], f[1], f[2], d[0], d[1], d[2], d[0] + _[0], d[1] + _[1], d[2] + _[2])) && (t.k[o].to = null,
              t.k[o].ti = null),
              f[0] === d[0] && f[1] === d[1] && g[0] === 0 && g[1] === 0 && _[0] === 0 && _[1] === 0 && (f.length === 2 || f[2] === d[2] && g[2] === 0 && _[2] === 0) && (t.k[o].to = null,
              t.k[o].ti = null));
          this.effectsSequence = [getValueAtCurrentTime.bind(this)],
          this.data = t,
          this.keyframes = t.k,
          this.keyframesMetadata = [],
          this.offsetTime = e.data.st,
          this.k = !0,
          this.kf = !0,
          this._isFirstFrame = !0,
          this.mult = r || 1,
          this.elem = e,
          this.container = a,
          this.comp = e.comp,
          this.getValue = processEffectsSequence,
          this.setVValue = setVValue,
          this.interpolateValue = interpolateValue,
          this.frameId = -1;
          var v = t.k[0].s.length;
          for (this.v = createTypedArray("float32", v),
          this.pv = createTypedArray("float32", v),
          o = 0; o < v; o += 1)
              this.v[o] = initFrame,
              this.pv[o] = initFrame;
          this._caching = {
              lastFrame: initFrame,
              lastIndex: 0,
              value: createTypedArray("float32", v)
          },
          this.addEffect = addEffect
      }
      var PropertyFactory = function() {
          function e(r, a, o, l, f) {
              a.sid && (a = r.globalData.slotManager.getProp(a));
              var d;
              if (!a.k.length)
                  d = new ValueProperty(r,a,l,f);
              else if (typeof a.k[0] == "number")
                  d = new MultiDimensionalProperty(r,a,l,f);
              else
                  switch (o) {
                  case 0:
                      d = new KeyframedValueProperty(r,a,l,f);
                      break;
                  case 1:
                      d = new KeyframedMultidimensionalProperty(r,a,l,f);
                      break
                  }
              return d.effectsSequence.length && f.addDynamicProperty(d),
              d
          }
          var t = {
              getProp: e
          };
          return t
      }();
      function DynamicPropertyContainer() {}
      DynamicPropertyContainer.prototype = {
          addDynamicProperty: function(t) {
              this.dynamicProperties.indexOf(t) === -1 && (this.dynamicProperties.push(t),
              this.container.addDynamicProperty(this),
              this._isAnimated = !0)
          },
          iterateDynamicProperties: function() {
              this._mdf = !1;
              var t, r = this.dynamicProperties.length;
              for (t = 0; t < r; t += 1)
                  this.dynamicProperties[t].getValue(),
                  this.dynamicProperties[t]._mdf && (this._mdf = !0)
          },
          initDynamicPropertyContainer: function(t) {
              this.container = t,
              this.dynamicProperties = [],
              this._mdf = !1,
              this._isAnimated = !1
          }
      };
      var pointPool = function() {
          function e() {
              return createTypedArray("float32", 2)
          }
          return poolFactory(8, e)
      }();
      function ShapePath() {
          this.c = !1,
          this._length = 0,
          this._maxLength = 8,
          this.v = createSizedArray(this._maxLength),
          this.o = createSizedArray(this._maxLength),
          this.i = createSizedArray(this._maxLength)
      }
      ShapePath.prototype.setPathData = function(e, t) {
          this.c = e,
          this.setLength(t);
          for (var r = 0; r < t; )
              this.v[r] = pointPool.newElement(),
              this.o[r] = pointPool.newElement(),
              this.i[r] = pointPool.newElement(),
              r += 1
      }
      ,
      ShapePath.prototype.setLength = function(e) {
          for (; this._maxLength < e; )
              this.doubleArrayLength();
          this._length = e
      }
      ,
      ShapePath.prototype.doubleArrayLength = function() {
          this.v = this.v.concat(createSizedArray(this._maxLength)),
          this.i = this.i.concat(createSizedArray(this._maxLength)),
          this.o = this.o.concat(createSizedArray(this._maxLength)),
          this._maxLength *= 2
      }
      ,
      ShapePath.prototype.setXYAt = function(e, t, r, a, o) {
          var l;
          switch (this._length = Math.max(this._length, a + 1),
          this._length >= this._maxLength && this.doubleArrayLength(),
          r) {
          case "v":
              l = this.v;
              break;
          case "i":
              l = this.i;
              break;
          case "o":
              l = this.o;
              break;
          default:
              l = [];
              break
          }
          (!l[a] || l[a] && !o) && (l[a] = pointPool.newElement()),
          l[a][0] = e,
          l[a][1] = t
      }
      ,
      ShapePath.prototype.setTripleAt = function(e, t, r, a, o, l, f, d) {
          this.setXYAt(e, t, "v", f, d),
          this.setXYAt(r, a, "o", f, d),
          this.setXYAt(o, l, "i", f, d)
      }
      ,
      ShapePath.prototype.reverse = function() {
          var e = new ShapePath;
          e.setPathData(this.c, this._length);
          var t = this.v
            , r = this.o
            , a = this.i
            , o = 0;
          this.c && (e.setTripleAt(t[0][0], t[0][1], a[0][0], a[0][1], r[0][0], r[0][1], 0, !1),
          o = 1);
          var l = this._length - 1, f = this._length, d;
          for (d = o; d < f; d += 1)
              e.setTripleAt(t[l][0], t[l][1], a[l][0], a[l][1], r[l][0], r[l][1], d, !1),
              l -= 1;
          return e
      }
      ,
      ShapePath.prototype.length = function() {
          return this._length
      }
      ;
      var shapePool = function() {
          function e() {
              return new ShapePath
          }
          function t(o) {
              var l = o._length, f;
              for (f = 0; f < l; f += 1)
                  pointPool.release(o.v[f]),
                  pointPool.release(o.i[f]),
                  pointPool.release(o.o[f]),
                  o.v[f] = null,
                  o.i[f] = null,
                  o.o[f] = null;
              o._length = 0,
              o.c = !1
          }
          function r(o) {
              var l = a.newElement(), f, d = o._length === void 0 ? o.v.length : o._length;
              for (l.setLength(d),
              l.c = o.c,
              f = 0; f < d; f += 1)
                  l.setTripleAt(o.v[f][0], o.v[f][1], o.o[f][0], o.o[f][1], o.i[f][0], o.i[f][1], f);
              return l
          }
          var a = poolFactory(4, e, t);
          return a.clone = r,
          a
      }();
      function ShapeCollection() {
          this._length = 0,
          this._maxLength = 4,
          this.shapes = createSizedArray(this._maxLength)
      }
      ShapeCollection.prototype.addShape = function(e) {
          this._length === this._maxLength && (this.shapes = this.shapes.concat(createSizedArray(this._maxLength)),
          this._maxLength *= 2),
          this.shapes[this._length] = e,
          this._length += 1
      }
      ,
      ShapeCollection.prototype.releaseShapes = function() {
          var e;
          for (e = 0; e < this._length; e += 1)
              shapePool.release(this.shapes[e]);
          this._length = 0
      }
      ;
      var shapeCollectionPool = function() {
          var e = {
              newShapeCollection: o,
              release: l
          }
            , t = 0
            , r = 4
            , a = createSizedArray(r);
          function o() {
              var f;
              return t ? (t -= 1,
              f = a[t]) : f = new ShapeCollection,
              f
          }
          function l(f) {
              var d, g = f._length;
              for (d = 0; d < g; d += 1)
                  shapePool.release(f.shapes[d]);
              f._length = 0,
              t === r && (a = pooling.double(a),
              r *= 2),
              a[t] = f,
              t += 1
          }
          return e
      }()
        , ShapePropertyFactory = function() {
          var e = -999999;
          function t(C, A, T) {
              var w = T.lastIndex, M, F, O, $, j, K, Y, W, Z, ee = this.keyframes;
              if (C < ee[0].t - this.offsetTime)
                  M = ee[0].s[0],
                  O = !0,
                  w = 0;
              else if (C >= ee[ee.length - 1].t - this.offsetTime)
                  M = ee[ee.length - 1].s ? ee[ee.length - 1].s[0] : ee[ee.length - 2].e[0],
                  O = !0;
              else {
                  for (var X = w, D = ee.length - 1, B = !0, R, L, V; B && (R = ee[X],
                  L = ee[X + 1],
                  !(L.t - this.offsetTime > C)); )
                      X < D - 1 ? X += 1 : B = !1;
                  if (V = this.keyframesMetadata[X] || {},
                  O = R.h === 1,
                  w = X,
                  !O) {
                      if (C >= L.t - this.offsetTime)
                          W = 1;
                      else if (C < R.t - this.offsetTime)
                          W = 0;
                      else {
                          var q;
                          V.__fnct ? q = V.__fnct : (q = BezierFactory.getBezierEasing(R.o.x, R.o.y, R.i.x, R.i.y).get,
                          V.__fnct = q),
                          W = q((C - (R.t - this.offsetTime)) / (L.t - this.offsetTime - (R.t - this.offsetTime)))
                      }
                      F = L.s ? L.s[0] : R.e[0]
                  }
                  M = R.s[0]
              }
              for (K = A._length,
              Y = M.i[0].length,
              T.lastIndex = w,
              $ = 0; $ < K; $ += 1)
                  for (j = 0; j < Y; j += 1)
                      Z = O ? M.i[$][j] : M.i[$][j] + (F.i[$][j] - M.i[$][j]) * W,
                      A.i[$][j] = Z,
                      Z = O ? M.o[$][j] : M.o[$][j] + (F.o[$][j] - M.o[$][j]) * W,
                      A.o[$][j] = Z,
                      Z = O ? M.v[$][j] : M.v[$][j] + (F.v[$][j] - M.v[$][j]) * W,
                      A.v[$][j] = Z
          }
          function r() {
              var C = this.comp.renderedFrame - this.offsetTime
                , A = this.keyframes[0].t - this.offsetTime
                , T = this.keyframes[this.keyframes.length - 1].t - this.offsetTime
                , w = this._caching.lastFrame;
              return w !== e && (w < A && C < A || w > T && C > T) || (this._caching.lastIndex = w < C ? this._caching.lastIndex : 0,
              this.interpolateShape(C, this.pv, this._caching)),
              this._caching.lastFrame = C,
              this.pv
          }
          function a() {
              this.paths = this.localShapeCollection
          }
          function o(C, A) {
              if (C._length !== A._length || C.c !== A.c)
                  return !1;
              var T, w = C._length;
              for (T = 0; T < w; T += 1)
                  if (C.v[T][0] !== A.v[T][0] || C.v[T][1] !== A.v[T][1] || C.o[T][0] !== A.o[T][0] || C.o[T][1] !== A.o[T][1] || C.i[T][0] !== A.i[T][0] || C.i[T][1] !== A.i[T][1])
                      return !1;
              return !0
          }
          function l(C) {
              o(this.v, C) || (this.v = shapePool.clone(C),
              this.localShapeCollection.releaseShapes(),
              this.localShapeCollection.addShape(this.v),
              this._mdf = !0,
              this.paths = this.localShapeCollection)
          }
          function f() {
              if (this.elem.globalData.frameId !== this.frameId) {
                  if (!this.effectsSequence.length) {
                      this._mdf = !1;
                      return
                  }
                  if (this.lock) {
                      this.setVValue(this.pv);
                      return
                  }
                  this.lock = !0,
                  this._mdf = !1;
                  var C;
                  this.kf ? C = this.pv : this.data.ks ? C = this.data.ks.k : C = this.data.pt.k;
                  var A, T = this.effectsSequence.length;
                  for (A = 0; A < T; A += 1)
                      C = this.effectsSequence[A](C);
                  this.setVValue(C),
                  this.lock = !1,
                  this.frameId = this.elem.globalData.frameId
              }
          }
          function d(C, A, T) {
              this.propType = "shape",
              this.comp = C.comp,
              this.container = C,
              this.elem = C,
              this.data = A,
              this.k = !1,
              this.kf = !1,
              this._mdf = !1;
              var w = T === 3 ? A.pt.k : A.ks.k;
              this.v = shapePool.clone(w),
              this.pv = shapePool.clone(this.v),
              this.localShapeCollection = shapeCollectionPool.newShapeCollection(),
              this.paths = this.localShapeCollection,
              this.paths.addShape(this.v),
              this.reset = a,
              this.effectsSequence = []
          }
          function g(C) {
              this.effectsSequence.push(C),
              this.container.addDynamicProperty(this)
          }
          d.prototype.interpolateShape = t,
          d.prototype.getValue = f,
          d.prototype.setVValue = l,
          d.prototype.addEffect = g;
          function _(C, A, T) {
              this.propType = "shape",
              this.comp = C.comp,
              this.elem = C,
              this.container = C,
              this.offsetTime = C.data.st,
              this.keyframes = T === 3 ? A.pt.k : A.ks.k,
              this.keyframesMetadata = [],
              this.k = !0,
              this.kf = !0;
              var w = this.keyframes[0].s[0].i.length;
              this.v = shapePool.newElement(),
              this.v.setPathData(this.keyframes[0].s[0].c, w),
              this.pv = shapePool.clone(this.v),
              this.localShapeCollection = shapeCollectionPool.newShapeCollection(),
              this.paths = this.localShapeCollection,
              this.paths.addShape(this.v),
              this.lastFrame = e,
              this.reset = a,
              this._caching = {
                  lastFrame: e,
                  lastIndex: 0
              },
              this.effectsSequence = [r.bind(this)]
          }
          _.prototype.getValue = f,
          _.prototype.interpolateShape = t,
          _.prototype.setVValue = l,
          _.prototype.addEffect = g;
          var v = function() {
              var C = roundCorner;
              function A(T, w) {
                  this.v = shapePool.newElement(),
                  this.v.setPathData(!0, 4),
                  this.localShapeCollection = shapeCollectionPool.newShapeCollection(),
                  this.paths = this.localShapeCollection,
                  this.localShapeCollection.addShape(this.v),
                  this.d = w.d,
                  this.elem = T,
                  this.comp = T.comp,
                  this.frameId = -1,
                  this.initDynamicPropertyContainer(T),
                  this.p = PropertyFactory.getProp(T, w.p, 1, 0, this),
                  this.s = PropertyFactory.getProp(T, w.s, 1, 0, this),
                  this.dynamicProperties.length ? this.k = !0 : (this.k = !1,
                  this.convertEllToPath())
              }
              return A.prototype = {
                  reset: a,
                  getValue: function() {
                      this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId,
                      this.iterateDynamicProperties(),
                      this._mdf && this.convertEllToPath())
                  },
                  convertEllToPath: function() {
                      var w = this.p.v[0]
                        , M = this.p.v[1]
                        , F = this.s.v[0] / 2
                        , O = this.s.v[1] / 2
                        , $ = this.d !== 3
                        , j = this.v;
                      j.v[0][0] = w,
                      j.v[0][1] = M - O,
                      j.v[1][0] = $ ? w + F : w - F,
                      j.v[1][1] = M,
                      j.v[2][0] = w,
                      j.v[2][1] = M + O,
                      j.v[3][0] = $ ? w - F : w + F,
                      j.v[3][1] = M,
                      j.i[0][0] = $ ? w - F * C : w + F * C,
                      j.i[0][1] = M - O,
                      j.i[1][0] = $ ? w + F : w - F,
                      j.i[1][1] = M - O * C,
                      j.i[2][0] = $ ? w + F * C : w - F * C,
                      j.i[2][1] = M + O,
                      j.i[3][0] = $ ? w - F : w + F,
                      j.i[3][1] = M + O * C,
                      j.o[0][0] = $ ? w + F * C : w - F * C,
                      j.o[0][1] = M - O,
                      j.o[1][0] = $ ? w + F : w - F,
                      j.o[1][1] = M + O * C,
                      j.o[2][0] = $ ? w - F * C : w + F * C,
                      j.o[2][1] = M + O,
                      j.o[3][0] = $ ? w - F : w + F,
                      j.o[3][1] = M - O * C
                  }
              },
              extendPrototype([DynamicPropertyContainer], A),
              A
          }()
            , S = function() {
              function C(A, T) {
                  this.v = shapePool.newElement(),
                  this.v.setPathData(!0, 0),
                  this.elem = A,
                  this.comp = A.comp,
                  this.data = T,
                  this.frameId = -1,
                  this.d = T.d,
                  this.initDynamicPropertyContainer(A),
                  T.sy === 1 ? (this.ir = PropertyFactory.getProp(A, T.ir, 0, 0, this),
                  this.is = PropertyFactory.getProp(A, T.is, 0, .01, this),
                  this.convertToPath = this.convertStarToPath) : this.convertToPath = this.convertPolygonToPath,
                  this.pt = PropertyFactory.getProp(A, T.pt, 0, 0, this),
                  this.p = PropertyFactory.getProp(A, T.p, 1, 0, this),
                  this.r = PropertyFactory.getProp(A, T.r, 0, degToRads, this),
                  this.or = PropertyFactory.getProp(A, T.or, 0, 0, this),
                  this.os = PropertyFactory.getProp(A, T.os, 0, .01, this),
                  this.localShapeCollection = shapeCollectionPool.newShapeCollection(),
                  this.localShapeCollection.addShape(this.v),
                  this.paths = this.localShapeCollection,
                  this.dynamicProperties.length ? this.k = !0 : (this.k = !1,
                  this.convertToPath())
              }
              return C.prototype = {
                  reset: a,
                  getValue: function() {
                      this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId,
                      this.iterateDynamicProperties(),
                      this._mdf && this.convertToPath())
                  },
                  convertStarToPath: function() {
                      var T = Math.floor(this.pt.v) * 2, w = Math.PI * 2 / T, M = !0, F = this.or.v, O = this.ir.v, $ = this.os.v, j = this.is.v, K = 2 * Math.PI * F / (T * 2), Y = 2 * Math.PI * O / (T * 2), W, Z, ee, X, D = -Math.PI / 2;
                      D += this.r.v;
                      var B = this.data.d === 3 ? -1 : 1;
                      for (this.v._length = 0,
                      W = 0; W < T; W += 1) {
                          Z = M ? F : O,
                          ee = M ? $ : j,
                          X = M ? K : Y;
                          var R = Z * Math.cos(D)
                            , L = Z * Math.sin(D)
                            , V = R === 0 && L === 0 ? 0 : L / Math.sqrt(R * R + L * L)
                            , q = R === 0 && L === 0 ? 0 : -R / Math.sqrt(R * R + L * L);
                          R += +this.p.v[0],
                          L += +this.p.v[1],
                          this.v.setTripleAt(R, L, R - V * X * ee * B, L - q * X * ee * B, R + V * X * ee * B, L + q * X * ee * B, W, !0),
                          M = !M,
                          D += w * B
                      }
                  },
                  convertPolygonToPath: function() {
                      var T = Math.floor(this.pt.v), w = Math.PI * 2 / T, M = this.or.v, F = this.os.v, O = 2 * Math.PI * M / (T * 4), $, j = -Math.PI * .5, K = this.data.d === 3 ? -1 : 1;
                      for (j += this.r.v,
                      this.v._length = 0,
                      $ = 0; $ < T; $ += 1) {
                          var Y = M * Math.cos(j)
                            , W = M * Math.sin(j)
                            , Z = Y === 0 && W === 0 ? 0 : W / Math.sqrt(Y * Y + W * W)
                            , ee = Y === 0 && W === 0 ? 0 : -Y / Math.sqrt(Y * Y + W * W);
                          Y += +this.p.v[0],
                          W += +this.p.v[1],
                          this.v.setTripleAt(Y, W, Y - Z * O * F * K, W - ee * O * F * K, Y + Z * O * F * K, W + ee * O * F * K, $, !0),
                          j += w * K
                      }
                      this.paths.length = 0,
                      this.paths[0] = this.v
                  }
              },
              extendPrototype([DynamicPropertyContainer], C),
              C
          }()
            , b = function() {
              function C(A, T) {
                  this.v = shapePool.newElement(),
                  this.v.c = !0,
                  this.localShapeCollection = shapeCollectionPool.newShapeCollection(),
                  this.localShapeCollection.addShape(this.v),
                  this.paths = this.localShapeCollection,
                  this.elem = A,
                  this.comp = A.comp,
                  this.frameId = -1,
                  this.d = T.d,
                  this.initDynamicPropertyContainer(A),
                  this.p = PropertyFactory.getProp(A, T.p, 1, 0, this),
                  this.s = PropertyFactory.getProp(A, T.s, 1, 0, this),
                  this.r = PropertyFactory.getProp(A, T.r, 0, 0, this),
                  this.dynamicProperties.length ? this.k = !0 : (this.k = !1,
                  this.convertRectToPath())
              }
              return C.prototype = {
                  convertRectToPath: function() {
                      var T = this.p.v[0]
                        , w = this.p.v[1]
                        , M = this.s.v[0] / 2
                        , F = this.s.v[1] / 2
                        , O = bmMin(M, F, this.r.v)
                        , $ = O * (1 - roundCorner);
                      this.v._length = 0,
                      this.d === 2 || this.d === 1 ? (this.v.setTripleAt(T + M, w - F + O, T + M, w - F + O, T + M, w - F + $, 0, !0),
                      this.v.setTripleAt(T + M, w + F - O, T + M, w + F - $, T + M, w + F - O, 1, !0),
                      O !== 0 ? (this.v.setTripleAt(T + M - O, w + F, T + M - O, w + F, T + M - $, w + F, 2, !0),
                      this.v.setTripleAt(T - M + O, w + F, T - M + $, w + F, T - M + O, w + F, 3, !0),
                      this.v.setTripleAt(T - M, w + F - O, T - M, w + F - O, T - M, w + F - $, 4, !0),
                      this.v.setTripleAt(T - M, w - F + O, T - M, w - F + $, T - M, w - F + O, 5, !0),
                      this.v.setTripleAt(T - M + O, w - F, T - M + O, w - F, T - M + $, w - F, 6, !0),
                      this.v.setTripleAt(T + M - O, w - F, T + M - $, w - F, T + M - O, w - F, 7, !0)) : (this.v.setTripleAt(T - M, w + F, T - M + $, w + F, T - M, w + F, 2),
                      this.v.setTripleAt(T - M, w - F, T - M, w - F + $, T - M, w - F, 3))) : (this.v.setTripleAt(T + M, w - F + O, T + M, w - F + $, T + M, w - F + O, 0, !0),
                      O !== 0 ? (this.v.setTripleAt(T + M - O, w - F, T + M - O, w - F, T + M - $, w - F, 1, !0),
                      this.v.setTripleAt(T - M + O, w - F, T - M + $, w - F, T - M + O, w - F, 2, !0),
                      this.v.setTripleAt(T - M, w - F + O, T - M, w - F + O, T - M, w - F + $, 3, !0),
                      this.v.setTripleAt(T - M, w + F - O, T - M, w + F - $, T - M, w + F - O, 4, !0),
                      this.v.setTripleAt(T - M + O, w + F, T - M + O, w + F, T - M + $, w + F, 5, !0),
                      this.v.setTripleAt(T + M - O, w + F, T + M - $, w + F, T + M - O, w + F, 6, !0),
                      this.v.setTripleAt(T + M, w + F - O, T + M, w + F - O, T + M, w + F - $, 7, !0)) : (this.v.setTripleAt(T - M, w - F, T - M + $, w - F, T - M, w - F, 1, !0),
                      this.v.setTripleAt(T - M, w + F, T - M, w + F - $, T - M, w + F, 2, !0),
                      this.v.setTripleAt(T + M, w + F, T + M - $, w + F, T + M, w + F, 3, !0)))
                  },
                  getValue: function() {
                      this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId,
                      this.iterateDynamicProperties(),
                      this._mdf && this.convertRectToPath())
                  },
                  reset: a
              },
              extendPrototype([DynamicPropertyContainer], C),
              C
          }();
          function P(C, A, T) {
              var w;
              if (T === 3 || T === 4) {
                  var M = T === 3 ? A.pt : A.ks
                    , F = M.k;
                  F.length ? w = new _(C,A,T) : w = new d(C,A,T)
              } else
                  T === 5 ? w = new b(C,A) : T === 6 ? w = new v(C,A) : T === 7 && (w = new S(C,A));
              return w.k && C.addDynamicProperty(w),
              w
          }
          function x() {
              return d
          }
          function E() {
              return _
          }
          var I = {};
          return I.getShapeProp = P,
          I.getConstructorFunction = x,
          I.getKeyframedConstructorFunction = E,
          I
      }();
      /*!
Transformation Matrix v2.0
(c) Epistemex 2014-2015
www.epistemex.com
By Ken Fyrstenberg
Contributions by leeoniya.
License: MIT, header required.
*/
      var Matrix = function() {
          var e = Math.cos
            , t = Math.sin
            , r = Math.tan
            , a = Math.round;
          function o() {
              return this.props[0] = 1,
              this.props[1] = 0,
              this.props[2] = 0,
              this.props[3] = 0,
              this.props[4] = 0,
              this.props[5] = 1,
              this.props[6] = 0,
              this.props[7] = 0,
              this.props[8] = 0,
              this.props[9] = 0,
              this.props[10] = 1,
              this.props[11] = 0,
              this.props[12] = 0,
              this.props[13] = 0,
              this.props[14] = 0,
              this.props[15] = 1,
              this
          }
          function l(R) {
              if (R === 0)
                  return this;
              var L = e(R)
                , V = t(R);
              return this._t(L, -V, 0, 0, V, L, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
          }
          function f(R) {
              if (R === 0)
                  return this;
              var L = e(R)
                , V = t(R);
              return this._t(1, 0, 0, 0, 0, L, -V, 0, 0, V, L, 0, 0, 0, 0, 1)
          }
          function d(R) {
              if (R === 0)
                  return this;
              var L = e(R)
                , V = t(R);
              return this._t(L, 0, V, 0, 0, 1, 0, 0, -V, 0, L, 0, 0, 0, 0, 1)
          }
          function g(R) {
              if (R === 0)
                  return this;
              var L = e(R)
                , V = t(R);
              return this._t(L, -V, 0, 0, V, L, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
          }
          function _(R, L) {
              return this._t(1, L, R, 1, 0, 0)
          }
          function v(R, L) {
              return this.shear(r(R), r(L))
          }
          function S(R, L) {
              var V = e(L)
                , q = t(L);
              return this._t(V, q, 0, 0, -q, V, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(1, 0, 0, 0, r(R), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(V, -q, 0, 0, q, V, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
          }
          function b(R, L, V) {
              return !V && V !== 0 && (V = 1),
              R === 1 && L === 1 && V === 1 ? this : this._t(R, 0, 0, 0, 0, L, 0, 0, 0, 0, V, 0, 0, 0, 0, 1)
          }
          function P(R, L, V, q, oe, ye, pe, Pe, me, Q, le, fe, ue, be, ge, H) {
              return this.props[0] = R,
              this.props[1] = L,
              this.props[2] = V,
              this.props[3] = q,
              this.props[4] = oe,
              this.props[5] = ye,
              this.props[6] = pe,
              this.props[7] = Pe,
              this.props[8] = me,
              this.props[9] = Q,
              this.props[10] = le,
              this.props[11] = fe,
              this.props[12] = ue,
              this.props[13] = be,
              this.props[14] = ge,
              this.props[15] = H,
              this
          }
          function x(R, L, V) {
              return V = V || 0,
              R !== 0 || L !== 0 || V !== 0 ? this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, R, L, V, 1) : this
          }
          function E(R, L, V, q, oe, ye, pe, Pe, me, Q, le, fe, ue, be, ge, H) {
              var z = this.props;
              if (R === 1 && L === 0 && V === 0 && q === 0 && oe === 0 && ye === 1 && pe === 0 && Pe === 0 && me === 0 && Q === 0 && le === 1 && fe === 0)
                  return z[12] = z[12] * R + z[15] * ue,
                  z[13] = z[13] * ye + z[15] * be,
                  z[14] = z[14] * le + z[15] * ge,
                  z[15] *= H,
                  this._identityCalculated = !1,
                  this;
              var J = z[0]
                , te = z[1]
                , U = z[2]
                , ne = z[3]
                , ie = z[4]
                , se = z[5]
                , ae = z[6]
                , re = z[7]
                , ce = z[8]
                , ve = z[9]
                , _e = z[10]
                , de = z[11]
                , Se = z[12]
                , Ee = z[13]
                , Re = z[14]
                , ke = z[15];
              return z[0] = J * R + te * oe + U * me + ne * ue,
              z[1] = J * L + te * ye + U * Q + ne * be,
              z[2] = J * V + te * pe + U * le + ne * ge,
              z[3] = J * q + te * Pe + U * fe + ne * H,
              z[4] = ie * R + se * oe + ae * me + re * ue,
              z[5] = ie * L + se * ye + ae * Q + re * be,
              z[6] = ie * V + se * pe + ae * le + re * ge,
              z[7] = ie * q + se * Pe + ae * fe + re * H,
              z[8] = ce * R + ve * oe + _e * me + de * ue,
              z[9] = ce * L + ve * ye + _e * Q + de * be,
              z[10] = ce * V + ve * pe + _e * le + de * ge,
              z[11] = ce * q + ve * Pe + _e * fe + de * H,
              z[12] = Se * R + Ee * oe + Re * me + ke * ue,
              z[13] = Se * L + Ee * ye + Re * Q + ke * be,
              z[14] = Se * V + Ee * pe + Re * le + ke * ge,
              z[15] = Se * q + Ee * Pe + Re * fe + ke * H,
              this._identityCalculated = !1,
              this
          }
          function I(R) {
              var L = R.props;
              return this.transform(L[0], L[1], L[2], L[3], L[4], L[5], L[6], L[7], L[8], L[9], L[10], L[11], L[12], L[13], L[14], L[15])
          }
          function C() {
              return this._identityCalculated || (this._identity = !(this.props[0] !== 1 || this.props[1] !== 0 || this.props[2] !== 0 || this.props[3] !== 0 || this.props[4] !== 0 || this.props[5] !== 1 || this.props[6] !== 0 || this.props[7] !== 0 || this.props[8] !== 0 || this.props[9] !== 0 || this.props[10] !== 1 || this.props[11] !== 0 || this.props[12] !== 0 || this.props[13] !== 0 || this.props[14] !== 0 || this.props[15] !== 1),
              this._identityCalculated = !0),
              this._identity
          }
          function A(R) {
              for (var L = 0; L < 16; ) {
                  if (R.props[L] !== this.props[L])
                      return !1;
                  L += 1
              }
              return !0
          }
          function T(R) {
              var L;
              for (L = 0; L < 16; L += 1)
                  R.props[L] = this.props[L];
              return R
          }
          function w(R) {
              var L;
              for (L = 0; L < 16; L += 1)
                  this.props[L] = R[L]
          }
          function M(R, L, V) {
              return {
                  x: R * this.props[0] + L * this.props[4] + V * this.props[8] + this.props[12],
                  y: R * this.props[1] + L * this.props[5] + V * this.props[9] + this.props[13],
                  z: R * this.props[2] + L * this.props[6] + V * this.props[10] + this.props[14]
              }
          }
          function F(R, L, V) {
              return R * this.props[0] + L * this.props[4] + V * this.props[8] + this.props[12]
          }
          function O(R, L, V) {
              return R * this.props[1] + L * this.props[5] + V * this.props[9] + this.props[13]
          }
          function $(R, L, V) {
              return R * this.props[2] + L * this.props[6] + V * this.props[10] + this.props[14]
          }
          function j() {
              var R = this.props[0] * this.props[5] - this.props[1] * this.props[4]
                , L = this.props[5] / R
                , V = -this.props[1] / R
                , q = -this.props[4] / R
                , oe = this.props[0] / R
                , ye = (this.props[4] * this.props[13] - this.props[5] * this.props[12]) / R
                , pe = -(this.props[0] * this.props[13] - this.props[1] * this.props[12]) / R
                , Pe = new Matrix;
              return Pe.props[0] = L,
              Pe.props[1] = V,
              Pe.props[4] = q,
              Pe.props[5] = oe,
              Pe.props[12] = ye,
              Pe.props[13] = pe,
              Pe
          }
          function K(R) {
              var L = this.getInverseMatrix();
              return L.applyToPointArray(R[0], R[1], R[2] || 0)
          }
          function Y(R) {
              var L, V = R.length, q = [];
              for (L = 0; L < V; L += 1)
                  q[L] = K(R[L]);
              return q
          }
          function W(R, L, V) {
              var q = createTypedArray("float32", 6);
              if (this.isIdentity())
                  q[0] = R[0],
                  q[1] = R[1],
                  q[2] = L[0],
                  q[3] = L[1],
                  q[4] = V[0],
                  q[5] = V[1];
              else {
                  var oe = this.props[0]
                    , ye = this.props[1]
                    , pe = this.props[4]
                    , Pe = this.props[5]
                    , me = this.props[12]
                    , Q = this.props[13];
                  q[0] = R[0] * oe + R[1] * pe + me,
                  q[1] = R[0] * ye + R[1] * Pe + Q,
                  q[2] = L[0] * oe + L[1] * pe + me,
                  q[3] = L[0] * ye + L[1] * Pe + Q,
                  q[4] = V[0] * oe + V[1] * pe + me,
                  q[5] = V[0] * ye + V[1] * Pe + Q
              }
              return q
          }
          function Z(R, L, V) {
              var q;
              return this.isIdentity() ? q = [R, L, V] : q = [R * this.props[0] + L * this.props[4] + V * this.props[8] + this.props[12], R * this.props[1] + L * this.props[5] + V * this.props[9] + this.props[13], R * this.props[2] + L * this.props[6] + V * this.props[10] + this.props[14]],
              q
          }
          function ee(R, L) {
              if (this.isIdentity())
                  return R + "," + L;
              var V = this.props;
              return Math.round((R * V[0] + L * V[4] + V[12]) * 100) / 100 + "," + Math.round((R * V[1] + L * V[5] + V[13]) * 100) / 100
          }
          function X() {
              for (var R = 0, L = this.props, V = "matrix3d(", q = 1e4; R < 16; )
                  V += a(L[R] * q) / q,
                  V += R === 15 ? ")" : ",",
                  R += 1;
              return V
          }
          function D(R) {
              var L = 1e4;
              return R < 1e-6 && R > 0 || R > -1e-6 && R < 0 ? a(R * L) / L : R
          }
          function B() {
              var R = this.props
                , L = D(R[0])
                , V = D(R[1])
                , q = D(R[4])
                , oe = D(R[5])
                , ye = D(R[12])
                , pe = D(R[13]);
              return "matrix(" + L + "," + V + "," + q + "," + oe + "," + ye + "," + pe + ")"
          }
          return function() {
              this.reset = o,
              this.rotate = l,
              this.rotateX = f,
              this.rotateY = d,
              this.rotateZ = g,
              this.skew = v,
              this.skewFromAxis = S,
              this.shear = _,
              this.scale = b,
              this.setTransform = P,
              this.translate = x,
              this.transform = E,
              this.multiply = I,
              this.applyToPoint = M,
              this.applyToX = F,
              this.applyToY = O,
              this.applyToZ = $,
              this.applyToPointArray = Z,
              this.applyToTriplePoints = W,
              this.applyToPointStringified = ee,
              this.toCSS = X,
              this.to2dCSS = B,
              this.clone = T,
              this.cloneFromProps = w,
              this.equals = A,
              this.inversePoints = Y,
              this.inversePoint = K,
              this.getInverseMatrix = j,
              this._t = this.transform,
              this.isIdentity = C,
              this._identity = !0,
              this._identityCalculated = !1,
              this.props = createTypedArray("float32", 16),
              this.reset()
          }
      }();
      function _typeof$3(e) {
          "@babel/helpers - typeof";
          return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$3 = function(r) {
              return typeof r
          }
          : _typeof$3 = function(r) {
              return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r
          }
          ,
          _typeof$3(e)
      }
      var lottie = {};
      function setLocation(e) {
          setLocationHref(e)
      }
      function searchAnimations() {
          animationManager.searchAnimations()
      }
      function setSubframeRendering(e) {
          setSubframeEnabled(e)
      }
      function setPrefix(e) {
          setIdPrefix(e)
      }
      function loadAnimation(e) {
          return animationManager.loadAnimation(e)
      }
      function setQuality(e) {
          if (typeof e == "string")
              switch (e) {
              case "high":
                  setDefaultCurveSegments(200);
                  break;
              default:
              case "medium":
                  setDefaultCurveSegments(50);
                  break;
              case "low":
                  setDefaultCurveSegments(10);
                  break
              }
          else
              !isNaN(e) && e > 1 && setDefaultCurveSegments(e)
      }
      function inBrowser() {
          return typeof navigator < "u"
      }
      function installPlugin(e, t) {
          e === "expressions" && setExpressionsPlugin(t)
      }
      function getFactory(e) {
          switch (e) {
          case "propertyFactory":
              return PropertyFactory;
          case "shapePropertyFactory":
              return ShapePropertyFactory;
          case "matrix":
              return Matrix;
          default:
              return null
          }
      }
      lottie.play = animationManager.play,
      lottie.pause = animationManager.pause,
      lottie.setLocationHref = setLocation,
      lottie.togglePause = animationManager.togglePause,
      lottie.setSpeed = animationManager.setSpeed,
      lottie.setDirection = animationManager.setDirection,
      lottie.stop = animationManager.stop,
      lottie.searchAnimations = searchAnimations,
      lottie.registerAnimation = animationManager.registerAnimation,
      lottie.loadAnimation = loadAnimation,
      lottie.setSubframeRendering = setSubframeRendering,
      lottie.resize = animationManager.resize,
      lottie.goToAndStop = animationManager.goToAndStop,
      lottie.destroy = animationManager.destroy,
      lottie.setQuality = setQuality,
      lottie.inBrowser = inBrowser,
      lottie.installPlugin = installPlugin,
      lottie.freeze = animationManager.freeze,
      lottie.unfreeze = animationManager.unfreeze,
      lottie.setVolume = animationManager.setVolume,
      lottie.mute = animationManager.mute,
      lottie.unmute = animationManager.unmute,
      lottie.getRegisteredAnimations = animationManager.getRegisteredAnimations,
      lottie.useWebWorker = setWebWorker,
      lottie.setIDPrefix = setPrefix,
      lottie.__getFactory = getFactory,
      lottie.version = "5.12.2";
      function checkReady() {
          document.readyState === "complete" && (clearInterval(readyStateCheckInterval),
          searchAnimations())
      }
      function getQueryVariable(e) {
          for (var t = queryString.split("&"), r = 0; r < t.length; r += 1) {
              var a = t[r].split("=");
              if (decodeURIComponent(a[0]) == e)
                  return decodeURIComponent(a[1])
          }
          return null
      }
      var queryString = "";
      {
          var scripts = document.getElementsByTagName("script")
            , index = scripts.length - 1
            , myScript = scripts[index] || {
              src: ""
          };
          queryString = myScript.src ? myScript.src.replace(/^[^\?]+\??/, "") : "",
          getQueryVariable("renderer")
      }
      var readyStateCheckInterval = setInterval(checkReady, 100);
      try {
          _typeof$3(exports) !== "object" && (window.bodymovin = lottie)
      } catch (e) {}
      var ShapeModifiers = function() {
          var e = {}
            , t = {};
          e.registerModifier = r,
          e.getModifier = a;
          function r(o, l) {
              t[o] || (t[o] = l)
          }
          function a(o, l, f) {
              return new t[o](l,f)
          }
          return e
      }();
      function ShapeModifier() {}
      ShapeModifier.prototype.initModifierProperties = function() {}
      ,
      ShapeModifier.prototype.addShapeToModifier = function() {}
      ,
      ShapeModifier.prototype.addShape = function(e) {
          if (!this.closed) {
              e.sh.container.addDynamicProperty(e.sh);
              var t = {
                  shape: e.sh,
                  data: e,
                  localShapeCollection: shapeCollectionPool.newShapeCollection()
              };
              this.shapes.push(t),
              this.addShapeToModifier(t),
              this._isAnimated && e.setAsAnimated()
          }
      }
      ,
      ShapeModifier.prototype.init = function(e, t) {
          this.shapes = [],
          this.elem = e,
          this.initDynamicPropertyContainer(e),
          this.initModifierProperties(e, t),
          this.frameId = initialDefaultFrame,
          this.closed = !1,
          this.k = !1,
          this.dynamicProperties.length ? this.k = !0 : this.getValue(!0)
      }
      ,
      ShapeModifier.prototype.processKeys = function() {
          this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId,
          this.iterateDynamicProperties())
      }
      ,
      extendPrototype([DynamicPropertyContainer], ShapeModifier);
      function TrimModifier() {}
      extendPrototype([ShapeModifier], TrimModifier),
      TrimModifier.prototype.initModifierProperties = function(e, t) {
          this.s = PropertyFactory.getProp(e, t.s, 0, .01, this),
          this.e = PropertyFactory.getProp(e, t.e, 0, .01, this),
          this.o = PropertyFactory.getProp(e, t.o, 0, 0, this),
          this.sValue = 0,
          this.eValue = 0,
          this.getValue = this.processKeys,
          this.m = t.m,
          this._isAnimated = !!this.s.effectsSequence.length || !!this.e.effectsSequence.length || !!this.o.effectsSequence.length
      }
      ,
      TrimModifier.prototype.addShapeToModifier = function(e) {
          e.pathsData = []
      }
      ,
      TrimModifier.prototype.calculateShapeEdges = function(e, t, r, a, o) {
          var l = [];
          t <= 1 ? l.push({
              s: e,
              e: t
          }) : e >= 1 ? l.push({
              s: e - 1,
              e: t - 1
          }) : (l.push({
              s: e,
              e: 1
          }),
          l.push({
              s: 0,
              e: t - 1
          }));
          var f = [], d, g = l.length, _;
          for (d = 0; d < g; d += 1)
              if (_ = l[d],
              !(_.e * o < a || _.s * o > a + r)) {
                  var v, S;
                  _.s * o <= a ? v = 0 : v = (_.s * o - a) / r,
                  _.e * o >= a + r ? S = 1 : S = (_.e * o - a) / r,
                  f.push([v, S])
              }
          return f.length || f.push([0, 0]),
          f
      }
      ,
      TrimModifier.prototype.releasePathsData = function(e) {
          var t, r = e.length;
          for (t = 0; t < r; t += 1)
              segmentsLengthPool.release(e[t]);
          return e.length = 0,
          e
      }
      ,
      TrimModifier.prototype.processShapes = function(e) {
          var t, r;
          if (this._mdf || e) {
              var a = this.o.v % 360 / 360;
              if (a < 0 && (a += 1),
              this.s.v > 1 ? t = 1 + a : this.s.v < 0 ? t = 0 + a : t = this.s.v + a,
              this.e.v > 1 ? r = 1 + a : this.e.v < 0 ? r = 0 + a : r = this.e.v + a,
              t > r) {
                  var o = t;
                  t = r,
                  r = o
              }
              t = Math.round(t * 1e4) * 1e-4,
              r = Math.round(r * 1e4) * 1e-4,
              this.sValue = t,
              this.eValue = r
          } else
              t = this.sValue,
              r = this.eValue;
          var l, f, d = this.shapes.length, g, _, v, S, b, P = 0;
          if (r === t)
              for (f = 0; f < d; f += 1)
                  this.shapes[f].localShapeCollection.releaseShapes(),
                  this.shapes[f].shape._mdf = !0,
                  this.shapes[f].shape.paths = this.shapes[f].localShapeCollection,
                  this._mdf && (this.shapes[f].pathsData.length = 0);
          else if (r === 1 && t === 0 || r === 0 && t === 1) {
              if (this._mdf)
                  for (f = 0; f < d; f += 1)
                      this.shapes[f].pathsData.length = 0,
                      this.shapes[f].shape._mdf = !0
          } else {
              var x = [], E, I;
              for (f = 0; f < d; f += 1)
                  if (E = this.shapes[f],
                  !E.shape._mdf && !this._mdf && !e && this.m !== 2)
                      E.shape.paths = E.localShapeCollection;
                  else {
                      if (l = E.shape.paths,
                      _ = l._length,
                      b = 0,
                      !E.shape._mdf && E.pathsData.length)
                          b = E.totalShapeLength;
                      else {
                          for (v = this.releasePathsData(E.pathsData),
                          g = 0; g < _; g += 1)
                              S = bez.getSegmentsLength(l.shapes[g]),
                              v.push(S),
                              b += S.totalLength;
                          E.totalShapeLength = b,
                          E.pathsData = v
                      }
                      P += b,
                      E.shape._mdf = !0
                  }
              var C = t, A = r, T = 0, w;
              for (f = d - 1; f >= 0; f -= 1)
                  if (E = this.shapes[f],
                  E.shape._mdf) {
                      for (I = E.localShapeCollection,
                      I.releaseShapes(),
                      this.m === 2 && d > 1 ? (w = this.calculateShapeEdges(t, r, E.totalShapeLength, T, P),
                      T += E.totalShapeLength) : w = [[C, A]],
                      _ = w.length,
                      g = 0; g < _; g += 1) {
                          C = w[g][0],
                          A = w[g][1],
                          x.length = 0,
                          A <= 1 ? x.push({
                              s: E.totalShapeLength * C,
                              e: E.totalShapeLength * A
                          }) : C >= 1 ? x.push({
                              s: E.totalShapeLength * (C - 1),
                              e: E.totalShapeLength * (A - 1)
                          }) : (x.push({
                              s: E.totalShapeLength * C,
                              e: E.totalShapeLength
                          }),
                          x.push({
                              s: 0,
                              e: E.totalShapeLength * (A - 1)
                          }));
                          var M = this.addShapes(E, x[0]);
                          if (x[0].s !== x[0].e) {
                              if (x.length > 1) {
                                  var F = E.shape.paths.shapes[E.shape.paths._length - 1];
                                  if (F.c) {
                                      var O = M.pop();
                                      this.addPaths(M, I),
                                      M = this.addShapes(E, x[1], O)
                                  } else
                                      this.addPaths(M, I),
                                      M = this.addShapes(E, x[1])
                              }
                              this.addPaths(M, I)
                          }
                      }
                      E.shape.paths = I
                  }
          }
      }
      ,
      TrimModifier.prototype.addPaths = function(e, t) {
          var r, a = e.length;
          for (r = 0; r < a; r += 1)
              t.addShape(e[r])
      }
      ,
      TrimModifier.prototype.addSegment = function(e, t, r, a, o, l, f) {
          o.setXYAt(t[0], t[1], "o", l),
          o.setXYAt(r[0], r[1], "i", l + 1),
          f && o.setXYAt(e[0], e[1], "v", l),
          o.setXYAt(a[0], a[1], "v", l + 1)
      }
      ,
      TrimModifier.prototype.addSegmentFromArray = function(e, t, r, a) {
          t.setXYAt(e[1], e[5], "o", r),
          t.setXYAt(e[2], e[6], "i", r + 1),
          a && t.setXYAt(e[0], e[4], "v", r),
          t.setXYAt(e[3], e[7], "v", r + 1)
      }
      ,
      TrimModifier.prototype.addShapes = function(e, t, r) {
          var a = e.pathsData, o = e.shape.paths.shapes, l, f = e.shape.paths._length, d, g, _ = 0, v, S, b, P, x = [], E, I = !0;
          for (r ? (S = r._length,
          E = r._length) : (r = shapePool.newElement(),
          S = 0,
          E = 0),
          x.push(r),
          l = 0; l < f; l += 1) {
              for (b = a[l].lengths,
              r.c = o[l].c,
              g = o[l].c ? b.length : b.length + 1,
              d = 1; d < g; d += 1)
                  if (v = b[d - 1],
                  _ + v.addedLength < t.s)
                      _ += v.addedLength,
                      r.c = !1;
                  else if (_ > t.e) {
                      r.c = !1;
                      break
                  } else
                      t.s <= _ && t.e >= _ + v.addedLength ? (this.addSegment(o[l].v[d - 1], o[l].o[d - 1], o[l].i[d], o[l].v[d], r, S, I),
                      I = !1) : (P = bez.getNewSegment(o[l].v[d - 1], o[l].v[d], o[l].o[d - 1], o[l].i[d], (t.s - _) / v.addedLength, (t.e - _) / v.addedLength, b[d - 1]),
                      this.addSegmentFromArray(P, r, S, I),
                      I = !1,
                      r.c = !1),
                      _ += v.addedLength,
                      S += 1;
              if (o[l].c && b.length) {
                  if (v = b[d - 1],
                  _ <= t.e) {
                      var C = b[d - 1].addedLength;
                      t.s <= _ && t.e >= _ + C ? (this.addSegment(o[l].v[d - 1], o[l].o[d - 1], o[l].i[0], o[l].v[0], r, S, I),
                      I = !1) : (P = bez.getNewSegment(o[l].v[d - 1], o[l].v[0], o[l].o[d - 1], o[l].i[0], (t.s - _) / C, (t.e - _) / C, b[d - 1]),
                      this.addSegmentFromArray(P, r, S, I),
                      I = !1,
                      r.c = !1)
                  } else
                      r.c = !1;
                  _ += v.addedLength,
                  S += 1
              }
              if (r._length && (r.setXYAt(r.v[E][0], r.v[E][1], "i", E),
              r.setXYAt(r.v[r._length - 1][0], r.v[r._length - 1][1], "o", r._length - 1)),
              _ > t.e)
                  break;
              l < f - 1 && (r = shapePool.newElement(),
              I = !0,
              x.push(r),
              S = 0)
          }
          return x
      }
      ;
      function PuckerAndBloatModifier() {}
      extendPrototype([ShapeModifier], PuckerAndBloatModifier),
      PuckerAndBloatModifier.prototype.initModifierProperties = function(e, t) {
          this.getValue = this.processKeys,
          this.amount = PropertyFactory.getProp(e, t.a, 0, null, this),
          this._isAnimated = !!this.amount.effectsSequence.length
      }
      ,
      PuckerAndBloatModifier.prototype.processPath = function(e, t) {
          var r = t / 100
            , a = [0, 0]
            , o = e._length
            , l = 0;
          for (l = 0; l < o; l += 1)
              a[0] += e.v[l][0],
              a[1] += e.v[l][1];
          a[0] /= o,
          a[1] /= o;
          var f = shapePool.newElement();
          f.c = e.c;
          var d, g, _, v, S, b;
          for (l = 0; l < o; l += 1)
              d = e.v[l][0] + (a[0] - e.v[l][0]) * r,
              g = e.v[l][1] + (a[1] - e.v[l][1]) * r,
              _ = e.o[l][0] + (a[0] - e.o[l][0]) * -r,
              v = e.o[l][1] + (a[1] - e.o[l][1]) * -r,
              S = e.i[l][0] + (a[0] - e.i[l][0]) * -r,
              b = e.i[l][1] + (a[1] - e.i[l][1]) * -r,
              f.setTripleAt(d, g, _, v, S, b, l);
          return f
      }
      ,
      PuckerAndBloatModifier.prototype.processShapes = function(e) {
          var t, r, a = this.shapes.length, o, l, f = this.amount.v;
          if (f !== 0) {
              var d, g;
              for (r = 0; r < a; r += 1) {
                  if (d = this.shapes[r],
                  g = d.localShapeCollection,
                  !(!d.shape._mdf && !this._mdf && !e))
                      for (g.releaseShapes(),
                      d.shape._mdf = !0,
                      t = d.shape.paths.shapes,
                      l = d.shape.paths._length,
                      o = 0; o < l; o += 1)
                          g.addShape(this.processPath(t[o], f));
                  d.shape.paths = d.localShapeCollection
              }
          }
          this.dynamicProperties.length || (this._mdf = !1)
      }
      ;
      var TransformPropertyFactory = function() {
          var e = [0, 0];
          function t(g) {
              var _ = this._mdf;
              this.iterateDynamicProperties(),
              this._mdf = this._mdf || _,
              this.a && g.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]),
              this.s && g.scale(this.s.v[0], this.s.v[1], this.s.v[2]),
              this.sk && g.skewFromAxis(-this.sk.v, this.sa.v),
              this.r ? g.rotate(-this.r.v) : g.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]),
              this.data.p.s ? this.data.p.z ? g.translate(this.px.v, this.py.v, -this.pz.v) : g.translate(this.px.v, this.py.v, 0) : g.translate(this.p.v[0], this.p.v[1], -this.p.v[2])
          }
          function r(g) {
              if (this.elem.globalData.frameId !== this.frameId) {
                  if (this._isDirty && (this.precalculateMatrix(),
                  this._isDirty = !1),
                  this.iterateDynamicProperties(),
                  this._mdf || g) {
                      var _;
                      if (this.v.cloneFromProps(this.pre.props),
                      this.appliedTransformations < 1 && this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]),
                      this.appliedTransformations < 2 && this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]),
                      this.sk && this.appliedTransformations < 3 && this.v.skewFromAxis(-this.sk.v, this.sa.v),
                      this.r && this.appliedTransformations < 4 ? this.v.rotate(-this.r.v) : !this.r && this.appliedTransformations < 4 && this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]),
                      this.autoOriented) {
                          var v, S;
                          if (_ = this.elem.globalData.frameRate,
                          this.p && this.p.keyframes && this.p.getValueAtTime)
                              this.p._caching.lastFrame + this.p.offsetTime <= this.p.keyframes[0].t ? (v = this.p.getValueAtTime((this.p.keyframes[0].t + .01) / _, 0),
                              S = this.p.getValueAtTime(this.p.keyframes[0].t / _, 0)) : this.p._caching.lastFrame + this.p.offsetTime >= this.p.keyframes[this.p.keyframes.length - 1].t ? (v = this.p.getValueAtTime(this.p.keyframes[this.p.keyframes.length - 1].t / _, 0),
                              S = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t - .05) / _, 0)) : (v = this.p.pv,
                              S = this.p.getValueAtTime((this.p._caching.lastFrame + this.p.offsetTime - .01) / _, this.p.offsetTime));
                          else if (this.px && this.px.keyframes && this.py.keyframes && this.px.getValueAtTime && this.py.getValueAtTime) {
                              v = [],
                              S = [];
                              var b = this.px
                                , P = this.py;
                              b._caching.lastFrame + b.offsetTime <= b.keyframes[0].t ? (v[0] = b.getValueAtTime((b.keyframes[0].t + .01) / _, 0),
                              v[1] = P.getValueAtTime((P.keyframes[0].t + .01) / _, 0),
                              S[0] = b.getValueAtTime(b.keyframes[0].t / _, 0),
                              S[1] = P.getValueAtTime(P.keyframes[0].t / _, 0)) : b._caching.lastFrame + b.offsetTime >= b.keyframes[b.keyframes.length - 1].t ? (v[0] = b.getValueAtTime(b.keyframes[b.keyframes.length - 1].t / _, 0),
                              v[1] = P.getValueAtTime(P.keyframes[P.keyframes.length - 1].t / _, 0),
                              S[0] = b.getValueAtTime((b.keyframes[b.keyframes.length - 1].t - .01) / _, 0),
                              S[1] = P.getValueAtTime((P.keyframes[P.keyframes.length - 1].t - .01) / _, 0)) : (v = [b.pv, P.pv],
                              S[0] = b.getValueAtTime((b._caching.lastFrame + b.offsetTime - .01) / _, b.offsetTime),
                              S[1] = P.getValueAtTime((P._caching.lastFrame + P.offsetTime - .01) / _, P.offsetTime))
                          } else
                              S = e,
                              v = S;
                          this.v.rotate(-Math.atan2(v[1] - S[1], v[0] - S[0]))
                      }
                      this.data.p && this.data.p.s ? this.data.p.z ? this.v.translate(this.px.v, this.py.v, -this.pz.v) : this.v.translate(this.px.v, this.py.v, 0) : this.v.translate(this.p.v[0], this.p.v[1], -this.p.v[2])
                  }
                  this.frameId = this.elem.globalData.frameId
              }
          }
          function a() {
              if (this.appliedTransformations = 0,
              this.pre.reset(),
              !this.a.effectsSequence.length)
                  this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]),
                  this.appliedTransformations = 1;
              else
                  return;
              if (!this.s.effectsSequence.length)
                  this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]),
                  this.appliedTransformations = 2;
              else
                  return;
              if (this.sk)
                  if (!this.sk.effectsSequence.length && !this.sa.effectsSequence.length)
                      this.pre.skewFromAxis(-this.sk.v, this.sa.v),
                      this.appliedTransformations = 3;
                  else
                      return;
              this.r ? this.r.effectsSequence.length || (this.pre.rotate(-this.r.v),
              this.appliedTransformations = 4) : !this.rz.effectsSequence.length && !this.ry.effectsSequence.length && !this.rx.effectsSequence.length && !this.or.effectsSequence.length && (this.pre.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]),
              this.appliedTransformations = 4)
          }
          function o() {}
          function l(g) {
              this._addDynamicProperty(g),
              this.elem.addDynamicProperty(g),
              this._isDirty = !0
          }
          function f(g, _, v) {
              if (this.elem = g,
              this.frameId = -1,
              this.propType = "transform",
              this.data = _,
              this.v = new Matrix,
              this.pre = new Matrix,
              this.appliedTransformations = 0,
              this.initDynamicPropertyContainer(v || g),
              _.p && _.p.s ? (this.px = PropertyFactory.getProp(g, _.p.x, 0, 0, this),
              this.py = PropertyFactory.getProp(g, _.p.y, 0, 0, this),
              _.p.z && (this.pz = PropertyFactory.getProp(g, _.p.z, 0, 0, this))) : this.p = PropertyFactory.getProp(g, _.p || {
                  k: [0, 0, 0]
              }, 1, 0, this),
              _.rx) {
                  if (this.rx = PropertyFactory.getProp(g, _.rx, 0, degToRads, this),
                  this.ry = PropertyFactory.getProp(g, _.ry, 0, degToRads, this),
                  this.rz = PropertyFactory.getProp(g, _.rz, 0, degToRads, this),
                  _.or.k[0].ti) {
                      var S, b = _.or.k.length;
                      for (S = 0; S < b; S += 1)
                          _.or.k[S].to = null,
                          _.or.k[S].ti = null
                  }
                  this.or = PropertyFactory.getProp(g, _.or, 1, degToRads, this),
                  this.or.sh = !0
              } else
                  this.r = PropertyFactory.getProp(g, _.r || {
                      k: 0
                  }, 0, degToRads, this);
              _.sk && (this.sk = PropertyFactory.getProp(g, _.sk, 0, degToRads, this),
              this.sa = PropertyFactory.getProp(g, _.sa, 0, degToRads, this)),
              this.a = PropertyFactory.getProp(g, _.a || {
                  k: [0, 0, 0]
              }, 1, 0, this),
              this.s = PropertyFactory.getProp(g, _.s || {
                  k: [100, 100, 100]
              }, 1, .01, this),
              _.o ? this.o = PropertyFactory.getProp(g, _.o, 0, .01, g) : this.o = {
                  _mdf: !1,
                  v: 1
              },
              this._isDirty = !0,
              this.dynamicProperties.length || this.getValue(!0)
          }
          f.prototype = {
              applyToMatrix: t,
              getValue: r,
              precalculateMatrix: a,
              autoOrient: o
          },
          extendPrototype([DynamicPropertyContainer], f),
          f.prototype.addDynamicProperty = l,
          f.prototype._addDynamicProperty = DynamicPropertyContainer.prototype.addDynamicProperty;
          function d(g, _, v) {
              return new f(g,_,v)
          }
          return {
              getTransformProperty: d
          }
      }();
      function RepeaterModifier() {}
      extendPrototype([ShapeModifier], RepeaterModifier),
      RepeaterModifier.prototype.initModifierProperties = function(e, t) {
          this.getValue = this.processKeys,
          this.c = PropertyFactory.getProp(e, t.c, 0, null, this),
          this.o = PropertyFactory.getProp(e, t.o, 0, null, this),
          this.tr = TransformPropertyFactory.getTransformProperty(e, t.tr, this),
          this.so = PropertyFactory.getProp(e, t.tr.so, 0, .01, this),
          this.eo = PropertyFactory.getProp(e, t.tr.eo, 0, .01, this),
          this.data = t,
          this.dynamicProperties.length || this.getValue(!0),
          this._isAnimated = !!this.dynamicProperties.length,
          this.pMatrix = new Matrix,
          this.rMatrix = new Matrix,
          this.sMatrix = new Matrix,
          this.tMatrix = new Matrix,
          this.matrix = new Matrix
      }
      ,
      RepeaterModifier.prototype.applyTransforms = function(e, t, r, a, o, l) {
          var f = l ? -1 : 1
            , d = a.s.v[0] + (1 - a.s.v[0]) * (1 - o)
            , g = a.s.v[1] + (1 - a.s.v[1]) * (1 - o);
          e.translate(a.p.v[0] * f * o, a.p.v[1] * f * o, a.p.v[2]),
          t.translate(-a.a.v[0], -a.a.v[1], a.a.v[2]),
          t.rotate(-a.r.v * f * o),
          t.translate(a.a.v[0], a.a.v[1], a.a.v[2]),
          r.translate(-a.a.v[0], -a.a.v[1], a.a.v[2]),
          r.scale(l ? 1 / d : d, l ? 1 / g : g),
          r.translate(a.a.v[0], a.a.v[1], a.a.v[2])
      }
      ,
      RepeaterModifier.prototype.init = function(e, t, r, a) {
          for (this.elem = e,
          this.arr = t,
          this.pos = r,
          this.elemsData = a,
          this._currentCopies = 0,
          this._elements = [],
          this._groups = [],
          this.frameId = -1,
          this.initDynamicPropertyContainer(e),
          this.initModifierProperties(e, t[r]); r > 0; )
              r -= 1,
              this._elements.unshift(t[r]);
          this.dynamicProperties.length ? this.k = !0 : this.getValue(!0)
      }
      ,
      RepeaterModifier.prototype.resetElements = function(e) {
          var t, r = e.length;
          for (t = 0; t < r; t += 1)
              e[t]._processed = !1,
              e[t].ty === "gr" && this.resetElements(e[t].it)
      }
      ,
      RepeaterModifier.prototype.cloneElements = function(e) {
          var t = JSON.parse(JSON.stringify(e));
          return this.resetElements(t),
          t
      }
      ,
      RepeaterModifier.prototype.changeGroupRender = function(e, t) {
          var r, a = e.length;
          for (r = 0; r < a; r += 1)
              e[r]._render = t,
              e[r].ty === "gr" && this.changeGroupRender(e[r].it, t)
      }
      ,
      RepeaterModifier.prototype.processShapes = function(e) {
          var t, r, a, o, l, f = !1;
          if (this._mdf || e) {
              var d = Math.ceil(this.c.v);
              if (this._groups.length < d) {
                  for (; this._groups.length < d; ) {
                      var g = {
                          it: this.cloneElements(this._elements),
                          ty: "gr"
                      };
                      g.it.push({
                          a: {
                              a: 0,
                              ix: 1,
                              k: [0, 0]
                          },
                          nm: "Transform",
                          o: {
                              a: 0,
                              ix: 7,
                              k: 100
                          },
                          p: {
                              a: 0,
                              ix: 2,
                              k: [0, 0]
                          },
                          r: {
                              a: 1,
                              ix: 6,
                              k: [{
                                  s: 0,
                                  e: 0,
                                  t: 0
                              }, {
                                  s: 0,
                                  e: 0,
                                  t: 1
                              }]
                          },
                          s: {
                              a: 0,
                              ix: 3,
                              k: [100, 100]
                          },
                          sa: {
                              a: 0,
                              ix: 5,
                              k: 0
                          },
                          sk: {
                              a: 0,
                              ix: 4,
                              k: 0
                          },
                          ty: "tr"
                      }),
                      this.arr.splice(0, 0, g),
                      this._groups.splice(0, 0, g),
                      this._currentCopies += 1
                  }
                  this.elem.reloadShapes(),
                  f = !0
              }
              l = 0;
              var _;
              for (a = 0; a <= this._groups.length - 1; a += 1) {
                  if (_ = l < d,
                  this._groups[a]._render = _,
                  this.changeGroupRender(this._groups[a].it, _),
                  !_) {
                      var v = this.elemsData[a].it
                        , S = v[v.length - 1];
                      S.transform.op.v !== 0 ? (S.transform.op._mdf = !0,
                      S.transform.op.v = 0) : S.transform.op._mdf = !1
                  }
                  l += 1
              }
              this._currentCopies = d;
              var b = this.o.v
                , P = b % 1
                , x = b > 0 ? Math.floor(b) : Math.ceil(b)
                , E = this.pMatrix.props
                , I = this.rMatrix.props
                , C = this.sMatrix.props;
              this.pMatrix.reset(),
              this.rMatrix.reset(),
              this.sMatrix.reset(),
              this.tMatrix.reset(),
              this.matrix.reset();
              var A = 0;
              if (b > 0) {
                  for (; A < x; )
                      this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !1),
                      A += 1;
                  P && (this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, P, !1),
                  A += P)
              } else if (b < 0) {
                  for (; A > x; )
                      this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !0),
                      A -= 1;
                  P && (this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, -P, !0),
                  A -= P)
              }
              a = this.data.m === 1 ? 0 : this._currentCopies - 1,
              o = this.data.m === 1 ? 1 : -1,
              l = this._currentCopies;
              for (var T, w; l; ) {
                  if (t = this.elemsData[a].it,
                  r = t[t.length - 1].transform.mProps.v.props,
                  w = r.length,
                  t[t.length - 1].transform.mProps._mdf = !0,
                  t[t.length - 1].transform.op._mdf = !0,
                  t[t.length - 1].transform.op.v = this._currentCopies === 1 ? this.so.v : this.so.v + (this.eo.v - this.so.v) * (a / (this._currentCopies - 1)),
                  A !== 0) {
                      for ((a !== 0 && o === 1 || a !== this._currentCopies - 1 && o === -1) && this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !1),
                      this.matrix.transform(I[0], I[1], I[2], I[3], I[4], I[5], I[6], I[7], I[8], I[9], I[10], I[11], I[12], I[13], I[14], I[15]),
                      this.matrix.transform(C[0], C[1], C[2], C[3], C[4], C[5], C[6], C[7], C[8], C[9], C[10], C[11], C[12], C[13], C[14], C[15]),
                      this.matrix.transform(E[0], E[1], E[2], E[3], E[4], E[5], E[6], E[7], E[8], E[9], E[10], E[11], E[12], E[13], E[14], E[15]),
                      T = 0; T < w; T += 1)
                          r[T] = this.matrix.props[T];
                      this.matrix.reset()
                  } else
                      for (this.matrix.reset(),
                      T = 0; T < w; T += 1)
                          r[T] = this.matrix.props[T];
                  A += 1,
                  l -= 1,
                  a += o
              }
          } else
              for (l = this._currentCopies,
              a = 0,
              o = 1; l; )
                  t = this.elemsData[a].it,
                  r = t[t.length - 1].transform.mProps.v.props,
                  t[t.length - 1].transform.mProps._mdf = !1,
                  t[t.length - 1].transform.op._mdf = !1,
                  l -= 1,
                  a += o;
          return f
      }
      ,
      RepeaterModifier.prototype.addShape = function() {}
      ;
      function RoundCornersModifier() {}
      extendPrototype([ShapeModifier], RoundCornersModifier),
      RoundCornersModifier.prototype.initModifierProperties = function(e, t) {
          this.getValue = this.processKeys,
          this.rd = PropertyFactory.getProp(e, t.r, 0, null, this),
          this._isAnimated = !!this.rd.effectsSequence.length
      }
      ,
      RoundCornersModifier.prototype.processPath = function(e, t) {
          var r = shapePool.newElement();
          r.c = e.c;
          var a, o = e._length, l, f, d, g, _, v, S = 0, b, P, x, E, I, C;
          for (a = 0; a < o; a += 1)
              l = e.v[a],
              d = e.o[a],
              f = e.i[a],
              l[0] === d[0] && l[1] === d[1] && l[0] === f[0] && l[1] === f[1] ? (a === 0 || a === o - 1) && !e.c ? (r.setTripleAt(l[0], l[1], d[0], d[1], f[0], f[1], S),
              S += 1) : (a === 0 ? g = e.v[o - 1] : g = e.v[a - 1],
              _ = Math.sqrt(Math.pow(l[0] - g[0], 2) + Math.pow(l[1] - g[1], 2)),
              v = _ ? Math.min(_ / 2, t) / _ : 0,
              I = l[0] + (g[0] - l[0]) * v,
              b = I,
              C = l[1] - (l[1] - g[1]) * v,
              P = C,
              x = b - (b - l[0]) * roundCorner,
              E = P - (P - l[1]) * roundCorner,
              r.setTripleAt(b, P, x, E, I, C, S),
              S += 1,
              a === o - 1 ? g = e.v[0] : g = e.v[a + 1],
              _ = Math.sqrt(Math.pow(l[0] - g[0], 2) + Math.pow(l[1] - g[1], 2)),
              v = _ ? Math.min(_ / 2, t) / _ : 0,
              x = l[0] + (g[0] - l[0]) * v,
              b = x,
              E = l[1] + (g[1] - l[1]) * v,
              P = E,
              I = b - (b - l[0]) * roundCorner,
              C = P - (P - l[1]) * roundCorner,
              r.setTripleAt(b, P, x, E, I, C, S),
              S += 1) : (r.setTripleAt(e.v[a][0], e.v[a][1], e.o[a][0], e.o[a][1], e.i[a][0], e.i[a][1], S),
              S += 1);
          return r
      }
      ,
      RoundCornersModifier.prototype.processShapes = function(e) {
          var t, r, a = this.shapes.length, o, l, f = this.rd.v;
          if (f !== 0) {
              var d, g;
              for (r = 0; r < a; r += 1) {
                  if (d = this.shapes[r],
                  g = d.localShapeCollection,
                  !(!d.shape._mdf && !this._mdf && !e))
                      for (g.releaseShapes(),
                      d.shape._mdf = !0,
                      t = d.shape.paths.shapes,
                      l = d.shape.paths._length,
                      o = 0; o < l; o += 1)
                          g.addShape(this.processPath(t[o], f));
                  d.shape.paths = d.localShapeCollection
              }
          }
          this.dynamicProperties.length || (this._mdf = !1)
      }
      ;
      function floatEqual(e, t) {
          return Math.abs(e - t) * 1e5 <= Math.min(Math.abs(e), Math.abs(t))
      }
      function floatZero(e) {
          return Math.abs(e) <= 1e-5
      }
      function lerp(e, t, r) {
          return e * (1 - r) + t * r
      }
      function lerpPoint(e, t, r) {
          return [lerp(e[0], t[0], r), lerp(e[1], t[1], r)]
      }
      function quadRoots(e, t, r) {
          if (e === 0)
              return [];
          var a = t * t - 4 * e * r;
          if (a < 0)
              return [];
          var o = -t / (2 * e);
          if (a === 0)
              return [o];
          var l = Math.sqrt(a) / (2 * e);
          return [o - l, o + l]
      }
      function polynomialCoefficients(e, t, r, a) {
          return [-e + 3 * t - 3 * r + a, 3 * e - 6 * t + 3 * r, -3 * e + 3 * t, e]
      }
      function singlePoint(e) {
          return new PolynomialBezier(e,e,e,e,!1)
      }
      function PolynomialBezier(e, t, r, a, o) {
          o && pointEqual(e, t) && (t = lerpPoint(e, a, 1 / 3)),
          o && pointEqual(r, a) && (r = lerpPoint(e, a, 2 / 3));
          var l = polynomialCoefficients(e[0], t[0], r[0], a[0])
            , f = polynomialCoefficients(e[1], t[1], r[1], a[1]);
          this.a = [l[0], f[0]],
          this.b = [l[1], f[1]],
          this.c = [l[2], f[2]],
          this.d = [l[3], f[3]],
          this.points = [e, t, r, a]
      }
      PolynomialBezier.prototype.point = function(e) {
          return [((this.a[0] * e + this.b[0]) * e + this.c[0]) * e + this.d[0], ((this.a[1] * e + this.b[1]) * e + this.c[1]) * e + this.d[1]]
      }
      ,
      PolynomialBezier.prototype.derivative = function(e) {
          return [(3 * e * this.a[0] + 2 * this.b[0]) * e + this.c[0], (3 * e * this.a[1] + 2 * this.b[1]) * e + this.c[1]]
      }
      ,
      PolynomialBezier.prototype.tangentAngle = function(e) {
          var t = this.derivative(e);
          return Math.atan2(t[1], t[0])
      }
      ,
      PolynomialBezier.prototype.normalAngle = function(e) {
          var t = this.derivative(e);
          return Math.atan2(t[0], t[1])
      }
      ,
      PolynomialBezier.prototype.inflectionPoints = function() {
          var e = this.a[1] * this.b[0] - this.a[0] * this.b[1];
          if (floatZero(e))
              return [];
          var t = -.5 * (this.a[1] * this.c[0] - this.a[0] * this.c[1]) / e
            , r = t * t - 1 / 3 * (this.b[1] * this.c[0] - this.b[0] * this.c[1]) / e;
          if (r < 0)
              return [];
          var a = Math.sqrt(r);
          return floatZero(a) ? a > 0 && a < 1 ? [t] : [] : [t - a, t + a].filter(function(o) {
              return o > 0 && o < 1
          })
      }
      ,
      PolynomialBezier.prototype.split = function(e) {
          if (e <= 0)
              return [singlePoint(this.points[0]), this];
          if (e >= 1)
              return [this, singlePoint(this.points[this.points.length - 1])];
          var t = lerpPoint(this.points[0], this.points[1], e)
            , r = lerpPoint(this.points[1], this.points[2], e)
            , a = lerpPoint(this.points[2], this.points[3], e)
            , o = lerpPoint(t, r, e)
            , l = lerpPoint(r, a, e)
            , f = lerpPoint(o, l, e);
          return [new PolynomialBezier(this.points[0],t,o,f,!0), new PolynomialBezier(f,l,a,this.points[3],!0)]
      }
      ;
      function extrema(e, t) {
          var r = e.points[0][t]
            , a = e.points[e.points.length - 1][t];
          if (r > a) {
              var o = a;
              a = r,
              r = o
          }
          for (var l = quadRoots(3 * e.a[t], 2 * e.b[t], e.c[t]), f = 0; f < l.length; f += 1)
              if (l[f] > 0 && l[f] < 1) {
                  var d = e.point(l[f])[t];
                  d < r ? r = d : d > a && (a = d)
              }
          return {
              min: r,
              max: a
          }
      }
      PolynomialBezier.prototype.bounds = function() {
          return {
              x: extrema(this, 0),
              y: extrema(this, 1)
          }
      }
      ,
      PolynomialBezier.prototype.boundingBox = function() {
          var e = this.bounds();
          return {
              left: e.x.min,
              right: e.x.max,
              top: e.y.min,
              bottom: e.y.max,
              width: e.x.max - e.x.min,
              height: e.y.max - e.y.min,
              cx: (e.x.max + e.x.min) / 2,
              cy: (e.y.max + e.y.min) / 2
          }
      }
      ;
      function intersectData(e, t, r) {
          var a = e.boundingBox();
          return {
              cx: a.cx,
              cy: a.cy,
              width: a.width,
              height: a.height,
              bez: e,
              t: (t + r) / 2,
              t1: t,
              t2: r
          }
      }
      function splitData(e) {
          var t = e.bez.split(.5);
          return [intersectData(t[0], e.t1, e.t), intersectData(t[1], e.t, e.t2)]
      }
      function boxIntersect(e, t) {
          return Math.abs(e.cx - t.cx) * 2 < e.width + t.width && Math.abs(e.cy - t.cy) * 2 < e.height + t.height
      }
      function intersectsImpl(e, t, r, a, o, l) {
          if (boxIntersect(e, t)) {
              if (r >= l || e.width <= a && e.height <= a && t.width <= a && t.height <= a) {
                  o.push([e.t, t.t]);
                  return
              }
              var f = splitData(e)
                , d = splitData(t);
              intersectsImpl(f[0], d[0], r + 1, a, o, l),
              intersectsImpl(f[0], d[1], r + 1, a, o, l),
              intersectsImpl(f[1], d[0], r + 1, a, o, l),
              intersectsImpl(f[1], d[1], r + 1, a, o, l)
          }
      }
      PolynomialBezier.prototype.intersections = function(e, t, r) {
          t === void 0 && (t = 2),
          r === void 0 && (r = 7);
          var a = [];
          return intersectsImpl(intersectData(this, 0, 1), intersectData(e, 0, 1), 0, t, a, r),
          a
      }
      ,
      PolynomialBezier.shapeSegment = function(e, t) {
          var r = (t + 1) % e.length();
          return new PolynomialBezier(e.v[t],e.o[t],e.i[r],e.v[r],!0)
      }
      ,
      PolynomialBezier.shapeSegmentInverted = function(e, t) {
          var r = (t + 1) % e.length();
          return new PolynomialBezier(e.v[r],e.i[r],e.o[t],e.v[t],!0)
      }
      ;
      function crossProduct(e, t) {
          return [e[1] * t[2] - e[2] * t[1], e[2] * t[0] - e[0] * t[2], e[0] * t[1] - e[1] * t[0]]
      }
      function lineIntersection(e, t, r, a) {
          var o = [e[0], e[1], 1]
            , l = [t[0], t[1], 1]
            , f = [r[0], r[1], 1]
            , d = [a[0], a[1], 1]
            , g = crossProduct(crossProduct(o, l), crossProduct(f, d));
          return floatZero(g[2]) ? null : [g[0] / g[2], g[1] / g[2]]
      }
      function polarOffset(e, t, r) {
          return [e[0] + Math.cos(t) * r, e[1] - Math.sin(t) * r]
      }
      function pointDistance(e, t) {
          return Math.hypot(e[0] - t[0], e[1] - t[1])
      }
      function pointEqual(e, t) {
          return floatEqual(e[0], t[0]) && floatEqual(e[1], t[1])
      }
      function ZigZagModifier() {}
      extendPrototype([ShapeModifier], ZigZagModifier),
      ZigZagModifier.prototype.initModifierProperties = function(e, t) {
          this.getValue = this.processKeys,
          this.amplitude = PropertyFactory.getProp(e, t.s, 0, null, this),
          this.frequency = PropertyFactory.getProp(e, t.r, 0, null, this),
          this.pointsType = PropertyFactory.getProp(e, t.pt, 0, null, this),
          this._isAnimated = this.amplitude.effectsSequence.length !== 0 || this.frequency.effectsSequence.length !== 0 || this.pointsType.effectsSequence.length !== 0
      }
      ;
      function setPoint(e, t, r, a, o, l, f) {
          var d = r - Math.PI / 2
            , g = r + Math.PI / 2
            , _ = t[0] + Math.cos(r) * a * o
            , v = t[1] - Math.sin(r) * a * o;
          e.setTripleAt(_, v, _ + Math.cos(d) * l, v - Math.sin(d) * l, _ + Math.cos(g) * f, v - Math.sin(g) * f, e.length())
      }
      function getPerpendicularVector(e, t) {
          var r = [t[0] - e[0], t[1] - e[1]]
            , a = -Math.PI * .5
            , o = [Math.cos(a) * r[0] - Math.sin(a) * r[1], Math.sin(a) * r[0] + Math.cos(a) * r[1]];
          return o
      }
      function getProjectingAngle(e, t) {
          var r = t === 0 ? e.length() - 1 : t - 1
            , a = (t + 1) % e.length()
            , o = e.v[r]
            , l = e.v[a]
            , f = getPerpendicularVector(o, l);
          return Math.atan2(0, 1) - Math.atan2(f[1], f[0])
      }
      function zigZagCorner(e, t, r, a, o, l, f) {
          var d = getProjectingAngle(t, r)
            , g = t.v[r % t._length]
            , _ = t.v[r === 0 ? t._length - 1 : r - 1]
            , v = t.v[(r + 1) % t._length]
            , S = l === 2 ? Math.sqrt(Math.pow(g[0] - _[0], 2) + Math.pow(g[1] - _[1], 2)) : 0
            , b = l === 2 ? Math.sqrt(Math.pow(g[0] - v[0], 2) + Math.pow(g[1] - v[1], 2)) : 0;
          setPoint(e, t.v[r % t._length], d, f, a, b / ((o + 1) * 2), S / ((o + 1) * 2))
      }
      function zigZagSegment(e, t, r, a, o, l) {
          for (var f = 0; f < a; f += 1) {
              var d = (f + 1) / (a + 1)
                , g = o === 2 ? Math.sqrt(Math.pow(t.points[3][0] - t.points[0][0], 2) + Math.pow(t.points[3][1] - t.points[0][1], 2)) : 0
                , _ = t.normalAngle(d)
                , v = t.point(d);
              setPoint(e, v, _, l, r, g / ((a + 1) * 2), g / ((a + 1) * 2)),
              l = -l
          }
          return l
      }
      ZigZagModifier.prototype.processPath = function(e, t, r, a) {
          var o = e._length
            , l = shapePool.newElement();
          if (l.c = e.c,
          e.c || (o -= 1),
          o === 0)
              return l;
          var f = -1
            , d = PolynomialBezier.shapeSegment(e, 0);
          zigZagCorner(l, e, 0, t, r, a, f);
          for (var g = 0; g < o; g += 1)
              f = zigZagSegment(l, d, t, r, a, -f),
              g === o - 1 && !e.c ? d = null : d = PolynomialBezier.shapeSegment(e, (g + 1) % o),
              zigZagCorner(l, e, g + 1, t, r, a, f);
          return l
      }
      ,
      ZigZagModifier.prototype.processShapes = function(e) {
          var t, r, a = this.shapes.length, o, l, f = this.amplitude.v, d = Math.max(0, Math.round(this.frequency.v)), g = this.pointsType.v;
          if (f !== 0) {
              var _, v;
              for (r = 0; r < a; r += 1) {
                  if (_ = this.shapes[r],
                  v = _.localShapeCollection,
                  !(!_.shape._mdf && !this._mdf && !e))
                      for (v.releaseShapes(),
                      _.shape._mdf = !0,
                      t = _.shape.paths.shapes,
                      l = _.shape.paths._length,
                      o = 0; o < l; o += 1)
                          v.addShape(this.processPath(t[o], f, d, g));
                  _.shape.paths = _.localShapeCollection
              }
          }
          this.dynamicProperties.length || (this._mdf = !1)
      }
      ;
      function linearOffset(e, t, r) {
          var a = Math.atan2(t[0] - e[0], t[1] - e[1]);
          return [polarOffset(e, a, r), polarOffset(t, a, r)]
      }
      function offsetSegment(e, t) {
          var r, a, o, l, f, d, g;
          g = linearOffset(e.points[0], e.points[1], t),
          r = g[0],
          a = g[1],
          g = linearOffset(e.points[1], e.points[2], t),
          o = g[0],
          l = g[1],
          g = linearOffset(e.points[2], e.points[3], t),
          f = g[0],
          d = g[1];
          var _ = lineIntersection(r, a, o, l);
          _ === null && (_ = a);
          var v = lineIntersection(f, d, o, l);
          return v === null && (v = f),
          new PolynomialBezier(r,_,v,d)
      }
      function joinLines(e, t, r, a, o) {
          var l = t.points[3]
            , f = r.points[0];
          if (a === 3 || pointEqual(l, f))
              return l;
          if (a === 2) {
              var d = -t.tangentAngle(1)
                , g = -r.tangentAngle(0) + Math.PI
                , _ = lineIntersection(l, polarOffset(l, d + Math.PI / 2, 100), f, polarOffset(f, d + Math.PI / 2, 100))
                , v = _ ? pointDistance(_, l) : pointDistance(l, f) / 2
                , S = polarOffset(l, d, 2 * v * roundCorner);
              return e.setXYAt(S[0], S[1], "o", e.length() - 1),
              S = polarOffset(f, g, 2 * v * roundCorner),
              e.setTripleAt(f[0], f[1], f[0], f[1], S[0], S[1], e.length()),
              f
          }
          var b = pointEqual(l, t.points[2]) ? t.points[0] : t.points[2]
            , P = pointEqual(f, r.points[1]) ? r.points[3] : r.points[1]
            , x = lineIntersection(b, l, f, P);
          return x && pointDistance(x, l) < o ? (e.setTripleAt(x[0], x[1], x[0], x[1], x[0], x[1], e.length()),
          x) : l
      }
      function getIntersection(e, t) {
          var r = e.intersections(t);
          return r.length && floatEqual(r[0][0], 1) && r.shift(),
          r.length ? r[0] : null
      }
      function pruneSegmentIntersection(e, t) {
          var r = e.slice()
            , a = t.slice()
            , o = getIntersection(e[e.length - 1], t[0]);
          return o && (r[e.length - 1] = e[e.length - 1].split(o[0])[0],
          a[0] = t[0].split(o[1])[1]),
          e.length > 1 && t.length > 1 && (o = getIntersection(e[0], t[t.length - 1]),
          o) ? [[e[0].split(o[0])[0]], [t[t.length - 1].split(o[1])[1]]] : [r, a]
      }
      function pruneIntersections(e) {
          for (var t, r = 1; r < e.length; r += 1)
              t = pruneSegmentIntersection(e[r - 1], e[r]),
              e[r - 1] = t[0],
              e[r] = t[1];
          return e.length > 1 && (t = pruneSegmentIntersection(e[e.length - 1], e[0]),
          e[e.length - 1] = t[0],
          e[0] = t[1]),
          e
      }
      function offsetSegmentSplit(e, t) {
          var r = e.inflectionPoints(), a, o, l, f;
          if (r.length === 0)
              return [offsetSegment(e, t)];
          if (r.length === 1 || floatEqual(r[1], 1))
              return l = e.split(r[0]),
              a = l[0],
              o = l[1],
              [offsetSegment(a, t), offsetSegment(o, t)];
          l = e.split(r[0]),
          a = l[0];
          var d = (r[1] - r[0]) / (1 - r[0]);
          return l = l[1].split(d),
          f = l[0],
          o = l[1],
          [offsetSegment(a, t), offsetSegment(f, t), offsetSegment(o, t)]
      }
      function OffsetPathModifier() {}
      extendPrototype([ShapeModifier], OffsetPathModifier),
      OffsetPathModifier.prototype.initModifierProperties = function(e, t) {
          this.getValue = this.processKeys,
          this.amount = PropertyFactory.getProp(e, t.a, 0, null, this),
          this.miterLimit = PropertyFactory.getProp(e, t.ml, 0, null, this),
          this.lineJoin = t.lj,
          this._isAnimated = this.amount.effectsSequence.length !== 0
      }
      ,
      OffsetPathModifier.prototype.processPath = function(e, t, r, a) {
          var o = shapePool.newElement();
          o.c = e.c;
          var l = e.length();
          e.c || (l -= 1);
          var f, d, g, _ = [];
          for (f = 0; f < l; f += 1)
              g = PolynomialBezier.shapeSegment(e, f),
              _.push(offsetSegmentSplit(g, t));
          if (!e.c)
              for (f = l - 1; f >= 0; f -= 1)
                  g = PolynomialBezier.shapeSegmentInverted(e, f),
                  _.push(offsetSegmentSplit(g, t));
          _ = pruneIntersections(_);
          var v = null
            , S = null;
          for (f = 0; f < _.length; f += 1) {
              var b = _[f];
              for (S && (v = joinLines(o, S, b[0], r, a)),
              S = b[b.length - 1],
              d = 0; d < b.length; d += 1)
                  g = b[d],
                  v && pointEqual(g.points[0], v) ? o.setXYAt(g.points[1][0], g.points[1][1], "o", o.length() - 1) : o.setTripleAt(g.points[0][0], g.points[0][1], g.points[1][0], g.points[1][1], g.points[0][0], g.points[0][1], o.length()),
                  o.setTripleAt(g.points[3][0], g.points[3][1], g.points[3][0], g.points[3][1], g.points[2][0], g.points[2][1], o.length()),
                  v = g.points[3]
          }
          return _.length && joinLines(o, S, _[0][0], r, a),
          o
      }
      ,
      OffsetPathModifier.prototype.processShapes = function(e) {
          var t, r, a = this.shapes.length, o, l, f = this.amount.v, d = this.miterLimit.v, g = this.lineJoin;
          if (f !== 0) {
              var _, v;
              for (r = 0; r < a; r += 1) {
                  if (_ = this.shapes[r],
                  v = _.localShapeCollection,
                  !(!_.shape._mdf && !this._mdf && !e))
                      for (v.releaseShapes(),
                      _.shape._mdf = !0,
                      t = _.shape.paths.shapes,
                      l = _.shape.paths._length,
                      o = 0; o < l; o += 1)
                          v.addShape(this.processPath(t[o], f, g, d));
                  _.shape.paths = _.localShapeCollection
              }
          }
          this.dynamicProperties.length || (this._mdf = !1)
      }
      ;
      function getFontProperties(e) {
          for (var t = e.fStyle ? e.fStyle.split(" ") : [], r = "normal", a = "normal", o = t.length, l, f = 0; f < o; f += 1)
              switch (l = t[f].toLowerCase(),
              l) {
              case "italic":
                  a = "italic";
                  break;
              case "bold":
                  r = "700";
                  break;
              case "black":
                  r = "900";
                  break;
              case "medium":
                  r = "500";
                  break;
              case "regular":
              case "normal":
                  r = "400";
                  break;
              case "light":
              case "thin":
                  r = "200";
                  break
              }
          return {
              style: a,
              weight: e.fWeight || r
          }
      }
      var FontManager = function() {
          var e = 5e3
            , t = {
              w: 0,
              size: 0,
              shapes: [],
              data: {
                  shapes: []
              }
          }
            , r = [];
          r = r.concat([2304, 2305, 2306, 2307, 2362, 2363, 2364, 2364, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2387, 2388, 2389, 2390, 2391, 2402, 2403]);
          var a = 127988
            , o = 917631
            , l = 917601
            , f = 917626
            , d = 65039
            , g = 8205
            , _ = 127462
            , v = 127487
            , S = ["d83cdffb", "d83cdffc", "d83cdffd", "d83cdffe", "d83cdfff"];
          function b(D) {
              var B = D.split(","), R, L = B.length, V = [];
              for (R = 0; R < L; R += 1)
                  B[R] !== "sans-serif" && B[R] !== "monospace" && V.push(B[R]);
              return V.join(",")
          }
          function P(D, B) {
              var R = createTag("span");
              R.setAttribute("aria-hidden", !0),
              R.style.fontFamily = B;
              var L = createTag("span");
              L.innerText = "giItT1WQy@!-/#",
              R.style.position = "absolute",
              R.style.left = "-10000px",
              R.style.top = "-10000px",
              R.style.fontSize = "300px",
              R.style.fontVariant = "normal",
              R.style.fontStyle = "normal",
              R.style.fontWeight = "normal",
              R.style.letterSpacing = "0",
              R.appendChild(L),
              document.body.appendChild(R);
              var V = L.offsetWidth;
              return L.style.fontFamily = b(D) + ", " + B,
              {
                  node: L,
                  w: V,
                  parent: R
              }
          }
          function x() {
              var D, B = this.fonts.length, R, L, V = B;
              for (D = 0; D < B; D += 1)
                  this.fonts[D].loaded ? V -= 1 : this.fonts[D].fOrigin === "n" || this.fonts[D].origin === 0 ? this.fonts[D].loaded = !0 : (R = this.fonts[D].monoCase.node,
                  L = this.fonts[D].monoCase.w,
                  R.offsetWidth !== L ? (V -= 1,
                  this.fonts[D].loaded = !0) : (R = this.fonts[D].sansCase.node,
                  L = this.fonts[D].sansCase.w,
                  R.offsetWidth !== L && (V -= 1,
                  this.fonts[D].loaded = !0)),
                  this.fonts[D].loaded && (this.fonts[D].sansCase.parent.parentNode.removeChild(this.fonts[D].sansCase.parent),
                  this.fonts[D].monoCase.parent.parentNode.removeChild(this.fonts[D].monoCase.parent)));
              V !== 0 && Date.now() - this.initTime < e ? setTimeout(this.checkLoadedFontsBinded, 20) : setTimeout(this.setIsLoadedBinded, 10)
          }
          function E(D, B) {
              var R = document.body && B ? "svg" : "canvas", L, V = getFontProperties(D);
              if (R === "svg") {
                  var q = createNS("text");
                  q.style.fontSize = "100px",
                  q.setAttribute("font-family", D.fFamily),
                  q.setAttribute("font-style", V.style),
                  q.setAttribute("font-weight", V.weight),
                  q.textContent = "1",
                  D.fClass ? (q.style.fontFamily = "inherit",
                  q.setAttribute("class", D.fClass)) : q.style.fontFamily = D.fFamily,
                  B.appendChild(q),
                  L = q
              } else {
                  var oe = new OffscreenCanvas(500,500).getContext("2d");
                  oe.font = V.style + " " + V.weight + " 100px " + D.fFamily,
                  L = oe
              }
              function ye(pe) {
                  return R === "svg" ? (L.textContent = pe,
                  L.getComputedTextLength()) : L.measureText(pe).width
              }
              return {
                  measureText: ye
              }
          }
          function I(D, B) {
              if (!D) {
                  this.isLoaded = !0;
                  return
              }
              if (this.chars) {
                  this.isLoaded = !0,
                  this.fonts = D.list;
                  return
              }
              if (!document.body) {
                  this.isLoaded = !0,
                  D.list.forEach(function(le) {
                      le.helper = E(le),
                      le.cache = {}
                  }),
                  this.fonts = D.list;
                  return
              }
              var R = D.list, L, V = R.length, q = V;
              for (L = 0; L < V; L += 1) {
                  var oe = !0, ye, pe;
                  if (R[L].loaded = !1,
                  R[L].monoCase = P(R[L].fFamily, "monospace"),
                  R[L].sansCase = P(R[L].fFamily, "sans-serif"),
                  !R[L].fPath)
                      R[L].loaded = !0,
                      q -= 1;
                  else if (R[L].fOrigin === "p" || R[L].origin === 3) {
                      if (ye = document.querySelectorAll('style[f-forigin="p"][f-family="' + R[L].fFamily + '"], style[f-origin="3"][f-family="' + R[L].fFamily + '"]'),
                      ye.length > 0 && (oe = !1),
                      oe) {
                          var Pe = createTag("style");
                          Pe.setAttribute("f-forigin", R[L].fOrigin),
                          Pe.setAttribute("f-origin", R[L].origin),
                          Pe.setAttribute("f-family", R[L].fFamily),
                          Pe.type = "text/css",
                          Pe.innerText = "@font-face {font-family: " + R[L].fFamily + "; font-style: normal; src: url('" + R[L].fPath + "');}",
                          B.appendChild(Pe)
                      }
                  } else if (R[L].fOrigin === "g" || R[L].origin === 1) {
                      for (ye = document.querySelectorAll('link[f-forigin="g"], link[f-origin="1"]'),
                      pe = 0; pe < ye.length; pe += 1)
                          ye[pe].href.indexOf(R[L].fPath) !== -1 && (oe = !1);
                      if (oe) {
                          var me = createTag("link");
                          me.setAttribute("f-forigin", R[L].fOrigin),
                          me.setAttribute("f-origin", R[L].origin),
                          me.type = "text/css",
                          me.rel = "stylesheet",
                          me.href = R[L].fPath,
                          document.body.appendChild(me)
                      }
                  } else if (R[L].fOrigin === "t" || R[L].origin === 2) {
                      for (ye = document.querySelectorAll('script[f-forigin="t"], script[f-origin="2"]'),
                      pe = 0; pe < ye.length; pe += 1)
                          R[L].fPath === ye[pe].src && (oe = !1);
                      if (oe) {
                          var Q = createTag("link");
                          Q.setAttribute("f-forigin", R[L].fOrigin),
                          Q.setAttribute("f-origin", R[L].origin),
                          Q.setAttribute("rel", "stylesheet"),
                          Q.setAttribute("href", R[L].fPath),
                          B.appendChild(Q)
                      }
                  }
                  R[L].helper = E(R[L], B),
                  R[L].cache = {},
                  this.fonts.push(R[L])
              }
              q === 0 ? this.isLoaded = !0 : setTimeout(this.checkLoadedFonts.bind(this), 100)
          }
          function C(D) {
              if (D) {
                  this.chars || (this.chars = []);
                  var B, R = D.length, L, V = this.chars.length, q;
                  for (B = 0; B < R; B += 1) {
                      for (L = 0,
                      q = !1; L < V; )
                          this.chars[L].style === D[B].style && this.chars[L].fFamily === D[B].fFamily && this.chars[L].ch === D[B].ch && (q = !0),
                          L += 1;
                      q || (this.chars.push(D[B]),
                      V += 1)
                  }
              }
          }
          function A(D, B, R) {
              for (var L = 0, V = this.chars.length; L < V; ) {
                  if (this.chars[L].ch === D && this.chars[L].style === B && this.chars[L].fFamily === R)
                      return this.chars[L];
                  L += 1
              }
              return (typeof D == "string" && D.charCodeAt(0) !== 13 || !D) && console && console.warn && !this._warned && (this._warned = !0,
              console.warn("Missing character from exported characters list: ", D, B, R)),
              t
          }
          function T(D, B, R) {
              var L = this.getFontByName(B)
                , V = D;
              if (!L.cache[V]) {
                  var q = L.helper;
                  if (D === " ") {
                      var oe = q.measureText("|" + D + "|")
                        , ye = q.measureText("||");
                      L.cache[V] = (oe - ye) / 100
                  } else
                      L.cache[V] = q.measureText(D) / 100
              }
              return L.cache[V] * R
          }
          function w(D) {
              for (var B = 0, R = this.fonts.length; B < R; ) {
                  if (this.fonts[B].fName === D)
                      return this.fonts[B];
                  B += 1
              }
              return this.fonts[0]
          }
          function M(D) {
              var B = 0
                , R = D.charCodeAt(0);
              if (R >= 55296 && R <= 56319) {
                  var L = D.charCodeAt(1);
                  L >= 56320 && L <= 57343 && (B = (R - 55296) * 1024 + L - 56320 + 65536)
              }
              return B
          }
          function F(D, B) {
              var R = D.toString(16) + B.toString(16);
              return S.indexOf(R) !== -1
          }
          function O(D) {
              return D === g
          }
          function $(D) {
              return D === d
          }
          function j(D) {
              var B = M(D);
              return B >= _ && B <= v
          }
          function K(D) {
              return j(D.substr(0, 2)) && j(D.substr(2, 2))
          }
          function Y(D) {
              return r.indexOf(D) !== -1
          }
          function W(D, B) {
              var R = M(D.substr(B, 2));
              if (R !== a)
                  return !1;
              var L = 0;
              for (B += 2; L < 5; ) {
                  if (R = M(D.substr(B, 2)),
                  R < l || R > f)
                      return !1;
                  L += 1,
                  B += 2
              }
              return M(D.substr(B, 2)) === o
          }
          function Z() {
              this.isLoaded = !0
          }
          var ee = function() {
              this.fonts = [],
              this.chars = null,
              this.typekitLoaded = 0,
              this.isLoaded = !1,
              this._warned = !1,
              this.initTime = Date.now(),
              this.setIsLoadedBinded = this.setIsLoaded.bind(this),
              this.checkLoadedFontsBinded = this.checkLoadedFonts.bind(this)
          };
          ee.isModifier = F,
          ee.isZeroWidthJoiner = O,
          ee.isFlagEmoji = K,
          ee.isRegionalCode = j,
          ee.isCombinedCharacter = Y,
          ee.isRegionalFlag = W,
          ee.isVariationSelector = $,
          ee.BLACK_FLAG_CODE_POINT = a;
          var X = {
              addChars: C,
              addFonts: I,
              getCharData: A,
              getFontByName: w,
              measureText: T,
              checkLoadedFonts: x,
              setIsLoaded: Z
          };
          return ee.prototype = X,
          ee
      }();
      function SlotManager(e) {
          this.animationData = e
      }
      SlotManager.prototype.getProp = function(e) {
          return this.animationData.slots && this.animationData.slots[e.sid] ? Object.assign(e, this.animationData.slots[e.sid].p) : e
      }
      ;
      function slotFactory(e) {
          return new SlotManager(e)
      }
      function RenderableElement() {}
      RenderableElement.prototype = {
          initRenderable: function() {
              this.isInRange = !1,
              this.hidden = !1,
              this.isTransparent = !1,
              this.renderableComponents = []
          },
          addRenderableComponent: function(t) {
              this.renderableComponents.indexOf(t) === -1 && this.renderableComponents.push(t)
          },
          removeRenderableComponent: function(t) {
              this.renderableComponents.indexOf(t) !== -1 && this.renderableComponents.splice(this.renderableComponents.indexOf(t), 1)
          },
          prepareRenderableFrame: function(t) {
              this.checkLayerLimits(t)
          },
          checkTransparency: function() {
              this.finalTransform.mProp.o.v <= 0 ? !this.isTransparent && this.globalData.renderConfig.hideOnTransparent && (this.isTransparent = !0,
              this.hide()) : this.isTransparent && (this.isTransparent = !1,
              this.show())
          },
          checkLayerLimits: function(t) {
              this.data.ip - this.data.st <= t && this.data.op - this.data.st > t ? this.isInRange !== !0 && (this.globalData._mdf = !0,
              this._mdf = !0,
              this.isInRange = !0,
              this.show()) : this.isInRange !== !1 && (this.globalData._mdf = !0,
              this.isInRange = !1,
              this.hide())
          },
          renderRenderable: function() {
              var t, r = this.renderableComponents.length;
              for (t = 0; t < r; t += 1)
                  this.renderableComponents[t].renderFrame(this._isFirstFrame)
          },
          sourceRectAtTime: function() {
              return {
                  top: 0,
                  left: 0,
                  width: 100,
                  height: 100
              }
          },
          getLayerSize: function() {
              return this.data.ty === 5 ? {
                  w: this.data.textData.width,
                  h: this.data.textData.height
              } : {
                  w: this.data.width,
                  h: this.data.height
              }
          }
      };
      var getBlendMode = function() {
          var e = {
              0: "source-over",
              1: "multiply",
              2: "screen",
              3: "overlay",
              4: "darken",
              5: "lighten",
              6: "color-dodge",
              7: "color-burn",
              8: "hard-light",
              9: "soft-light",
              10: "difference",
              11: "exclusion",
              12: "hue",
              13: "saturation",
              14: "color",
              15: "luminosity"
          };
          return function(t) {
              return e[t] || ""
          }
      }();
      function SliderEffect(e, t, r) {
          this.p = PropertyFactory.getProp(t, e.v, 0, 0, r)
      }
      function AngleEffect(e, t, r) {
          this.p = PropertyFactory.getProp(t, e.v, 0, 0, r)
      }
      function ColorEffect(e, t, r) {
          this.p = PropertyFactory.getProp(t, e.v, 1, 0, r)
      }
      function PointEffect(e, t, r) {
          this.p = PropertyFactory.getProp(t, e.v, 1, 0, r)
      }
      function LayerIndexEffect(e, t, r) {
          this.p = PropertyFactory.getProp(t, e.v, 0, 0, r)
      }
      function MaskIndexEffect(e, t, r) {
          this.p = PropertyFactory.getProp(t, e.v, 0, 0, r)
      }
      function CheckboxEffect(e, t, r) {
          this.p = PropertyFactory.getProp(t, e.v, 0, 0, r)
      }
      function NoValueEffect() {
          this.p = {}
      }
      function EffectsManager(e, t) {
          var r = e.ef || [];
          this.effectElements = [];
          var a, o = r.length, l;
          for (a = 0; a < o; a += 1)
              l = new GroupEffect(r[a],t),
              this.effectElements.push(l)
      }
      function GroupEffect(e, t) {
          this.init(e, t)
      }
      extendPrototype([DynamicPropertyContainer], GroupEffect),
      GroupEffect.prototype.getValue = GroupEffect.prototype.iterateDynamicProperties,
      GroupEffect.prototype.init = function(e, t) {
          this.data = e,
          this.effectElements = [],
          this.initDynamicPropertyContainer(t);
          var r, a = this.data.ef.length, o, l = this.data.ef;
          for (r = 0; r < a; r += 1) {
              switch (o = null,
              l[r].ty) {
              case 0:
                  o = new SliderEffect(l[r],t,this);
                  break;
              case 1:
                  o = new AngleEffect(l[r],t,this);
                  break;
              case 2:
                  o = new ColorEffect(l[r],t,this);
                  break;
              case 3:
                  o = new PointEffect(l[r],t,this);
                  break;
              case 4:
              case 7:
                  o = new CheckboxEffect(l[r],t,this);
                  break;
              case 10:
                  o = new LayerIndexEffect(l[r],t,this);
                  break;
              case 11:
                  o = new MaskIndexEffect(l[r],t,this);
                  break;
              case 5:
                  o = new EffectsManager(l[r],t);
                  break;
              default:
                  o = new NoValueEffect(l[r]);
                  break
              }
              o && this.effectElements.push(o)
          }
      }
      ;
      function BaseElement() {}
      BaseElement.prototype = {
          checkMasks: function() {
              if (!this.data.hasMask)
                  return !1;
              for (var t = 0, r = this.data.masksProperties.length; t < r; ) {
                  if (this.data.masksProperties[t].mode !== "n" && this.data.masksProperties[t].cl !== !1)
                      return !0;
                  t += 1
              }
              return !1
          },
          initExpressions: function() {
              var t = getExpressionInterfaces();
              if (t) {
                  var r = t("layer")
                    , a = t("effects")
                    , o = t("shape")
                    , l = t("text")
                    , f = t("comp");
                  this.layerInterface = r(this),
                  this.data.hasMask && this.maskManager && this.layerInterface.registerMaskInterface(this.maskManager);
                  var d = a.createEffectsInterface(this, this.layerInterface);
                  this.layerInterface.registerEffectsInterface(d),
                  this.data.ty === 0 || this.data.xt ? this.compInterface = f(this) : this.data.ty === 4 ? (this.layerInterface.shapeInterface = o(this.shapesData, this.itemsData, this.layerInterface),
                  this.layerInterface.content = this.layerInterface.shapeInterface) : this.data.ty === 5 && (this.layerInterface.textInterface = l(this),
                  this.layerInterface.text = this.layerInterface.textInterface)
              }
          },
          setBlendMode: function() {
              var t = getBlendMode(this.data.bm)
                , r = this.baseElement || this.layerElement;
              r.style["mix-blend-mode"] = t
          },
          initBaseData: function(t, r, a) {
              this.globalData = r,
              this.comp = a,
              this.data = t,
              this.layerId = createElementID(),
              this.data.sr || (this.data.sr = 1),
              this.effectsManager = new EffectsManager(this.data,this,this.dynamicProperties)
          },
          getType: function() {
              return this.type
          },
          sourceRectAtTime: function() {}
      };
      function FrameElement() {}
      FrameElement.prototype = {
          initFrame: function() {
              this._isFirstFrame = !1,
              this.dynamicProperties = [],
              this._mdf = !1
          },
          prepareProperties: function(t, r) {
              var a, o = this.dynamicProperties.length;
              for (a = 0; a < o; a += 1)
                  (r || this._isParent && this.dynamicProperties[a].propType === "transform") && (this.dynamicProperties[a].getValue(),
                  this.dynamicProperties[a]._mdf && (this.globalData._mdf = !0,
                  this._mdf = !0))
          },
          addDynamicProperty: function(t) {
              this.dynamicProperties.indexOf(t) === -1 && this.dynamicProperties.push(t)
          }
      };
      function FootageElement(e, t, r) {
          this.initFrame(),
          this.initRenderable(),
          this.assetData = t.getAssetData(e.refId),
          this.footageData = t.imageLoader.getAsset(this.assetData),
          this.initBaseData(e, t, r)
      }
      FootageElement.prototype.prepareFrame = function() {}
      ,
      extendPrototype([RenderableElement, BaseElement, FrameElement], FootageElement),
      FootageElement.prototype.getBaseElement = function() {
          return null
      }
      ,
      FootageElement.prototype.renderFrame = function() {}
      ,
      FootageElement.prototype.destroy = function() {}
      ,
      FootageElement.prototype.initExpressions = function() {
          var e = getExpressionInterfaces();
          if (e) {
              var t = e("footage");
              this.layerInterface = t(this)
          }
      }
      ,
      FootageElement.prototype.getFootageData = function() {
          return this.footageData
      }
      ;
      function AudioElement(e, t, r) {
          this.initFrame(),
          this.initRenderable(),
          this.assetData = t.getAssetData(e.refId),
          this.initBaseData(e, t, r),
          this._isPlaying = !1,
          this._canPlay = !1;
          var a = this.globalData.getAssetsPath(this.assetData);
          this.audio = this.globalData.audioController.createAudio(a),
          this._currentTime = 0,
          this.globalData.audioController.addAudio(this),
          this._volumeMultiplier = 1,
          this._volume = 1,
          this._previousVolume = null,
          this.tm = e.tm ? PropertyFactory.getProp(this, e.tm, 0, t.frameRate, this) : {
              _placeholder: !0
          },
          this.lv = PropertyFactory.getProp(this, e.au && e.au.lv ? e.au.lv : {
              k: [100]
          }, 1, .01, this)
      }
      AudioElement.prototype.prepareFrame = function(e) {
          if (this.prepareRenderableFrame(e, !0),
          this.prepareProperties(e, !0),
          this.tm._placeholder)
              this._currentTime = e / this.data.sr;
          else {
              var t = this.tm.v;
              this._currentTime = t
          }
          this._volume = this.lv.v[0];
          var r = this._volume * this._volumeMultiplier;
          this._previousVolume !== r && (this._previousVolume = r,
          this.audio.volume(r))
      }
      ,
      extendPrototype([RenderableElement, BaseElement, FrameElement], AudioElement),
      AudioElement.prototype.renderFrame = function() {
          this.isInRange && this._canPlay && (this._isPlaying ? (!this.audio.playing() || Math.abs(this._currentTime / this.globalData.frameRate - this.audio.seek()) > .1) && this.audio.seek(this._currentTime / this.globalData.frameRate) : (this.audio.play(),
          this.audio.seek(this._currentTime / this.globalData.frameRate),
          this._isPlaying = !0))
      }
      ,
      AudioElement.prototype.show = function() {}
      ,
      AudioElement.prototype.hide = function() {
          this.audio.pause(),
          this._isPlaying = !1
      }
      ,
      AudioElement.prototype.pause = function() {
          this.audio.pause(),
          this._isPlaying = !1,
          this._canPlay = !1
      }
      ,
      AudioElement.prototype.resume = function() {
          this._canPlay = !0
      }
      ,
      AudioElement.prototype.setRate = function(e) {
          this.audio.rate(e)
      }
      ,
      AudioElement.prototype.volume = function(e) {
          this._volumeMultiplier = e,
          this._previousVolume = e * this._volume,
          this.audio.volume(this._previousVolume)
      }
      ,
      AudioElement.prototype.getBaseElement = function() {
          return null
      }
      ,
      AudioElement.prototype.destroy = function() {}
      ,
      AudioElement.prototype.sourceRectAtTime = function() {}
      ,
      AudioElement.prototype.initExpressions = function() {}
      ;
      function BaseRenderer() {}
      BaseRenderer.prototype.checkLayers = function(e) {
          var t, r = this.layers.length, a;
          for (this.completeLayers = !0,
          t = r - 1; t >= 0; t -= 1)
              this.elements[t] || (a = this.layers[t],
              a.ip - a.st <= e - this.layers[t].st && a.op - a.st > e - this.layers[t].st && this.buildItem(t)),
              this.completeLayers = this.elements[t] ? this.completeLayers : !1;
          this.checkPendingElements()
      }
      ,
      BaseRenderer.prototype.createItem = function(e) {
          switch (e.ty) {
          case 2:
              return this.createImage(e);
          case 0:
              return this.createComp(e);
          case 1:
              return this.createSolid(e);
          case 3:
              return this.createNull(e);
          case 4:
              return this.createShape(e);
          case 5:
              return this.createText(e);
          case 6:
              return this.createAudio(e);
          case 13:
              return this.createCamera(e);
          case 15:
              return this.createFootage(e);
          default:
              return this.createNull(e)
          }
      }
      ,
      BaseRenderer.prototype.createCamera = function() {
          throw new Error("You're using a 3d camera. Try the html renderer.")
      }
      ,
      BaseRenderer.prototype.createAudio = function(e) {
          return new AudioElement(e,this.globalData,this)
      }
      ,
      BaseRenderer.prototype.createFootage = function(e) {
          return new FootageElement(e,this.globalData,this)
      }
      ,
      BaseRenderer.prototype.buildAllItems = function() {
          var e, t = this.layers.length;
          for (e = 0; e < t; e += 1)
              this.buildItem(e);
          this.checkPendingElements()
      }
      ,
      BaseRenderer.prototype.includeLayers = function(e) {
          this.completeLayers = !1;
          var t, r = e.length, a, o = this.layers.length;
          for (t = 0; t < r; t += 1)
              for (a = 0; a < o; ) {
                  if (this.layers[a].id === e[t].id) {
                      this.layers[a] = e[t];
                      break
                  }
                  a += 1
              }
      }
      ,
      BaseRenderer.prototype.setProjectInterface = function(e) {
          this.globalData.projectInterface = e
      }
      ,
      BaseRenderer.prototype.initItems = function() {
          this.globalData.progressiveLoad || this.buildAllItems()
      }
      ,
      BaseRenderer.prototype.buildElementParenting = function(e, t, r) {
          for (var a = this.elements, o = this.layers, l = 0, f = o.length; l < f; )
              o[l].ind == t && (!a[l] || a[l] === !0 ? (this.buildItem(l),
              this.addPendingElement(e)) : (r.push(a[l]),
              a[l].setAsParent(),
              o[l].parent !== void 0 ? this.buildElementParenting(e, o[l].parent, r) : e.setHierarchy(r))),
              l += 1
      }
      ,
      BaseRenderer.prototype.addPendingElement = function(e) {
          this.pendingElements.push(e)
      }
      ,
      BaseRenderer.prototype.searchExtraCompositions = function(e) {
          var t, r = e.length;
          for (t = 0; t < r; t += 1)
              if (e[t].xt) {
                  var a = this.createComp(e[t]);
                  a.initExpressions(),
                  this.globalData.projectInterface.registerComposition(a)
              }
      }
      ,
      BaseRenderer.prototype.getElementById = function(e) {
          var t, r = this.elements.length;
          for (t = 0; t < r; t += 1)
              if (this.elements[t].data.ind === e)
                  return this.elements[t];
          return null
      }
      ,
      BaseRenderer.prototype.getElementByPath = function(e) {
          var t = e.shift(), r;
          if (typeof t == "number")
              r = this.elements[t];
          else {
              var a, o = this.elements.length;
              for (a = 0; a < o; a += 1)
                  if (this.elements[a].data.nm === t) {
                      r = this.elements[a];
                      break
                  }
          }
          return e.length === 0 ? r : r.getElementByPath(e)
      }
      ,
      BaseRenderer.prototype.setupGlobalData = function(e, t) {
          this.globalData.fontManager = new FontManager,
          this.globalData.slotManager = slotFactory(e),
          this.globalData.fontManager.addChars(e.chars),
          this.globalData.fontManager.addFonts(e.fonts, t),
          this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem),
          this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem),
          this.globalData.imageLoader = this.animationItem.imagePreloader,
          this.globalData.audioController = this.animationItem.audioController,
          this.globalData.frameId = 0,
          this.globalData.frameRate = e.fr,
          this.globalData.nm = e.nm,
          this.globalData.compSize = {
              w: e.w,
              h: e.h
          }
      }
      ;
      var effectTypes = {
          TRANSFORM_EFFECT: "transformEFfect"
      };
      function TransformElement() {}
      TransformElement.prototype = {
          initTransform: function() {
              var t = new Matrix;
              this.finalTransform = {
                  mProp: this.data.ks ? TransformPropertyFactory.getTransformProperty(this, this.data.ks, this) : {
                      o: 0
                  },
                  _matMdf: !1,
                  _localMatMdf: !1,
                  _opMdf: !1,
                  mat: t,
                  localMat: t,
                  localOpacity: 1
              },
              this.data.ao && (this.finalTransform.mProp.autoOriented = !0),
              this.data.ty
          },
          renderTransform: function() {
              if (this.finalTransform._opMdf = this.finalTransform.mProp.o._mdf || this._isFirstFrame,
              this.finalTransform._matMdf = this.finalTransform.mProp._mdf || this._isFirstFrame,
              this.hierarchy) {
                  var t, r = this.finalTransform.mat, a = 0, o = this.hierarchy.length;
                  if (!this.finalTransform._matMdf)
                      for (; a < o; ) {
                          if (this.hierarchy[a].finalTransform.mProp._mdf) {
                              this.finalTransform._matMdf = !0;
                              break
                          }
                          a += 1
                      }
                  if (this.finalTransform._matMdf)
                      for (t = this.finalTransform.mProp.v.props,
                      r.cloneFromProps(t),
                      a = 0; a < o; a += 1)
                          r.multiply(this.hierarchy[a].finalTransform.mProp.v)
              }
              this.finalTransform._matMdf && (this.finalTransform._localMatMdf = this.finalTransform._matMdf),
              this.finalTransform._opMdf && (this.finalTransform.localOpacity = this.finalTransform.mProp.o.v)
          },
          renderLocalTransform: function() {
              if (this.localTransforms) {
                  var t = 0
                    , r = this.localTransforms.length;
                  if (this.finalTransform._localMatMdf = this.finalTransform._matMdf,
                  !this.finalTransform._localMatMdf || !this.finalTransform._opMdf)
                      for (; t < r; )
                          this.localTransforms[t]._mdf && (this.finalTransform._localMatMdf = !0),
                          this.localTransforms[t]._opMdf && !this.finalTransform._opMdf && (this.finalTransform.localOpacity = this.finalTransform.mProp.o.v,
                          this.finalTransform._opMdf = !0),
                          t += 1;
                  if (this.finalTransform._localMatMdf) {
                      var a = this.finalTransform.localMat;
                      for (this.localTransforms[0].matrix.clone(a),
                      t = 1; t < r; t += 1) {
                          var o = this.localTransforms[t].matrix;
                          a.multiply(o)
                      }
                      a.multiply(this.finalTransform.mat)
                  }
                  if (this.finalTransform._opMdf) {
                      var l = this.finalTransform.localOpacity;
                      for (t = 0; t < r; t += 1)
                          l *= this.localTransforms[t].opacity * .01;
                      this.finalTransform.localOpacity = l
                  }
              }
          },
          searchEffectTransforms: function() {
              if (this.renderableEffectsManager) {
                  var t = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT);
                  if (t.length) {
                      this.localTransforms = [],
                      this.finalTransform.localMat = new Matrix;
                      var r = 0
                        , a = t.length;
                      for (r = 0; r < a; r += 1)
                          this.localTransforms.push(t[r])
                  }
              }
          },
          globalToLocal: function(t) {
              var r = [];
              r.push(this.finalTransform);
              for (var a = !0, o = this.comp; a; )
                  o.finalTransform ? (o.data.hasMask && r.splice(0, 0, o.finalTransform),
                  o = o.comp) : a = !1;
              var l, f = r.length, d;
              for (l = 0; l < f; l += 1)
                  d = r[l].mat.applyToPointArray(0, 0, 0),
                  t = [t[0] - d[0], t[1] - d[1], 0];
              return t
          },
          mHelper: new Matrix
      };
      function MaskElement(e, t, r) {
          this.data = e,
          this.element = t,
          this.globalData = r,
          this.storedData = [],
          this.masksProperties = this.data.masksProperties || [],
          this.maskElement = null;
          var a = this.globalData.defs, o, l = this.masksProperties ? this.masksProperties.length : 0;
          this.viewData = createSizedArray(l),
          this.solidPath = "";
          var f, d = this.masksProperties, g = 0, _ = [], v, S, b = createElementID(), P, x, E, I, C = "clipPath", A = "clip-path";
          for (o = 0; o < l; o += 1)
              if ((d[o].mode !== "a" && d[o].mode !== "n" || d[o].inv || d[o].o.k !== 100 || d[o].o.x) && (C = "mask",
              A = "mask"),
              (d[o].mode === "s" || d[o].mode === "i") && g === 0 ? (P = createNS("rect"),
              P.setAttribute("fill", "#ffffff"),
              P.setAttribute("width", this.element.comp.data.w || 0),
              P.setAttribute("height", this.element.comp.data.h || 0),
              _.push(P)) : P = null,
              f = createNS("path"),
              d[o].mode === "n")
                  this.viewData[o] = {
                      op: PropertyFactory.getProp(this.element, d[o].o, 0, .01, this.element),
                      prop: ShapePropertyFactory.getShapeProp(this.element, d[o], 3),
                      elem: f,
                      lastPath: ""
                  },
                  a.appendChild(f);
              else {
                  g += 1,
                  f.setAttribute("fill", d[o].mode === "s" ? "#000000" : "#ffffff"),
                  f.setAttribute("clip-rule", "nonzero");
                  var T;
                  if (d[o].x.k !== 0 ? (C = "mask",
                  A = "mask",
                  I = PropertyFactory.getProp(this.element, d[o].x, 0, null, this.element),
                  T = createElementID(),
                  x = createNS("filter"),
                  x.setAttribute("id", T),
                  E = createNS("feMorphology"),
                  E.setAttribute("operator", "erode"),
                  E.setAttribute("in", "SourceGraphic"),
                  E.setAttribute("radius", "0"),
                  x.appendChild(E),
                  a.appendChild(x),
                  f.setAttribute("stroke", d[o].mode === "s" ? "#000000" : "#ffffff")) : (E = null,
                  I = null),
                  this.storedData[o] = {
                      elem: f,
                      x: I,
                      expan: E,
                      lastPath: "",
                      lastOperator: "",
                      filterId: T,
                      lastRadius: 0
                  },
                  d[o].mode === "i") {
                      S = _.length;
                      var w = createNS("g");
                      for (v = 0; v < S; v += 1)
                          w.appendChild(_[v]);
                      var M = createNS("mask");
                      M.setAttribute("mask-type", "alpha"),
                      M.setAttribute("id", b + "_" + g),
                      M.appendChild(f),
                      a.appendChild(M),
                      w.setAttribute("mask", "url(" + getLocationHref() + "#" + b + "_" + g + ")"),
                      _.length = 0,
                      _.push(w)
                  } else
                      _.push(f);
                  d[o].inv && !this.solidPath && (this.solidPath = this.createLayerSolidPath()),
                  this.viewData[o] = {
                      elem: f,
                      lastPath: "",
                      op: PropertyFactory.getProp(this.element, d[o].o, 0, .01, this.element),
                      prop: ShapePropertyFactory.getShapeProp(this.element, d[o], 3),
                      invRect: P
                  },
                  this.viewData[o].prop.k || this.drawPath(d[o], this.viewData[o].prop.v, this.viewData[o])
              }
          for (this.maskElement = createNS(C),
          l = _.length,
          o = 0; o < l; o += 1)
              this.maskElement.appendChild(_[o]);
          g > 0 && (this.maskElement.setAttribute("id", b),
          this.element.maskedElement.setAttribute(A, "url(" + getLocationHref() + "#" + b + ")"),
          a.appendChild(this.maskElement)),
          this.viewData.length && this.element.addRenderableComponent(this)
      }
      MaskElement.prototype.getMaskProperty = function(e) {
          return this.viewData[e].prop
      }
      ,
      MaskElement.prototype.renderFrame = function(e) {
          var t = this.element.finalTransform.mat, r, a = this.masksProperties.length;
          for (r = 0; r < a; r += 1)
              if ((this.viewData[r].prop._mdf || e) && this.drawPath(this.masksProperties[r], this.viewData[r].prop.v, this.viewData[r]),
              (this.viewData[r].op._mdf || e) && this.viewData[r].elem.setAttribute("fill-opacity", this.viewData[r].op.v),
              this.masksProperties[r].mode !== "n" && (this.viewData[r].invRect && (this.element.finalTransform.mProp._mdf || e) && this.viewData[r].invRect.setAttribute("transform", t.getInverseMatrix().to2dCSS()),
              this.storedData[r].x && (this.storedData[r].x._mdf || e))) {
                  var o = this.storedData[r].expan;
                  this.storedData[r].x.v < 0 ? (this.storedData[r].lastOperator !== "erode" && (this.storedData[r].lastOperator = "erode",
                  this.storedData[r].elem.setAttribute("filter", "url(" + getLocationHref() + "#" + this.storedData[r].filterId + ")")),
                  o.setAttribute("radius", -this.storedData[r].x.v)) : (this.storedData[r].lastOperator !== "dilate" && (this.storedData[r].lastOperator = "dilate",
                  this.storedData[r].elem.setAttribute("filter", null)),
                  this.storedData[r].elem.setAttribute("stroke-width", this.storedData[r].x.v * 2))
              }
      }
      ,
      MaskElement.prototype.getMaskelement = function() {
          return this.maskElement
      }
      ,
      MaskElement.prototype.createLayerSolidPath = function() {
          var e = "M0,0 ";
          return e += " h" + this.globalData.compSize.w,
          e += " v" + this.globalData.compSize.h,
          e += " h-" + this.globalData.compSize.w,
          e += " v-" + this.globalData.compSize.h + " ",
          e
      }
      ,
      MaskElement.prototype.drawPath = function(e, t, r) {
          var a = " M" + t.v[0][0] + "," + t.v[0][1], o, l;
          for (l = t._length,
          o = 1; o < l; o += 1)
              a += " C" + t.o[o - 1][0] + "," + t.o[o - 1][1] + " " + t.i[o][0] + "," + t.i[o][1] + " " + t.v[o][0] + "," + t.v[o][1];
          if (t.c && l > 1 && (a += " C" + t.o[o - 1][0] + "," + t.o[o - 1][1] + " " + t.i[0][0] + "," + t.i[0][1] + " " + t.v[0][0] + "," + t.v[0][1]),
          r.lastPath !== a) {
              var f = "";
              r.elem && (t.c && (f = e.inv ? this.solidPath + a : a),
              r.elem.setAttribute("d", f)),
              r.lastPath = a
          }
      }
      ,
      MaskElement.prototype.destroy = function() {
          this.element = null,
          this.globalData = null,
          this.maskElement = null,
          this.data = null,
          this.masksProperties = null
      }
      ;
      var filtersFactory = function() {
          var e = {};
          e.createFilter = t,
          e.createAlphaToLuminanceFilter = r;
          function t(a, o) {
              var l = createNS("filter");
              return l.setAttribute("id", a),
              o !== !0 && (l.setAttribute("filterUnits", "objectBoundingBox"),
              l.setAttribute("x", "0%"),
              l.setAttribute("y", "0%"),
              l.setAttribute("width", "100%"),
              l.setAttribute("height", "100%")),
              l
          }
          function r() {
              var a = createNS("feColorMatrix");
              return a.setAttribute("type", "matrix"),
              a.setAttribute("color-interpolation-filters", "sRGB"),
              a.setAttribute("values", "0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1"),
              a
          }
          return e
      }()
        , featureSupport = function() {
          var e = {
              maskType: !0,
              svgLumaHidden: !0,
              offscreenCanvas: typeof OffscreenCanvas < "u"
          };
          return (/MSIE 10/i.test(navigator.userAgent) || /MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge\/\d./i.test(navigator.userAgent)) && (e.maskType = !1),
          /firefox/i.test(navigator.userAgent) && (e.svgLumaHidden = !1),
          e
      }()
        , registeredEffects$1 = {}
        , idPrefix = "filter_result_";
      function SVGEffects(e) {
          var t, r = "SourceGraphic", a = e.data.ef ? e.data.ef.length : 0, o = createElementID(), l = filtersFactory.createFilter(o, !0), f = 0;
          this.filters = [];
          var d;
          for (t = 0; t < a; t += 1) {
              d = null;
              var g = e.data.ef[t].ty;
              if (registeredEffects$1[g]) {
                  var _ = registeredEffects$1[g].effect;
                  d = new _(l,e.effectsManager.effectElements[t],e,idPrefix + f,r),
                  r = idPrefix + f,
                  registeredEffects$1[g].countsAsEffect && (f += 1)
              }
              d && this.filters.push(d)
          }
          f && (e.globalData.defs.appendChild(l),
          e.layerElement.setAttribute("filter", "url(" + getLocationHref() + "#" + o + ")")),
          this.filters.length && e.addRenderableComponent(this)
      }
      SVGEffects.prototype.renderFrame = function(e) {
          var t, r = this.filters.length;
          for (t = 0; t < r; t += 1)
              this.filters[t].renderFrame(e)
      }
      ,
      SVGEffects.prototype.getEffects = function(e) {
          var t, r = this.filters.length, a = [];
          for (t = 0; t < r; t += 1)
              this.filters[t].type === e && a.push(this.filters[t]);
          return a
      }
      ;
      function registerEffect$1(e, t, r) {
          registeredEffects$1[e] = {
              effect: t,
              countsAsEffect: r
          }
      }
      function SVGBaseElement() {}
      SVGBaseElement.prototype = {
          initRendererElement: function() {
              this.layerElement = createNS("g")
          },
          createContainerElements: function() {
              this.matteElement = createNS("g"),
              this.transformedElement = this.layerElement,
              this.maskedElement = this.layerElement,
              this._sizeChanged = !1;
              var t = null;
              if (this.data.td) {
                  this.matteMasks = {};
                  var r = createNS("g");
                  r.setAttribute("id", this.layerId),
                  r.appendChild(this.layerElement),
                  t = r,
                  this.globalData.defs.appendChild(r)
              } else
                  this.data.tt ? (this.matteElement.appendChild(this.layerElement),
                  t = this.matteElement,
                  this.baseElement = this.matteElement) : this.baseElement = this.layerElement;
              if (this.data.ln && this.layerElement.setAttribute("id", this.data.ln),
              this.data.cl && this.layerElement.setAttribute("class", this.data.cl),
              this.data.ty === 0 && !this.data.hd) {
                  var a = createNS("clipPath")
                    , o = createNS("path");
                  o.setAttribute("d", "M0,0 L" + this.data.w + ",0 L" + this.data.w + "," + this.data.h + " L0," + this.data.h + "z");
                  var l = createElementID();
                  if (a.setAttribute("id", l),
                  a.appendChild(o),
                  this.globalData.defs.appendChild(a),
                  this.checkMasks()) {
                      var f = createNS("g");
                      f.setAttribute("clip-path", "url(" + getLocationHref() + "#" + l + ")"),
                      f.appendChild(this.layerElement),
                      this.transformedElement = f,
                      t ? t.appendChild(this.transformedElement) : this.baseElement = this.transformedElement
                  } else
                      this.layerElement.setAttribute("clip-path", "url(" + getLocationHref() + "#" + l + ")")
              }
              this.data.bm !== 0 && this.setBlendMode()
          },
          renderElement: function() {
              this.finalTransform._localMatMdf && this.transformedElement.setAttribute("transform", this.finalTransform.localMat.to2dCSS()),
              this.finalTransform._opMdf && this.transformedElement.setAttribute("opacity", this.finalTransform.localOpacity)
          },
          destroyBaseElement: function() {
              this.layerElement = null,
              this.matteElement = null,
              this.maskManager.destroy()
          },
          getBaseElement: function() {
              return this.data.hd ? null : this.baseElement
          },
          createRenderableComponents: function() {
              this.maskManager = new MaskElement(this.data,this,this.globalData),
              this.renderableEffectsManager = new SVGEffects(this),
              this.searchEffectTransforms()
          },
          getMatte: function(t) {
              if (this.matteMasks || (this.matteMasks = {}),
              !this.matteMasks[t]) {
                  var r = this.layerId + "_" + t, a, o, l, f;
                  if (t === 1 || t === 3) {
                      var d = createNS("mask");
                      d.setAttribute("id", r),
                      d.setAttribute("mask-type", t === 3 ? "luminance" : "alpha"),
                      l = createNS("use"),
                      l.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#" + this.layerId),
                      d.appendChild(l),
                      this.globalData.defs.appendChild(d),
                      !featureSupport.maskType && t === 1 && (d.setAttribute("mask-type", "luminance"),
                      a = createElementID(),
                      o = filtersFactory.createFilter(a),
                      this.globalData.defs.appendChild(o),
                      o.appendChild(filtersFactory.createAlphaToLuminanceFilter()),
                      f = createNS("g"),
                      f.appendChild(l),
                      d.appendChild(f),
                      f.setAttribute("filter", "url(" + getLocationHref() + "#" + a + ")"))
                  } else if (t === 2) {
                      var g = createNS("mask");
                      g.setAttribute("id", r),
                      g.setAttribute("mask-type", "alpha");
                      var _ = createNS("g");
                      g.appendChild(_),
                      a = createElementID(),
                      o = filtersFactory.createFilter(a);
                      var v = createNS("feComponentTransfer");
                      v.setAttribute("in", "SourceGraphic"),
                      o.appendChild(v);
                      var S = createNS("feFuncA");
                      S.setAttribute("type", "table"),
                      S.setAttribute("tableValues", "1.0 0.0"),
                      v.appendChild(S),
                      this.globalData.defs.appendChild(o);
                      var b = createNS("rect");
                      b.setAttribute("width", this.comp.data.w),
                      b.setAttribute("height", this.comp.data.h),
                      b.setAttribute("x", "0"),
                      b.setAttribute("y", "0"),
                      b.setAttribute("fill", "#ffffff"),
                      b.setAttribute("opacity", "0"),
                      _.setAttribute("filter", "url(" + getLocationHref() + "#" + a + ")"),
                      _.appendChild(b),
                      l = createNS("use"),
                      l.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#" + this.layerId),
                      _.appendChild(l),
                      featureSupport.maskType || (g.setAttribute("mask-type", "luminance"),
                      o.appendChild(filtersFactory.createAlphaToLuminanceFilter()),
                      f = createNS("g"),
                      _.appendChild(b),
                      f.appendChild(this.layerElement),
                      _.appendChild(f)),
                      this.globalData.defs.appendChild(g)
                  }
                  this.matteMasks[t] = r
              }
              return this.matteMasks[t]
          },
          setMatte: function(t) {
              this.matteElement && this.matteElement.setAttribute("mask", "url(" + getLocationHref() + "#" + t + ")")
          }
      };
      function HierarchyElement() {}
      HierarchyElement.prototype = {
          initHierarchy: function() {
              this.hierarchy = [],
              this._isParent = !1,
              this.checkParenting()
          },
          setHierarchy: function(t) {
              this.hierarchy = t
          },
          setAsParent: function() {
              this._isParent = !0
          },
          checkParenting: function() {
              this.data.parent !== void 0 && this.comp.buildElementParenting(this, this.data.parent, [])
          }
      };
      function RenderableDOMElement() {}
      (function() {
          var e = {
              initElement: function(r, a, o) {
                  this.initFrame(),
                  this.initBaseData(r, a, o),
                  this.initTransform(r, a, o),
                  this.initHierarchy(),
                  this.initRenderable(),
                  this.initRendererElement(),
                  this.createContainerElements(),
                  this.createRenderableComponents(),
                  this.createContent(),
                  this.hide()
              },
              hide: function() {
                  if (!this.hidden && (!this.isInRange || this.isTransparent)) {
                      var r = this.baseElement || this.layerElement;
                      r.style.display = "none",
                      this.hidden = !0
                  }
              },
              show: function() {
                  if (this.isInRange && !this.isTransparent) {
                      if (!this.data.hd) {
                          var r = this.baseElement || this.layerElement;
                          r.style.display = "block"
                      }
                      this.hidden = !1,
                      this._isFirstFrame = !0
                  }
              },
              renderFrame: function() {
                  this.data.hd || this.hidden || (this.renderTransform(),
                  this.renderRenderable(),
                  this.renderLocalTransform(),
                  this.renderElement(),
                  this.renderInnerContent(),
                  this._isFirstFrame && (this._isFirstFrame = !1))
              },
              renderInnerContent: function() {},
              prepareFrame: function(r) {
                  this._mdf = !1,
                  this.prepareRenderableFrame(r),
                  this.prepareProperties(r, this.isInRange),
                  this.checkTransparency()
              },
              destroy: function() {
                  this.innerElem = null,
                  this.destroyBaseElement()
              }
          };
          extendPrototype([RenderableElement, createProxyFunction(e)], RenderableDOMElement)
      }
      )();
      function IImageElement(e, t, r) {
          this.assetData = t.getAssetData(e.refId),
          this.assetData && this.assetData.sid && (this.assetData = t.slotManager.getProp(this.assetData)),
          this.initElement(e, t, r),
          this.sourceRect = {
              top: 0,
              left: 0,
              width: this.assetData.w,
              height: this.assetData.h
          }
      }
      extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], IImageElement),
      IImageElement.prototype.createContent = function() {
          var e = this.globalData.getAssetsPath(this.assetData);
          this.innerElem = createNS("image"),
          this.innerElem.setAttribute("width", this.assetData.w + "px"),
          this.innerElem.setAttribute("height", this.assetData.h + "px"),
          this.innerElem.setAttribute("preserveAspectRatio", this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio),
          this.innerElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", e),
          this.layerElement.appendChild(this.innerElem)
      }
      ,
      IImageElement.prototype.sourceRectAtTime = function() {
          return this.sourceRect
      }
      ;
      function ProcessedElement(e, t) {
          this.elem = e,
          this.pos = t
      }
      function IShapeElement() {}
      IShapeElement.prototype = {
          addShapeToModifiers: function(t) {
              var r, a = this.shapeModifiers.length;
              for (r = 0; r < a; r += 1)
                  this.shapeModifiers[r].addShape(t)
          },
          isShapeInAnimatedModifiers: function(t) {
              for (var r = 0, a = this.shapeModifiers.length; r < a; )
                  if (this.shapeModifiers[r].isAnimatedWithShape(t))
                      return !0;
              return !1
          },
          renderModifiers: function() {
              if (this.shapeModifiers.length) {
                  var t, r = this.shapes.length;
                  for (t = 0; t < r; t += 1)
                      this.shapes[t].sh.reset();
                  r = this.shapeModifiers.length;
                  var a;
                  for (t = r - 1; t >= 0 && (a = this.shapeModifiers[t].processShapes(this._isFirstFrame),
                  !a); t -= 1)
                      ;
              }
          },
          searchProcessedElement: function(t) {
              for (var r = this.processedElements, a = 0, o = r.length; a < o; ) {
                  if (r[a].elem === t)
                      return r[a].pos;
                  a += 1
              }
              return 0
          },
          addProcessedElement: function(t, r) {
              for (var a = this.processedElements, o = a.length; o; )
                  if (o -= 1,
                  a[o].elem === t) {
                      a[o].pos = r;
                      return
                  }
              a.push(new ProcessedElement(t,r))
          },
          prepareFrame: function(t) {
              this.prepareRenderableFrame(t),
              this.prepareProperties(t, this.isInRange)
          }
      };
      var lineCapEnum = {
          1: "butt",
          2: "round",
          3: "square"
      }
        , lineJoinEnum = {
          1: "miter",
          2: "round",
          3: "bevel"
      };
      function SVGShapeData(e, t, r) {
          this.caches = [],
          this.styles = [],
          this.transformers = e,
          this.lStr = "",
          this.sh = r,
          this.lvl = t,
          this._isAnimated = !!r.k;
          for (var a = 0, o = e.length; a < o; ) {
              if (e[a].mProps.dynamicProperties.length) {
                  this._isAnimated = !0;
                  break
              }
              a += 1
          }
      }
      SVGShapeData.prototype.setAsAnimated = function() {
          this._isAnimated = !0
      }
      ;
      function SVGStyleData(e, t) {
          this.data = e,
          this.type = e.ty,
          this.d = "",
          this.lvl = t,
          this._mdf = !1,
          this.closed = e.hd === !0,
          this.pElem = createNS("path"),
          this.msElem = null
      }
      SVGStyleData.prototype.reset = function() {
          this.d = "",
          this._mdf = !1
      }
      ;
      function DashProperty(e, t, r, a) {
          this.elem = e,
          this.frameId = -1,
          this.dataProps = createSizedArray(t.length),
          this.renderer = r,
          this.k = !1,
          this.dashStr = "",
          this.dashArray = createTypedArray("float32", t.length ? t.length - 1 : 0),
          this.dashoffset = createTypedArray("float32", 1),
          this.initDynamicPropertyContainer(a);
          var o, l = t.length || 0, f;
          for (o = 0; o < l; o += 1)
              f = PropertyFactory.getProp(e, t[o].v, 0, 0, this),
              this.k = f.k || this.k,
              this.dataProps[o] = {
                  n: t[o].n,
                  p: f
              };
          this.k || this.getValue(!0),
          this._isAnimated = this.k
      }
      DashProperty.prototype.getValue = function(e) {
          if (!(this.elem.globalData.frameId === this.frameId && !e) && (this.frameId = this.elem.globalData.frameId,
          this.iterateDynamicProperties(),
          this._mdf = this._mdf || e,
          this._mdf)) {
              var t = 0
                , r = this.dataProps.length;
              for (this.renderer === "svg" && (this.dashStr = ""),
              t = 0; t < r; t += 1)
                  this.dataProps[t].n !== "o" ? this.renderer === "svg" ? this.dashStr += " " + this.dataProps[t].p.v : this.dashArray[t] = this.dataProps[t].p.v : this.dashoffset[0] = this.dataProps[t].p.v
          }
      }
      ,
      extendPrototype([DynamicPropertyContainer], DashProperty);
      function SVGStrokeStyleData(e, t, r) {
          this.initDynamicPropertyContainer(e),
          this.getValue = this.iterateDynamicProperties,
          this.o = PropertyFactory.getProp(e, t.o, 0, .01, this),
          this.w = PropertyFactory.getProp(e, t.w, 0, null, this),
          this.d = new DashProperty(e,t.d || {},"svg",this),
          this.c = PropertyFactory.getProp(e, t.c, 1, 255, this),
          this.style = r,
          this._isAnimated = !!this._isAnimated
      }
      extendPrototype([DynamicPropertyContainer], SVGStrokeStyleData);
      function SVGFillStyleData(e, t, r) {
          this.initDynamicPropertyContainer(e),
          this.getValue = this.iterateDynamicProperties,
          this.o = PropertyFactory.getProp(e, t.o, 0, .01, this),
          this.c = PropertyFactory.getProp(e, t.c, 1, 255, this),
          this.style = r
      }
      extendPrototype([DynamicPropertyContainer], SVGFillStyleData);
      function SVGNoStyleData(e, t, r) {
          this.initDynamicPropertyContainer(e),
          this.getValue = this.iterateDynamicProperties,
          this.style = r
      }
      extendPrototype([DynamicPropertyContainer], SVGNoStyleData);
      function GradientProperty(e, t, r) {
          this.data = t,
          this.c = createTypedArray("uint8c", t.p * 4);
          var a = t.k.k[0].s ? t.k.k[0].s.length - t.p * 4 : t.k.k.length - t.p * 4;
          this.o = createTypedArray("float32", a),
          this._cmdf = !1,
          this._omdf = !1,
          this._collapsable = this.checkCollapsable(),
          this._hasOpacity = a,
          this.initDynamicPropertyContainer(r),
          this.prop = PropertyFactory.getProp(e, t.k, 1, null, this),
          this.k = this.prop.k,
          this.getValue(!0)
      }
      GradientProperty.prototype.comparePoints = function(e, t) {
          for (var r = 0, a = this.o.length / 2, o; r < a; ) {
              if (o = Math.abs(e[r * 4] - e[t * 4 + r * 2]),
              o > .01)
                  return !1;
              r += 1
          }
          return !0
      }
      ,
      GradientProperty.prototype.checkCollapsable = function() {
          if (this.o.length / 2 !== this.c.length / 4)
              return !1;
          if (this.data.k.k[0].s)
              for (var e = 0, t = this.data.k.k.length; e < t; ) {
                  if (!this.comparePoints(this.data.k.k[e].s, this.data.p))
                      return !1;
                  e += 1
              }
          else if (!this.comparePoints(this.data.k.k, this.data.p))
              return !1;
          return !0
      }
      ,
      GradientProperty.prototype.getValue = function(e) {
          if (this.prop.getValue(),
          this._mdf = !1,
          this._cmdf = !1,
          this._omdf = !1,
          this.prop._mdf || e) {
              var t, r = this.data.p * 4, a, o;
              for (t = 0; t < r; t += 1)
                  a = t % 4 === 0 ? 100 : 255,
                  o = Math.round(this.prop.v[t] * a),
                  this.c[t] !== o && (this.c[t] = o,
                  this._cmdf = !e);
              if (this.o.length)
                  for (r = this.prop.v.length,
                  t = this.data.p * 4; t < r; t += 1)
                      a = t % 2 === 0 ? 100 : 1,
                      o = t % 2 === 0 ? Math.round(this.prop.v[t] * 100) : this.prop.v[t],
                      this.o[t - this.data.p * 4] !== o && (this.o[t - this.data.p * 4] = o,
                      this._omdf = !e);
              this._mdf = !e
          }
      }
      ,
      extendPrototype([DynamicPropertyContainer], GradientProperty);
      function SVGGradientFillStyleData(e, t, r) {
          this.initDynamicPropertyContainer(e),
          this.getValue = this.iterateDynamicProperties,
          this.initGradientData(e, t, r)
      }
      SVGGradientFillStyleData.prototype.initGradientData = function(e, t, r) {
          this.o = PropertyFactory.getProp(e, t.o, 0, .01, this),
          this.s = PropertyFactory.getProp(e, t.s, 1, null, this),
          this.e = PropertyFactory.getProp(e, t.e, 1, null, this),
          this.h = PropertyFactory.getProp(e, t.h || {
              k: 0
          }, 0, .01, this),
          this.a = PropertyFactory.getProp(e, t.a || {
              k: 0
          }, 0, degToRads, this),
          this.g = new GradientProperty(e,t.g,this),
          this.style = r,
          this.stops = [],
          this.setGradientData(r.pElem, t),
          this.setGradientOpacity(t, r),
          this._isAnimated = !!this._isAnimated
      }
      ,
      SVGGradientFillStyleData.prototype.setGradientData = function(e, t) {
          var r = createElementID()
            , a = createNS(t.t === 1 ? "linearGradient" : "radialGradient");
          a.setAttribute("id", r),
          a.setAttribute("spreadMethod", "pad"),
          a.setAttribute("gradientUnits", "userSpaceOnUse");
          var o = [], l, f, d;
          for (d = t.g.p * 4,
          f = 0; f < d; f += 4)
              l = createNS("stop"),
              a.appendChild(l),
              o.push(l);
          e.setAttribute(t.ty === "gf" ? "fill" : "stroke", "url(" + getLocationHref() + "#" + r + ")"),
          this.gf = a,
          this.cst = o
      }
      ,
      SVGGradientFillStyleData.prototype.setGradientOpacity = function(e, t) {
          if (this.g._hasOpacity && !this.g._collapsable) {
              var r, a, o, l = createNS("mask"), f = createNS("path");
              l.appendChild(f);
              var d = createElementID()
                , g = createElementID();
              l.setAttribute("id", g);
              var _ = createNS(e.t === 1 ? "linearGradient" : "radialGradient");
              _.setAttribute("id", d),
              _.setAttribute("spreadMethod", "pad"),
              _.setAttribute("gradientUnits", "userSpaceOnUse"),
              o = e.g.k.k[0].s ? e.g.k.k[0].s.length : e.g.k.k.length;
              var v = this.stops;
              for (a = e.g.p * 4; a < o; a += 2)
                  r = createNS("stop"),
                  r.setAttribute("stop-color", "rgb(255,255,255)"),
                  _.appendChild(r),
                  v.push(r);
              f.setAttribute(e.ty === "gf" ? "fill" : "stroke", "url(" + getLocationHref() + "#" + d + ")"),
              e.ty === "gs" && (f.setAttribute("stroke-linecap", lineCapEnum[e.lc || 2]),
              f.setAttribute("stroke-linejoin", lineJoinEnum[e.lj || 2]),
              e.lj === 1 && f.setAttribute("stroke-miterlimit", e.ml)),
              this.of = _,
              this.ms = l,
              this.ost = v,
              this.maskId = g,
              t.msElem = f
          }
      }
      ,
      extendPrototype([DynamicPropertyContainer], SVGGradientFillStyleData);
      function SVGGradientStrokeStyleData(e, t, r) {
          this.initDynamicPropertyContainer(e),
          this.getValue = this.iterateDynamicProperties,
          this.w = PropertyFactory.getProp(e, t.w, 0, null, this),
          this.d = new DashProperty(e,t.d || {},"svg",this),
          this.initGradientData(e, t, r),
          this._isAnimated = !!this._isAnimated
      }
      extendPrototype([SVGGradientFillStyleData, DynamicPropertyContainer], SVGGradientStrokeStyleData);
      function ShapeGroupData() {
          this.it = [],
          this.prevViewData = [],
          this.gr = createNS("g")
      }
      function SVGTransformData(e, t, r) {
          this.transform = {
              mProps: e,
              op: t,
              container: r
          },
          this.elements = [],
          this._isAnimated = this.transform.mProps.dynamicProperties.length || this.transform.op.effectsSequence.length
      }
      var buildShapeString = function(t, r, a, o) {
          if (r === 0)
              return "";
          var l = t.o, f = t.i, d = t.v, g, _ = " M" + o.applyToPointStringified(d[0][0], d[0][1]);
          for (g = 1; g < r; g += 1)
              _ += " C" + o.applyToPointStringified(l[g - 1][0], l[g - 1][1]) + " " + o.applyToPointStringified(f[g][0], f[g][1]) + " " + o.applyToPointStringified(d[g][0], d[g][1]);
          return a && r && (_ += " C" + o.applyToPointStringified(l[g - 1][0], l[g - 1][1]) + " " + o.applyToPointStringified(f[0][0], f[0][1]) + " " + o.applyToPointStringified(d[0][0], d[0][1]),
          _ += "z"),
          _
      }
        , SVGElementsRenderer = function() {
          var e = new Matrix
            , t = new Matrix
            , r = {
              createRenderFunction: a
          };
          function a(S) {
              switch (S.ty) {
              case "fl":
                  return d;
              case "gf":
                  return _;
              case "gs":
                  return g;
              case "st":
                  return v;
              case "sh":
              case "el":
              case "rc":
              case "sr":
                  return f;
              case "tr":
                  return o;
              case "no":
                  return l;
              default:
                  return null
              }
          }
          function o(S, b, P) {
              (P || b.transform.op._mdf) && b.transform.container.setAttribute("opacity", b.transform.op.v),
              (P || b.transform.mProps._mdf) && b.transform.container.setAttribute("transform", b.transform.mProps.v.to2dCSS())
          }
          function l() {}
          function f(S, b, P) {
              var x, E, I, C, A, T, w = b.styles.length, M = b.lvl, F, O, $, j;
              for (T = 0; T < w; T += 1) {
                  if (C = b.sh._mdf || P,
                  b.styles[T].lvl < M) {
                      for (O = t.reset(),
                      $ = M - b.styles[T].lvl,
                      j = b.transformers.length - 1; !C && $ > 0; )
                          C = b.transformers[j].mProps._mdf || C,
                          $ -= 1,
                          j -= 1;
                      if (C)
                          for ($ = M - b.styles[T].lvl,
                          j = b.transformers.length - 1; $ > 0; )
                              O.multiply(b.transformers[j].mProps.v),
                              $ -= 1,
                              j -= 1
                  } else
                      O = e;
                  if (F = b.sh.paths,
                  E = F._length,
                  C) {
                      for (I = "",
                      x = 0; x < E; x += 1)
                          A = F.shapes[x],
                          A && A._length && (I += buildShapeString(A, A._length, A.c, O));
                      b.caches[T] = I
                  } else
                      I = b.caches[T];
                  b.styles[T].d += S.hd === !0 ? "" : I,
                  b.styles[T]._mdf = C || b.styles[T]._mdf
              }
          }
          function d(S, b, P) {
              var x = b.style;
              (b.c._mdf || P) && x.pElem.setAttribute("fill", "rgb(" + bmFloor(b.c.v[0]) + "," + bmFloor(b.c.v[1]) + "," + bmFloor(b.c.v[2]) + ")"),
              (b.o._mdf || P) && x.pElem.setAttribute("fill-opacity", b.o.v)
          }
          function g(S, b, P) {
              _(S, b, P),
              v(S, b, P)
          }
          function _(S, b, P) {
              var x = b.gf
                , E = b.g._hasOpacity
                , I = b.s.v
                , C = b.e.v;
              if (b.o._mdf || P) {
                  var A = S.ty === "gf" ? "fill-opacity" : "stroke-opacity";
                  b.style.pElem.setAttribute(A, b.o.v)
              }
              if (b.s._mdf || P) {
                  var T = S.t === 1 ? "x1" : "cx"
                    , w = T === "x1" ? "y1" : "cy";
                  x.setAttribute(T, I[0]),
                  x.setAttribute(w, I[1]),
                  E && !b.g._collapsable && (b.of.setAttribute(T, I[0]),
                  b.of.setAttribute(w, I[1]))
              }
              var M, F, O, $;
              if (b.g._cmdf || P) {
                  M = b.cst;
                  var j = b.g.c;
                  for (O = M.length,
                  F = 0; F < O; F += 1)
                      $ = M[F],
                      $.setAttribute("offset", j[F * 4] + "%"),
                      $.setAttribute("stop-color", "rgb(" + j[F * 4 + 1] + "," + j[F * 4 + 2] + "," + j[F * 4 + 3] + ")")
              }
              if (E && (b.g._omdf || P)) {
                  var K = b.g.o;
                  for (b.g._collapsable ? M = b.cst : M = b.ost,
                  O = M.length,
                  F = 0; F < O; F += 1)
                      $ = M[F],
                      b.g._collapsable || $.setAttribute("offset", K[F * 2] + "%"),
                      $.setAttribute("stop-opacity", K[F * 2 + 1])
              }
              if (S.t === 1)
                  (b.e._mdf || P) && (x.setAttribute("x2", C[0]),
                  x.setAttribute("y2", C[1]),
                  E && !b.g._collapsable && (b.of.setAttribute("x2", C[0]),
                  b.of.setAttribute("y2", C[1])));
              else {
                  var Y;
                  if ((b.s._mdf || b.e._mdf || P) && (Y = Math.sqrt(Math.pow(I[0] - C[0], 2) + Math.pow(I[1] - C[1], 2)),
                  x.setAttribute("r", Y),
                  E && !b.g._collapsable && b.of.setAttribute("r", Y)),
                  b.e._mdf || b.h._mdf || b.a._mdf || P) {
                      Y || (Y = Math.sqrt(Math.pow(I[0] - C[0], 2) + Math.pow(I[1] - C[1], 2)));
                      var W = Math.atan2(C[1] - I[1], C[0] - I[0])
                        , Z = b.h.v;
                      Z >= 1 ? Z = .99 : Z <= -1 && (Z = -.99);
                      var ee = Y * Z
                        , X = Math.cos(W + b.a.v) * ee + I[0]
                        , D = Math.sin(W + b.a.v) * ee + I[1];
                      x.setAttribute("fx", X),
                      x.setAttribute("fy", D),
                      E && !b.g._collapsable && (b.of.setAttribute("fx", X),
                      b.of.setAttribute("fy", D))
                  }
              }
          }
          function v(S, b, P) {
              var x = b.style
                , E = b.d;
              E && (E._mdf || P) && E.dashStr && (x.pElem.setAttribute("stroke-dasharray", E.dashStr),
              x.pElem.setAttribute("stroke-dashoffset", E.dashoffset[0])),
              b.c && (b.c._mdf || P) && x.pElem.setAttribute("stroke", "rgb(" + bmFloor(b.c.v[0]) + "," + bmFloor(b.c.v[1]) + "," + bmFloor(b.c.v[2]) + ")"),
              (b.o._mdf || P) && x.pElem.setAttribute("stroke-opacity", b.o.v),
              (b.w._mdf || P) && (x.pElem.setAttribute("stroke-width", b.w.v),
              x.msElem && x.msElem.setAttribute("stroke-width", b.w.v))
          }
          return r
      }();
      function SVGShapeElement(e, t, r) {
          this.shapes = [],
          this.shapesData = e.shapes,
          this.stylesList = [],
          this.shapeModifiers = [],
          this.itemsData = [],
          this.processedElements = [],
          this.animatedContents = [],
          this.initElement(e, t, r),
          this.prevViewData = []
      }
      extendPrototype([BaseElement, TransformElement, SVGBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableDOMElement], SVGShapeElement),
      SVGShapeElement.prototype.initSecondaryElement = function() {}
      ,
      SVGShapeElement.prototype.identityMatrix = new Matrix,
      SVGShapeElement.prototype.buildExpressionInterface = function() {}
      ,
      SVGShapeElement.prototype.createContent = function() {
          this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], !0),
          this.filterUniqueShapes()
      }
      ,
      SVGShapeElement.prototype.filterUniqueShapes = function() {
          var e, t = this.shapes.length, r, a, o = this.stylesList.length, l, f = [], d = !1;
          for (a = 0; a < o; a += 1) {
              for (l = this.stylesList[a],
              d = !1,
              f.length = 0,
              e = 0; e < t; e += 1)
                  r = this.shapes[e],
                  r.styles.indexOf(l) !== -1 && (f.push(r),
                  d = r._isAnimated || d);
              f.length > 1 && d && this.setShapesAsAnimated(f)
          }
      }
      ,
      SVGShapeElement.prototype.setShapesAsAnimated = function(e) {
          var t, r = e.length;
          for (t = 0; t < r; t += 1)
              e[t].setAsAnimated()
      }
      ,
      SVGShapeElement.prototype.createStyleElement = function(e, t) {
          var r, a = new SVGStyleData(e,t), o = a.pElem;
          if (e.ty === "st")
              r = new SVGStrokeStyleData(this,e,a);
          else if (e.ty === "fl")
              r = new SVGFillStyleData(this,e,a);
          else if (e.ty === "gf" || e.ty === "gs") {
              var l = e.ty === "gf" ? SVGGradientFillStyleData : SVGGradientStrokeStyleData;
              r = new l(this,e,a),
              this.globalData.defs.appendChild(r.gf),
              r.maskId && (this.globalData.defs.appendChild(r.ms),
              this.globalData.defs.appendChild(r.of),
              o.setAttribute("mask", "url(" + getLocationHref() + "#" + r.maskId + ")"))
          } else
              e.ty === "no" && (r = new SVGNoStyleData(this,e,a));
          return (e.ty === "st" || e.ty === "gs") && (o.setAttribute("stroke-linecap", lineCapEnum[e.lc || 2]),
          o.setAttribute("stroke-linejoin", lineJoinEnum[e.lj || 2]),
          o.setAttribute("fill-opacity", "0"),
          e.lj === 1 && o.setAttribute("stroke-miterlimit", e.ml)),
          e.r === 2 && o.setAttribute("fill-rule", "evenodd"),
          e.ln && o.setAttribute("id", e.ln),
          e.cl && o.setAttribute("class", e.cl),
          e.bm && (o.style["mix-blend-mode"] = getBlendMode(e.bm)),
          this.stylesList.push(a),
          this.addToAnimatedContents(e, r),
          r
      }
      ,
      SVGShapeElement.prototype.createGroupElement = function(e) {
          var t = new ShapeGroupData;
          return e.ln && t.gr.setAttribute("id", e.ln),
          e.cl && t.gr.setAttribute("class", e.cl),
          e.bm && (t.gr.style["mix-blend-mode"] = getBlendMode(e.bm)),
          t
      }
      ,
      SVGShapeElement.prototype.createTransformElement = function(e, t) {
          var r = TransformPropertyFactory.getTransformProperty(this, e, this)
            , a = new SVGTransformData(r,r.o,t);
          return this.addToAnimatedContents(e, a),
          a
      }
      ,
      SVGShapeElement.prototype.createShapeElement = function(e, t, r) {
          var a = 4;
          e.ty === "rc" ? a = 5 : e.ty === "el" ? a = 6 : e.ty === "sr" && (a = 7);
          var o = ShapePropertyFactory.getShapeProp(this, e, a, this)
            , l = new SVGShapeData(t,r,o);
          return this.shapes.push(l),
          this.addShapeToModifiers(l),
          this.addToAnimatedContents(e, l),
          l
      }
      ,
      SVGShapeElement.prototype.addToAnimatedContents = function(e, t) {
          for (var r = 0, a = this.animatedContents.length; r < a; ) {
              if (this.animatedContents[r].element === t)
                  return;
              r += 1
          }
          this.animatedContents.push({
              fn: SVGElementsRenderer.createRenderFunction(e),
              element: t,
              data: e
          })
      }
      ,
      SVGShapeElement.prototype.setElementStyles = function(e) {
          var t = e.styles, r, a = this.stylesList.length;
          for (r = 0; r < a; r += 1)
              this.stylesList[r].closed || t.push(this.stylesList[r])
      }
      ,
      SVGShapeElement.prototype.reloadShapes = function() {
          this._isFirstFrame = !0;
          var e, t = this.itemsData.length;
          for (e = 0; e < t; e += 1)
              this.prevViewData[e] = this.itemsData[e];
          for (this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], !0),
          this.filterUniqueShapes(),
          t = this.dynamicProperties.length,
          e = 0; e < t; e += 1)
              this.dynamicProperties[e].getValue();
          this.renderModifiers()
      }
      ,
      SVGShapeElement.prototype.searchShapes = function(e, t, r, a, o, l, f) {
          var d = [].concat(l), g, _ = e.length - 1, v, S, b = [], P = [], x, E, I;
          for (g = _; g >= 0; g -= 1) {
              if (I = this.searchProcessedElement(e[g]),
              I ? t[g] = r[I - 1] : e[g]._render = f,
              e[g].ty === "fl" || e[g].ty === "st" || e[g].ty === "gf" || e[g].ty === "gs" || e[g].ty === "no")
                  I ? t[g].style.closed = !1 : t[g] = this.createStyleElement(e[g], o),
                  e[g]._render && t[g].style.pElem.parentNode !== a && a.appendChild(t[g].style.pElem),
                  b.push(t[g].style);
              else if (e[g].ty === "gr") {
                  if (!I)
                      t[g] = this.createGroupElement(e[g]);
                  else
                      for (S = t[g].it.length,
                      v = 0; v < S; v += 1)
                          t[g].prevViewData[v] = t[g].it[v];
                  this.searchShapes(e[g].it, t[g].it, t[g].prevViewData, t[g].gr, o + 1, d, f),
                  e[g]._render && t[g].gr.parentNode !== a && a.appendChild(t[g].gr)
              } else
                  e[g].ty === "tr" ? (I || (t[g] = this.createTransformElement(e[g], a)),
                  x = t[g].transform,
                  d.push(x)) : e[g].ty === "sh" || e[g].ty === "rc" || e[g].ty === "el" || e[g].ty === "sr" ? (I || (t[g] = this.createShapeElement(e[g], d, o)),
                  this.setElementStyles(t[g])) : e[g].ty === "tm" || e[g].ty === "rd" || e[g].ty === "ms" || e[g].ty === "pb" || e[g].ty === "zz" || e[g].ty === "op" ? (I ? (E = t[g],
                  E.closed = !1) : (E = ShapeModifiers.getModifier(e[g].ty),
                  E.init(this, e[g]),
                  t[g] = E,
                  this.shapeModifiers.push(E)),
                  P.push(E)) : e[g].ty === "rp" && (I ? (E = t[g],
                  E.closed = !0) : (E = ShapeModifiers.getModifier(e[g].ty),
                  t[g] = E,
                  E.init(this, e, g, t),
                  this.shapeModifiers.push(E),
                  f = !1),
                  P.push(E));
              this.addProcessedElement(e[g], g + 1)
          }
          for (_ = b.length,
          g = 0; g < _; g += 1)
              b[g].closed = !0;
          for (_ = P.length,
          g = 0; g < _; g += 1)
              P[g].closed = !0
      }
      ,
      SVGShapeElement.prototype.renderInnerContent = function() {
          this.renderModifiers();
          var e, t = this.stylesList.length;
          for (e = 0; e < t; e += 1)
              this.stylesList[e].reset();
          for (this.renderShape(),
          e = 0; e < t; e += 1)
              (this.stylesList[e]._mdf || this._isFirstFrame) && (this.stylesList[e].msElem && (this.stylesList[e].msElem.setAttribute("d", this.stylesList[e].d),
              this.stylesList[e].d = "M0 0" + this.stylesList[e].d),
              this.stylesList[e].pElem.setAttribute("d", this.stylesList[e].d || "M0 0"))
      }
      ,
      SVGShapeElement.prototype.renderShape = function() {
          var e, t = this.animatedContents.length, r;
          for (e = 0; e < t; e += 1)
              r = this.animatedContents[e],
              (this._isFirstFrame || r.element._isAnimated) && r.data !== !0 && r.fn(r.data, r.element, this._isFirstFrame)
      }
      ,
      SVGShapeElement.prototype.destroy = function() {
          this.destroyBaseElement(),
          this.shapesData = null,
          this.itemsData = null
      }
      ;
      function LetterProps(e, t, r, a, o, l) {
          this.o = e,
          this.sw = t,
          this.sc = r,
          this.fc = a,
          this.m = o,
          this.p = l,
          this._mdf = {
              o: !0,
              sw: !!t,
              sc: !!r,
              fc: !!a,
              m: !0,
              p: !0
          }
      }
      LetterProps.prototype.update = function(e, t, r, a, o, l) {
          this._mdf.o = !1,
          this._mdf.sw = !1,
          this._mdf.sc = !1,
          this._mdf.fc = !1,
          this._mdf.m = !1,
          this._mdf.p = !1;
          var f = !1;
          return this.o !== e && (this.o = e,
          this._mdf.o = !0,
          f = !0),
          this.sw !== t && (this.sw = t,
          this._mdf.sw = !0,
          f = !0),
          this.sc !== r && (this.sc = r,
          this._mdf.sc = !0,
          f = !0),
          this.fc !== a && (this.fc = a,
          this._mdf.fc = !0,
          f = !0),
          this.m !== o && (this.m = o,
          this._mdf.m = !0,
          f = !0),
          l.length && (this.p[0] !== l[0] || this.p[1] !== l[1] || this.p[4] !== l[4] || this.p[5] !== l[5] || this.p[12] !== l[12] || this.p[13] !== l[13]) && (this.p = l,
          this._mdf.p = !0,
          f = !0),
          f
      }
      ;
      function TextProperty(e, t) {
          this._frameId = initialDefaultFrame,
          this.pv = "",
          this.v = "",
          this.kf = !1,
          this._isFirstFrame = !0,
          this._mdf = !1,
          t.d && t.d.sid && (t.d = e.globalData.slotManager.getProp(t.d)),
          this.data = t,
          this.elem = e,
          this.comp = this.elem.comp,
          this.keysIndex = 0,
          this.canResize = !1,
          this.minimumFontSize = 1,
          this.effectsSequence = [],
          this.currentData = {
              ascent: 0,
              boxWidth: this.defaultBoxWidth,
              f: "",
              fStyle: "",
              fWeight: "",
              fc: "",
              j: "",
              justifyOffset: "",
              l: [],
              lh: 0,
              lineWidths: [],
              ls: "",
              of: "",
              s: "",
              sc: "",
              sw: 0,
              t: 0,
              tr: 0,
              sz: 0,
              ps: null,
              fillColorAnim: !1,
              strokeColorAnim: !1,
              strokeWidthAnim: !1,
              yOffset: 0,
              finalSize: 0,
              finalText: [],
              finalLineHeight: 0,
              __complete: !1
          },
          this.copyData(this.currentData, this.data.d.k[0].s),
          this.searchProperty() || this.completeTextData(this.currentData)
      }
      TextProperty.prototype.defaultBoxWidth = [0, 0],
      TextProperty.prototype.copyData = function(e, t) {
          for (var r in t)
              Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
          return e
      }
      ,
      TextProperty.prototype.setCurrentData = function(e) {
          e.__complete || this.completeTextData(e),
          this.currentData = e,
          this.currentData.boxWidth = this.currentData.boxWidth || this.defaultBoxWidth,
          this._mdf = !0
      }
      ,
      TextProperty.prototype.searchProperty = function() {
          return this.searchKeyframes()
      }
      ,
      TextProperty.prototype.searchKeyframes = function() {
          return this.kf = this.data.d.k.length > 1,
          this.kf && this.addEffect(this.getKeyframeValue.bind(this)),
          this.kf
      }
      ,
      TextProperty.prototype.addEffect = function(e) {
          this.effectsSequence.push(e),
          this.elem.addDynamicProperty(this)
      }
      ,
      TextProperty.prototype.getValue = function(e) {
          if (!((this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) && !e)) {
              this.currentData.t = this.data.d.k[this.keysIndex].s.t;
              var t = this.currentData
                , r = this.keysIndex;
              if (this.lock) {
                  this.setCurrentData(this.currentData);
                  return
              }
              this.lock = !0,
              this._mdf = !1;
              var a, o = this.effectsSequence.length, l = e || this.data.d.k[this.keysIndex].s;
              for (a = 0; a < o; a += 1)
                  r !== this.keysIndex ? l = this.effectsSequence[a](l, l.t) : l = this.effectsSequence[a](this.currentData, l.t);
              t !== l && this.setCurrentData(l),
              this.v = this.currentData,
              this.pv = this.v,
              this.lock = !1,
              this.frameId = this.elem.globalData.frameId
          }
      }
      ,
      TextProperty.prototype.getKeyframeValue = function() {
          for (var e = this.data.d.k, t = this.elem.comp.renderedFrame, r = 0, a = e.length; r <= a - 1 && !(r === a - 1 || e[r + 1].t > t); )
              r += 1;
          return this.keysIndex !== r && (this.keysIndex = r),
          this.data.d.k[this.keysIndex].s
      }
      ,
      TextProperty.prototype.buildFinalText = function(e) {
          for (var t = [], r = 0, a = e.length, o, l, f = !1, d = !1, g = ""; r < a; )
              f = d,
              d = !1,
              o = e.charCodeAt(r),
              g = e.charAt(r),
              FontManager.isCombinedCharacter(o) ? f = !0 : o >= 55296 && o <= 56319 ? FontManager.isRegionalFlag(e, r) ? g = e.substr(r, 14) : (l = e.charCodeAt(r + 1),
              l >= 56320 && l <= 57343 && (FontManager.isModifier(o, l) ? (g = e.substr(r, 2),
              f = !0) : FontManager.isFlagEmoji(e.substr(r, 4)) ? g = e.substr(r, 4) : g = e.substr(r, 2))) : o > 56319 ? (l = e.charCodeAt(r + 1),
              FontManager.isVariationSelector(o) && (f = !0)) : FontManager.isZeroWidthJoiner(o) && (f = !0,
              d = !0),
              f ? (t[t.length - 1] += g,
              f = !1) : t.push(g),
              r += g.length;
          return t
      }
      ,
      TextProperty.prototype.completeTextData = function(e) {
          e.__complete = !0;
          var t = this.elem.globalData.fontManager, r = this.data, a = [], o, l, f, d = 0, g, _ = r.m.g, v = 0, S = 0, b = 0, P = [], x = 0, E = 0, I, C, A = t.getFontByName(e.f), T, w = 0, M = getFontProperties(A);
          e.fWeight = M.weight,
          e.fStyle = M.style,
          e.finalSize = e.s,
          e.finalText = this.buildFinalText(e.t),
          l = e.finalText.length,
          e.finalLineHeight = e.lh;
          var F = e.tr / 1e3 * e.finalSize, O;
          if (e.sz)
              for (var $ = !0, j = e.sz[0], K = e.sz[1], Y, W; $; ) {
                  W = this.buildFinalText(e.t),
                  Y = 0,
                  x = 0,
                  l = W.length,
                  F = e.tr / 1e3 * e.finalSize;
                  var Z = -1;
                  for (o = 0; o < l; o += 1)
                      O = W[o].charCodeAt(0),
                      f = !1,
                      W[o] === " " ? Z = o : (O === 13 || O === 3) && (x = 0,
                      f = !0,
                      Y += e.finalLineHeight || e.finalSize * 1.2),
                      t.chars ? (T = t.getCharData(W[o], A.fStyle, A.fFamily),
                      w = f ? 0 : T.w * e.finalSize / 100) : w = t.measureText(W[o], e.f, e.finalSize),
                      x + w > j && W[o] !== " " ? (Z === -1 ? l += 1 : o = Z,
                      Y += e.finalLineHeight || e.finalSize * 1.2,
                      W.splice(o, Z === o ? 1 : 0, "\r"),
                      Z = -1,
                      x = 0) : (x += w,
                      x += F);
                  Y += A.ascent * e.finalSize / 100,
                  this.canResize && e.finalSize > this.minimumFontSize && K < Y ? (e.finalSize -= 1,
                  e.finalLineHeight = e.finalSize * e.lh / e.s) : (e.finalText = W,
                  l = e.finalText.length,
                  $ = !1)
              }
          x = -F,
          w = 0;
          var ee = 0, X;
          for (o = 0; o < l; o += 1)
              if (f = !1,
              X = e.finalText[o],
              O = X.charCodeAt(0),
              O === 13 || O === 3 ? (ee = 0,
              P.push(x),
              E = x > E ? x : E,
              x = -2 * F,
              g = "",
              f = !0,
              b += 1) : g = X,
              t.chars ? (T = t.getCharData(X, A.fStyle, t.getFontByName(e.f).fFamily),
              w = f ? 0 : T.w * e.finalSize / 100) : w = t.measureText(g, e.f, e.finalSize),
              X === " " ? ee += w + F : (x += w + F + ee,
              ee = 0),
              a.push({
                  l: w,
                  an: w,
                  add: v,
                  n: f,
                  anIndexes: [],
                  val: g,
                  line: b,
                  animatorJustifyOffset: 0
              }),
              _ == 2) {
                  if (v += w,
                  g === "" || g === " " || o === l - 1) {
                      for ((g === "" || g === " ") && (v -= w); S <= o; )
                          a[S].an = v,
                          a[S].ind = d,
                          a[S].extra = w,
                          S += 1;
                      d += 1,
                      v = 0
                  }
              } else if (_ == 3) {
                  if (v += w,
                  g === "" || o === l - 1) {
                      for (g === "" && (v -= w); S <= o; )
                          a[S].an = v,
                          a[S].ind = d,
                          a[S].extra = w,
                          S += 1;
                      v = 0,
                      d += 1
                  }
              } else
                  a[d].ind = d,
                  a[d].extra = 0,
                  d += 1;
          if (e.l = a,
          E = x > E ? x : E,
          P.push(x),
          e.sz)
              e.boxWidth = e.sz[0],
              e.justifyOffset = 0;
          else
              switch (e.boxWidth = E,
              e.j) {
              case 1:
                  e.justifyOffset = -e.boxWidth;
                  break;
              case 2:
                  e.justifyOffset = -e.boxWidth / 2;
                  break;
              default:
                  e.justifyOffset = 0
              }
          e.lineWidths = P;
          var D = r.a, B, R;
          C = D.length;
          var L, V, q = [];
          for (I = 0; I < C; I += 1) {
              for (B = D[I],
              B.a.sc && (e.strokeColorAnim = !0),
              B.a.sw && (e.strokeWidthAnim = !0),
              (B.a.fc || B.a.fh || B.a.fs || B.a.fb) && (e.fillColorAnim = !0),
              V = 0,
              L = B.s.b,
              o = 0; o < l; o += 1)
                  R = a[o],
                  R.anIndexes[I] = V,
                  (L == 1 && R.val !== "" || L == 2 && R.val !== "" && R.val !== " " || L == 3 && (R.n || R.val == " " || o == l - 1) || L == 4 && (R.n || o == l - 1)) && (B.s.rn === 1 && q.push(V),
                  V += 1);
              r.a[I].s.totalChars = V;
              var oe = -1, ye;
              if (B.s.rn === 1)
                  for (o = 0; o < l; o += 1)
                      R = a[o],
                      oe != R.anIndexes[I] && (oe = R.anIndexes[I],
                      ye = q.splice(Math.floor(Math.random() * q.length), 1)[0]),
                      R.anIndexes[I] = ye
          }
          e.yOffset = e.finalLineHeight || e.finalSize * 1.2,
          e.ls = e.ls || 0,
          e.ascent = A.ascent * e.finalSize / 100
      }
      ,
      TextProperty.prototype.updateDocumentData = function(e, t) {
          t = t === void 0 ? this.keysIndex : t;
          var r = this.copyData({}, this.data.d.k[t].s);
          r = this.copyData(r, e),
          this.data.d.k[t].s = r,
          this.recalculate(t),
          this.setCurrentData(r),
          this.elem.addDynamicProperty(this)
      }
      ,
      TextProperty.prototype.recalculate = function(e) {
          var t = this.data.d.k[e].s;
          t.__complete = !1,
          this.keysIndex = 0,
          this._isFirstFrame = !0,
          this.getValue(t)
      }
      ,
      TextProperty.prototype.canResizeFont = function(e) {
          this.canResize = e,
          this.recalculate(this.keysIndex),
          this.elem.addDynamicProperty(this)
      }
      ,
      TextProperty.prototype.setMinimumFontSize = function(e) {
          this.minimumFontSize = Math.floor(e) || 1,
          this.recalculate(this.keysIndex),
          this.elem.addDynamicProperty(this)
      }
      ;
      var TextSelectorProp = function() {
          var e = Math.max
            , t = Math.min
            , r = Math.floor;
          function a(l, f) {
              this._currentTextLength = -1,
              this.k = !1,
              this.data = f,
              this.elem = l,
              this.comp = l.comp,
              this.finalS = 0,
              this.finalE = 0,
              this.initDynamicPropertyContainer(l),
              this.s = PropertyFactory.getProp(l, f.s || {
                  k: 0
              }, 0, 0, this),
              "e"in f ? this.e = PropertyFactory.getProp(l, f.e, 0, 0, this) : this.e = {
                  v: 100
              },
              this.o = PropertyFactory.getProp(l, f.o || {
                  k: 0
              }, 0, 0, this),
              this.xe = PropertyFactory.getProp(l, f.xe || {
                  k: 0
              }, 0, 0, this),
              this.ne = PropertyFactory.getProp(l, f.ne || {
                  k: 0
              }, 0, 0, this),
              this.sm = PropertyFactory.getProp(l, f.sm || {
                  k: 100
              }, 0, 0, this),
              this.a = PropertyFactory.getProp(l, f.a, 0, .01, this),
              this.dynamicProperties.length || this.getValue()
          }
          a.prototype = {
              getMult: function(f) {
                  this._currentTextLength !== this.elem.textProperty.currentData.l.length && this.getValue();
                  var d = 0
                    , g = 0
                    , _ = 1
                    , v = 1;
                  this.ne.v > 0 ? d = this.ne.v / 100 : g = -this.ne.v / 100,
                  this.xe.v > 0 ? _ = 1 - this.xe.v / 100 : v = 1 + this.xe.v / 100;
                  var S = BezierFactory.getBezierEasing(d, g, _, v).get
                    , b = 0
                    , P = this.finalS
                    , x = this.finalE
                    , E = this.data.sh;
                  if (E === 2)
                      x === P ? b = f >= x ? 1 : 0 : b = e(0, t(.5 / (x - P) + (f - P) / (x - P), 1)),
                      b = S(b);
                  else if (E === 3)
                      x === P ? b = f >= x ? 0 : 1 : b = 1 - e(0, t(.5 / (x - P) + (f - P) / (x - P), 1)),
                      b = S(b);
                  else if (E === 4)
                      x === P ? b = 0 : (b = e(0, t(.5 / (x - P) + (f - P) / (x - P), 1)),
                      b < .5 ? b *= 2 : b = 1 - 2 * (b - .5)),
                      b = S(b);
                  else if (E === 5) {
                      if (x === P)
                          b = 0;
                      else {
                          var I = x - P;
                          f = t(e(0, f + .5 - P), x - P);
                          var C = -I / 2 + f
                            , A = I / 2;
                          b = Math.sqrt(1 - C * C / (A * A))
                      }
                      b = S(b)
                  } else
                      E === 6 ? (x === P ? b = 0 : (f = t(e(0, f + .5 - P), x - P),
                      b = (1 + Math.cos(Math.PI + Math.PI * 2 * f / (x - P))) / 2),
                      b = S(b)) : (f >= r(P) && (f - P < 0 ? b = e(0, t(t(x, 1) - (P - f), 1)) : b = e(0, t(x - f, 1))),
                      b = S(b));
                  if (this.sm.v !== 100) {
                      var T = this.sm.v * .01;
                      T === 0 && (T = 1e-8);
                      var w = .5 - T * .5;
                      b < w ? b = 0 : (b = (b - w) / T,
                      b > 1 && (b = 1))
                  }
                  return b * this.a.v
              },
              getValue: function(f) {
                  this.iterateDynamicProperties(),
                  this._mdf = f || this._mdf,
                  this._currentTextLength = this.elem.textProperty.currentData.l.length || 0,
                  f && this.data.r === 2 && (this.e.v = this._currentTextLength);
                  var d = this.data.r === 2 ? 1 : 100 / this.data.totalChars
                    , g = this.o.v / d
                    , _ = this.s.v / d + g
                    , v = this.e.v / d + g;
                  if (_ > v) {
                      var S = _;
                      _ = v,
                      v = S
                  }
                  this.finalS = _,
                  this.finalE = v
              }
          },
          extendPrototype([DynamicPropertyContainer], a);
          function o(l, f, d) {
              return new a(l,f)
          }
          return {
              getTextSelectorProp: o
          }
      }();
      function TextAnimatorDataProperty(e, t, r) {
          var a = {
              propType: !1
          }
            , o = PropertyFactory.getProp
            , l = t.a;
          this.a = {
              r: l.r ? o(e, l.r, 0, degToRads, r) : a,
              rx: l.rx ? o(e, l.rx, 0, degToRads, r) : a,
              ry: l.ry ? o(e, l.ry, 0, degToRads, r) : a,
              sk: l.sk ? o(e, l.sk, 0, degToRads, r) : a,
              sa: l.sa ? o(e, l.sa, 0, degToRads, r) : a,
              s: l.s ? o(e, l.s, 1, .01, r) : a,
              a: l.a ? o(e, l.a, 1, 0, r) : a,
              o: l.o ? o(e, l.o, 0, .01, r) : a,
              p: l.p ? o(e, l.p, 1, 0, r) : a,
              sw: l.sw ? o(e, l.sw, 0, 0, r) : a,
              sc: l.sc ? o(e, l.sc, 1, 0, r) : a,
              fc: l.fc ? o(e, l.fc, 1, 0, r) : a,
              fh: l.fh ? o(e, l.fh, 0, 0, r) : a,
              fs: l.fs ? o(e, l.fs, 0, .01, r) : a,
              fb: l.fb ? o(e, l.fb, 0, .01, r) : a,
              t: l.t ? o(e, l.t, 0, 0, r) : a
          },
          this.s = TextSelectorProp.getTextSelectorProp(e, t.s, r),
          this.s.t = t.s.t
      }
      function TextAnimatorProperty(e, t, r) {
          this._isFirstFrame = !0,
          this._hasMaskedPath = !1,
          this._frameId = -1,
          this._textData = e,
          this._renderType = t,
          this._elem = r,
          this._animatorsData = createSizedArray(this._textData.a.length),
          this._pathData = {},
          this._moreOptions = {
              alignment: {}
          },
          this.renderedLetters = [],
          this.lettersChangedFlag = !1,
          this.initDynamicPropertyContainer(r)
      }
      TextAnimatorProperty.prototype.searchProperties = function() {
          var e, t = this._textData.a.length, r, a = PropertyFactory.getProp;
          for (e = 0; e < t; e += 1)
              r = this._textData.a[e],
              this._animatorsData[e] = new TextAnimatorDataProperty(this._elem,r,this);
          this._textData.p && "m"in this._textData.p ? (this._pathData = {
              a: a(this._elem, this._textData.p.a, 0, 0, this),
              f: a(this._elem, this._textData.p.f, 0, 0, this),
              l: a(this._elem, this._textData.p.l, 0, 0, this),
              r: a(this._elem, this._textData.p.r, 0, 0, this),
              p: a(this._elem, this._textData.p.p, 0, 0, this),
              m: this._elem.maskManager.getMaskProperty(this._textData.p.m)
          },
          this._hasMaskedPath = !0) : this._hasMaskedPath = !1,
          this._moreOptions.alignment = a(this._elem, this._textData.m.a, 1, 0, this)
      }
      ,
      TextAnimatorProperty.prototype.getMeasures = function(e, t) {
          if (this.lettersChangedFlag = t,
          !(!this._mdf && !this._isFirstFrame && !t && (!this._hasMaskedPath || !this._pathData.m._mdf))) {
              this._isFirstFrame = !1;
              var r = this._moreOptions.alignment.v, a = this._animatorsData, o = this._textData, l = this.mHelper, f = this._renderType, d = this.renderedLetters.length, g, _, v, S, b = e.l, P, x, E, I, C, A, T, w, M, F, O, $, j, K, Y;
              if (this._hasMaskedPath) {
                  if (Y = this._pathData.m,
                  !this._pathData.n || this._pathData._mdf) {
                      var W = Y.v;
                      this._pathData.r.v && (W = W.reverse()),
                      P = {
                          tLength: 0,
                          segments: []
                      },
                      S = W._length - 1;
                      var Z;
                      for ($ = 0,
                      v = 0; v < S; v += 1)
                          Z = bez.buildBezierData(W.v[v], W.v[v + 1], [W.o[v][0] - W.v[v][0], W.o[v][1] - W.v[v][1]], [W.i[v + 1][0] - W.v[v + 1][0], W.i[v + 1][1] - W.v[v + 1][1]]),
                          P.tLength += Z.segmentLength,
                          P.segments.push(Z),
                          $ += Z.segmentLength;
                      v = S,
                      Y.v.c && (Z = bez.buildBezierData(W.v[v], W.v[0], [W.o[v][0] - W.v[v][0], W.o[v][1] - W.v[v][1]], [W.i[0][0] - W.v[0][0], W.i[0][1] - W.v[0][1]]),
                      P.tLength += Z.segmentLength,
                      P.segments.push(Z),
                      $ += Z.segmentLength),
                      this._pathData.pi = P
                  }
                  if (P = this._pathData.pi,
                  x = this._pathData.f.v,
                  T = 0,
                  A = 1,
                  I = 0,
                  C = !0,
                  F = P.segments,
                  x < 0 && Y.v.c)
                      for (P.tLength < Math.abs(x) && (x = -Math.abs(x) % P.tLength),
                      T = F.length - 1,
                      M = F[T].points,
                      A = M.length - 1; x < 0; )
                          x += M[A].partialLength,
                          A -= 1,
                          A < 0 && (T -= 1,
                          M = F[T].points,
                          A = M.length - 1);
                  M = F[T].points,
                  w = M[A - 1],
                  E = M[A],
                  O = E.partialLength
              }
              S = b.length,
              g = 0,
              _ = 0;
              var ee = e.finalSize * 1.2 * .714, X = !0, D, B, R, L, V;
              L = a.length;
              var q, oe = -1, ye, pe, Pe, me = x, Q = T, le = A, fe = -1, ue, be, ge, H, z, J, te, U, ne = "", ie = this.defaultPropsArray, se;
              if (e.j === 2 || e.j === 1) {
                  var ae = 0
                    , re = 0
                    , ce = e.j === 2 ? -.5 : -1
                    , ve = 0
                    , _e = !0;
                  for (v = 0; v < S; v += 1)
                      if (b[v].n) {
                          for (ae && (ae += re); ve < v; )
                              b[ve].animatorJustifyOffset = ae,
                              ve += 1;
                          ae = 0,
                          _e = !0
                      } else {
                          for (R = 0; R < L; R += 1)
                              D = a[R].a,
                              D.t.propType && (_e && e.j === 2 && (re += D.t.v * ce),
                              B = a[R].s,
                              q = B.getMult(b[v].anIndexes[R], o.a[R].s.totalChars),
                              q.length ? ae += D.t.v * q[0] * ce : ae += D.t.v * q * ce);
                          _e = !1
                      }
                  for (ae && (ae += re); ve < v; )
                      b[ve].animatorJustifyOffset = ae,
                      ve += 1
              }
              for (v = 0; v < S; v += 1) {
                  if (l.reset(),
                  ue = 1,
                  b[v].n)
                      g = 0,
                      _ += e.yOffset,
                      _ += X ? 1 : 0,
                      x = me,
                      X = !1,
                      this._hasMaskedPath && (T = Q,
                      A = le,
                      M = F[T].points,
                      w = M[A - 1],
                      E = M[A],
                      O = E.partialLength,
                      I = 0),
                      ne = "",
                      U = "",
                      J = "",
                      se = "",
                      ie = this.defaultPropsArray;
                  else {
                      if (this._hasMaskedPath) {
                          if (fe !== b[v].line) {
                              switch (e.j) {
                              case 1:
                                  x += $ - e.lineWidths[b[v].line];
                                  break;
                              case 2:
                                  x += ($ - e.lineWidths[b[v].line]) / 2;
                                  break
                              }
                              fe = b[v].line
                          }
                          oe !== b[v].ind && (b[oe] && (x += b[oe].extra),
                          x += b[v].an / 2,
                          oe = b[v].ind),
                          x += r[0] * b[v].an * .005;
                          var de = 0;
                          for (R = 0; R < L; R += 1)
                              D = a[R].a,
                              D.p.propType && (B = a[R].s,
                              q = B.getMult(b[v].anIndexes[R], o.a[R].s.totalChars),
                              q.length ? de += D.p.v[0] * q[0] : de += D.p.v[0] * q),
                              D.a.propType && (B = a[R].s,
                              q = B.getMult(b[v].anIndexes[R], o.a[R].s.totalChars),
                              q.length ? de += D.a.v[0] * q[0] : de += D.a.v[0] * q);
                          for (C = !0,
                          this._pathData.a.v && (x = b[0].an * .5 + ($ - this._pathData.f.v - b[0].an * .5 - b[b.length - 1].an * .5) * oe / (S - 1),
                          x += this._pathData.f.v); C; )
                              I + O >= x + de || !M ? (j = (x + de - I) / E.partialLength,
                              pe = w.point[0] + (E.point[0] - w.point[0]) * j,
                              Pe = w.point[1] + (E.point[1] - w.point[1]) * j,
                              l.translate(-r[0] * b[v].an * .005, -(r[1] * ee) * .01),
                              C = !1) : M && (I += E.partialLength,
                              A += 1,
                              A >= M.length && (A = 0,
                              T += 1,
                              F[T] ? M = F[T].points : Y.v.c ? (A = 0,
                              T = 0,
                              M = F[T].points) : (I -= E.partialLength,
                              M = null)),
                              M && (w = E,
                              E = M[A],
                              O = E.partialLength));
                          ye = b[v].an / 2 - b[v].add,
                          l.translate(-ye, 0, 0)
                      } else
                          ye = b[v].an / 2 - b[v].add,
                          l.translate(-ye, 0, 0),
                          l.translate(-r[0] * b[v].an * .005, -r[1] * ee * .01, 0);
                      for (R = 0; R < L; R += 1)
                          D = a[R].a,
                          D.t.propType && (B = a[R].s,
                          q = B.getMult(b[v].anIndexes[R], o.a[R].s.totalChars),
                          (g !== 0 || e.j !== 0) && (this._hasMaskedPath ? q.length ? x += D.t.v * q[0] : x += D.t.v * q : q.length ? g += D.t.v * q[0] : g += D.t.v * q));
                      for (e.strokeWidthAnim && (ge = e.sw || 0),
                      e.strokeColorAnim && (e.sc ? be = [e.sc[0], e.sc[1], e.sc[2]] : be = [0, 0, 0]),
                      e.fillColorAnim && e.fc && (H = [e.fc[0], e.fc[1], e.fc[2]]),
                      R = 0; R < L; R += 1)
                          D = a[R].a,
                          D.a.propType && (B = a[R].s,
                          q = B.getMult(b[v].anIndexes[R], o.a[R].s.totalChars),
                          q.length ? l.translate(-D.a.v[0] * q[0], -D.a.v[1] * q[1], D.a.v[2] * q[2]) : l.translate(-D.a.v[0] * q, -D.a.v[1] * q, D.a.v[2] * q));
                      for (R = 0; R < L; R += 1)
                          D = a[R].a,
                          D.s.propType && (B = a[R].s,
                          q = B.getMult(b[v].anIndexes[R], o.a[R].s.totalChars),
                          q.length ? l.scale(1 + (D.s.v[0] - 1) * q[0], 1 + (D.s.v[1] - 1) * q[1], 1) : l.scale(1 + (D.s.v[0] - 1) * q, 1 + (D.s.v[1] - 1) * q, 1));
                      for (R = 0; R < L; R += 1) {
                          if (D = a[R].a,
                          B = a[R].s,
                          q = B.getMult(b[v].anIndexes[R], o.a[R].s.totalChars),
                          D.sk.propType && (q.length ? l.skewFromAxis(-D.sk.v * q[0], D.sa.v * q[1]) : l.skewFromAxis(-D.sk.v * q, D.sa.v * q)),
                          D.r.propType && (q.length ? l.rotateZ(-D.r.v * q[2]) : l.rotateZ(-D.r.v * q)),
                          D.ry.propType && (q.length ? l.rotateY(D.ry.v * q[1]) : l.rotateY(D.ry.v * q)),
                          D.rx.propType && (q.length ? l.rotateX(D.rx.v * q[0]) : l.rotateX(D.rx.v * q)),
                          D.o.propType && (q.length ? ue += (D.o.v * q[0] - ue) * q[0] : ue += (D.o.v * q - ue) * q),
                          e.strokeWidthAnim && D.sw.propType && (q.length ? ge += D.sw.v * q[0] : ge += D.sw.v * q),
                          e.strokeColorAnim && D.sc.propType)
                              for (z = 0; z < 3; z += 1)
                                  q.length ? be[z] += (D.sc.v[z] - be[z]) * q[0] : be[z] += (D.sc.v[z] - be[z]) * q;
                          if (e.fillColorAnim && e.fc) {
                              if (D.fc.propType)
                                  for (z = 0; z < 3; z += 1)
                                      q.length ? H[z] += (D.fc.v[z] - H[z]) * q[0] : H[z] += (D.fc.v[z] - H[z]) * q;
                              D.fh.propType && (q.length ? H = addHueToRGB(H, D.fh.v * q[0]) : H = addHueToRGB(H, D.fh.v * q)),
                              D.fs.propType && (q.length ? H = addSaturationToRGB(H, D.fs.v * q[0]) : H = addSaturationToRGB(H, D.fs.v * q)),
                              D.fb.propType && (q.length ? H = addBrightnessToRGB(H, D.fb.v * q[0]) : H = addBrightnessToRGB(H, D.fb.v * q))
                          }
                      }
                      for (R = 0; R < L; R += 1)
                          D = a[R].a,
                          D.p.propType && (B = a[R].s,
                          q = B.getMult(b[v].anIndexes[R], o.a[R].s.totalChars),
                          this._hasMaskedPath ? q.length ? l.translate(0, D.p.v[1] * q[0], -D.p.v[2] * q[1]) : l.translate(0, D.p.v[1] * q, -D.p.v[2] * q) : q.length ? l.translate(D.p.v[0] * q[0], D.p.v[1] * q[1], -D.p.v[2] * q[2]) : l.translate(D.p.v[0] * q, D.p.v[1] * q, -D.p.v[2] * q));
                      if (e.strokeWidthAnim && (J = ge < 0 ? 0 : ge),
                      e.strokeColorAnim && (te = "rgb(" + Math.round(be[0] * 255) + "," + Math.round(be[1] * 255) + "," + Math.round(be[2] * 255) + ")"),
                      e.fillColorAnim && e.fc && (U = "rgb(" + Math.round(H[0] * 255) + "," + Math.round(H[1] * 255) + "," + Math.round(H[2] * 255) + ")"),
                      this._hasMaskedPath) {
                          if (l.translate(0, -e.ls),
                          l.translate(0, r[1] * ee * .01 + _, 0),
                          this._pathData.p.v) {
                              K = (E.point[1] - w.point[1]) / (E.point[0] - w.point[0]);
                              var Se = Math.atan(K) * 180 / Math.PI;
                              E.point[0] < w.point[0] && (Se += 180),
                              l.rotate(-Se * Math.PI / 180)
                          }
                          l.translate(pe, Pe, 0),
                          x -= r[0] * b[v].an * .005,
                          b[v + 1] && oe !== b[v + 1].ind && (x += b[v].an / 2,
                          x += e.tr * .001 * e.finalSize)
                      } else {
                          switch (l.translate(g, _, 0),
                          e.ps && l.translate(e.ps[0], e.ps[1] + e.ascent, 0),
                          e.j) {
                          case 1:
                              l.translate(b[v].animatorJustifyOffset + e.justifyOffset + (e.boxWidth - e.lineWidths[b[v].line]), 0, 0);
                              break;
                          case 2:
                              l.translate(b[v].animatorJustifyOffset + e.justifyOffset + (e.boxWidth - e.lineWidths[b[v].line]) / 2, 0, 0);
                              break
                          }
                          l.translate(0, -e.ls),
                          l.translate(ye, 0, 0),
                          l.translate(r[0] * b[v].an * .005, r[1] * ee * .01, 0),
                          g += b[v].l + e.tr * .001 * e.finalSize
                      }
                      f === "html" ? ne = l.toCSS() : f === "svg" ? ne = l.to2dCSS() : ie = [l.props[0], l.props[1], l.props[2], l.props[3], l.props[4], l.props[5], l.props[6], l.props[7], l.props[8], l.props[9], l.props[10], l.props[11], l.props[12], l.props[13], l.props[14], l.props[15]],
                      se = ue
                  }
                  d <= v ? (V = new LetterProps(se,J,te,U,ne,ie),
                  this.renderedLetters.push(V),
                  d += 1,
                  this.lettersChangedFlag = !0) : (V = this.renderedLetters[v],
                  this.lettersChangedFlag = V.update(se, J, te, U, ne, ie) || this.lettersChangedFlag)
              }
          }
      }
      ,
      TextAnimatorProperty.prototype.getValue = function() {
          this._elem.globalData.frameId !== this._frameId && (this._frameId = this._elem.globalData.frameId,
          this.iterateDynamicProperties())
      }
      ,
      TextAnimatorProperty.prototype.mHelper = new Matrix,
      TextAnimatorProperty.prototype.defaultPropsArray = [],
      extendPrototype([DynamicPropertyContainer], TextAnimatorProperty);
      function ITextElement() {}
      ITextElement.prototype.initElement = function(e, t, r) {
          this.lettersChangedFlag = !0,
          this.initFrame(),
          this.initBaseData(e, t, r),
          this.textProperty = new TextProperty(this,e.t,this.dynamicProperties),
          this.textAnimator = new TextAnimatorProperty(e.t,this.renderType,this),
          this.initTransform(e, t, r),
          this.initHierarchy(),
          this.initRenderable(),
          this.initRendererElement(),
          this.createContainerElements(),
          this.createRenderableComponents(),
          this.createContent(),
          this.hide(),
          this.textAnimator.searchProperties(this.dynamicProperties)
      }
      ,
      ITextElement.prototype.prepareFrame = function(e) {
          this._mdf = !1,
          this.prepareRenderableFrame(e),
          this.prepareProperties(e, this.isInRange)
      }
      ,
      ITextElement.prototype.createPathShape = function(e, t) {
          var r, a = t.length, o, l = "";
          for (r = 0; r < a; r += 1)
              t[r].ty === "sh" && (o = t[r].ks.k,
              l += buildShapeString(o, o.i.length, !0, e));
          return l
      }
      ,
      ITextElement.prototype.updateDocumentData = function(e, t) {
          this.textProperty.updateDocumentData(e, t)
      }
      ,
      ITextElement.prototype.canResizeFont = function(e) {
          this.textProperty.canResizeFont(e)
      }
      ,
      ITextElement.prototype.setMinimumFontSize = function(e) {
          this.textProperty.setMinimumFontSize(e)
      }
      ,
      ITextElement.prototype.applyTextPropertiesToMatrix = function(e, t, r, a, o) {
          switch (e.ps && t.translate(e.ps[0], e.ps[1] + e.ascent, 0),
          t.translate(0, -e.ls, 0),
          e.j) {
          case 1:
              t.translate(e.justifyOffset + (e.boxWidth - e.lineWidths[r]), 0, 0);
              break;
          case 2:
              t.translate(e.justifyOffset + (e.boxWidth - e.lineWidths[r]) / 2, 0, 0);
              break
          }
          t.translate(a, o, 0)
      }
      ,
      ITextElement.prototype.buildColor = function(e) {
          return "rgb(" + Math.round(e[0] * 255) + "," + Math.round(e[1] * 255) + "," + Math.round(e[2] * 255) + ")"
      }
      ,
      ITextElement.prototype.emptyProp = new LetterProps,
      ITextElement.prototype.destroy = function() {}
      ,
      ITextElement.prototype.validateText = function() {
          (this.textProperty._mdf || this.textProperty._isFirstFrame) && (this.buildNewText(),
          this.textProperty._isFirstFrame = !1,
          this.textProperty._mdf = !1)
      }
      ;
      var emptyShapeData = {
          shapes: []
      };
      function SVGTextLottieElement(e, t, r) {
          this.textSpans = [],
          this.renderType = "svg",
          this.initElement(e, t, r)
      }
      extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], SVGTextLottieElement),
      SVGTextLottieElement.prototype.createContent = function() {
          this.data.singleShape && !this.globalData.fontManager.chars && (this.textContainer = createNS("text"))
      }
      ,
      SVGTextLottieElement.prototype.buildTextContents = function(e) {
          for (var t = 0, r = e.length, a = [], o = ""; t < r; )
              e[t] === "\r" || e[t] === "" ? (a.push(o),
              o = "") : o += e[t],
              t += 1;
          return a.push(o),
          a
      }
      ,
      SVGTextLottieElement.prototype.buildShapeData = function(e, t) {
          if (e.shapes && e.shapes.length) {
              var r = e.shapes[0];
              if (r.it) {
                  var a = r.it[r.it.length - 1];
                  a.s && (a.s.k[0] = t,
                  a.s.k[1] = t)
              }
          }
          return e
      }
      ,
      SVGTextLottieElement.prototype.buildNewText = function() {
          this.addDynamicProperty(this);
          var e, t, r = this.textProperty.currentData;
          this.renderedLetters = createSizedArray(r ? r.l.length : 0),
          r.fc ? this.layerElement.setAttribute("fill", this.buildColor(r.fc)) : this.layerElement.setAttribute("fill", "rgba(0,0,0,0)"),
          r.sc && (this.layerElement.setAttribute("stroke", this.buildColor(r.sc)),
          this.layerElement.setAttribute("stroke-width", r.sw)),
          this.layerElement.setAttribute("font-size", r.finalSize);
          var a = this.globalData.fontManager.getFontByName(r.f);
          if (a.fClass)
              this.layerElement.setAttribute("class", a.fClass);
          else {
              this.layerElement.setAttribute("font-family", a.fFamily);
              var o = r.fWeight
                , l = r.fStyle;
              this.layerElement.setAttribute("font-style", l),
              this.layerElement.setAttribute("font-weight", o)
          }
          this.layerElement.setAttribute("aria-label", r.t);
          var f = r.l || []
            , d = !!this.globalData.fontManager.chars;
          t = f.length;
          var g, _ = this.mHelper, v = "", S = this.data.singleShape, b = 0, P = 0, x = !0, E = r.tr * .001 * r.finalSize;
          if (S && !d && !r.sz) {
              var I = this.textContainer
                , C = "start";
              switch (r.j) {
              case 1:
                  C = "end";
                  break;
              case 2:
                  C = "middle";
                  break;
              default:
                  C = "start";
                  break
              }
              I.setAttribute("text-anchor", C),
              I.setAttribute("letter-spacing", E);
              var A = this.buildTextContents(r.finalText);
              for (t = A.length,
              P = r.ps ? r.ps[1] + r.ascent : 0,
              e = 0; e < t; e += 1)
                  g = this.textSpans[e].span || createNS("tspan"),
                  g.textContent = A[e],
                  g.setAttribute("x", 0),
                  g.setAttribute("y", P),
                  g.style.display = "inherit",
                  I.appendChild(g),
                  this.textSpans[e] || (this.textSpans[e] = {
                      span: null,
                      glyph: null
                  }),
                  this.textSpans[e].span = g,
                  P += r.finalLineHeight;
              this.layerElement.appendChild(I)
          } else {
              var T = this.textSpans.length, w;
              for (e = 0; e < t; e += 1) {
                  if (this.textSpans[e] || (this.textSpans[e] = {
                      span: null,
                      childSpan: null,
                      glyph: null
                  }),
                  !d || !S || e === 0) {
                      if (g = T > e ? this.textSpans[e].span : createNS(d ? "g" : "text"),
                      T <= e) {
                          if (g.setAttribute("stroke-linecap", "butt"),
                          g.setAttribute("stroke-linejoin", "round"),
                          g.setAttribute("stroke-miterlimit", "4"),
                          this.textSpans[e].span = g,
                          d) {
                              var M = createNS("g");
                              g.appendChild(M),
                              this.textSpans[e].childSpan = M
                          }
                          this.textSpans[e].span = g,
                          this.layerElement.appendChild(g)
                      }
                      g.style.display = "inherit"
                  }
                  if (_.reset(),
                  S && (f[e].n && (b = -E,
                  P += r.yOffset,
                  P += x ? 1 : 0,
                  x = !1),
                  this.applyTextPropertiesToMatrix(r, _, f[e].line, b, P),
                  b += f[e].l || 0,
                  b += E),
                  d) {
                      w = this.globalData.fontManager.getCharData(r.finalText[e], a.fStyle, this.globalData.fontManager.getFontByName(r.f).fFamily);
                      var F;
                      if (w.t === 1)
                          F = new SVGCompElement(w.data,this.globalData,this);
                      else {
                          var O = emptyShapeData;
                          w.data && w.data.shapes && (O = this.buildShapeData(w.data, r.finalSize)),
                          F = new SVGShapeElement(O,this.globalData,this)
                      }
                      if (this.textSpans[e].glyph) {
                          var $ = this.textSpans[e].glyph;
                          this.textSpans[e].childSpan.removeChild($.layerElement),
                          $.destroy()
                      }
                      this.textSpans[e].glyph = F,
                      F._debug = !0,
                      F.prepareFrame(0),
                      F.renderFrame(),
                      this.textSpans[e].childSpan.appendChild(F.layerElement),
                      w.t === 1 && this.textSpans[e].childSpan.setAttribute("transform", "scale(" + r.finalSize / 100 + "," + r.finalSize / 100 + ")")
                  } else
                      S && g.setAttribute("transform", "translate(" + _.props[12] + "," + _.props[13] + ")"),
                      g.textContent = f[e].val,
                      g.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve")
              }
              S && g && g.setAttribute("d", v)
          }
          for (; e < this.textSpans.length; )
              this.textSpans[e].span.style.display = "none",
              e += 1;
          this._sizeChanged = !0
      }
      ,
      SVGTextLottieElement.prototype.sourceRectAtTime = function() {
          if (this.prepareFrame(this.comp.renderedFrame - this.data.st),
          this.renderInnerContent(),
          this._sizeChanged) {
              this._sizeChanged = !1;
              var e = this.layerElement.getBBox();
              this.bbox = {
                  top: e.y,
                  left: e.x,
                  width: e.width,
                  height: e.height
              }
          }
          return this.bbox
      }
      ,
      SVGTextLottieElement.prototype.getValue = function() {
          var e, t = this.textSpans.length, r;
          for (this.renderedFrame = this.comp.renderedFrame,
          e = 0; e < t; e += 1)
              r = this.textSpans[e].glyph,
              r && (r.prepareFrame(this.comp.renderedFrame - this.data.st),
              r._mdf && (this._mdf = !0))
      }
      ,
      SVGTextLottieElement.prototype.renderInnerContent = function() {
          if (this.validateText(),
          (!this.data.singleShape || this._mdf) && (this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag),
          this.lettersChangedFlag || this.textAnimator.lettersChangedFlag)) {
              this._sizeChanged = !0;
              var e, t, r = this.textAnimator.renderedLetters, a = this.textProperty.currentData.l;
              t = a.length;
              var o, l, f;
              for (e = 0; e < t; e += 1)
                  a[e].n || (o = r[e],
                  l = this.textSpans[e].span,
                  f = this.textSpans[e].glyph,
                  f && f.renderFrame(),
                  o._mdf.m && l.setAttribute("transform", o.m),
                  o._mdf.o && l.setAttribute("opacity", o.o),
                  o._mdf.sw && l.setAttribute("stroke-width", o.sw),
                  o._mdf.sc && l.setAttribute("stroke", o.sc),
                  o._mdf.fc && l.setAttribute("fill", o.fc))
          }
      }
      ;
      function ISolidElement(e, t, r) {
          this.initElement(e, t, r)
      }
      extendPrototype([IImageElement], ISolidElement),
      ISolidElement.prototype.createContent = function() {
          var e = createNS("rect");
          e.setAttribute("width", this.data.sw),
          e.setAttribute("height", this.data.sh),
          e.setAttribute("fill", this.data.sc),
          this.layerElement.appendChild(e)
      }
      ;
      function NullElement(e, t, r) {
          this.initFrame(),
          this.initBaseData(e, t, r),
          this.initFrame(),
          this.initTransform(e, t, r),
          this.initHierarchy()
      }
      NullElement.prototype.prepareFrame = function(e) {
          this.prepareProperties(e, !0)
      }
      ,
      NullElement.prototype.renderFrame = function() {}
      ,
      NullElement.prototype.getBaseElement = function() {
          return null
      }
      ,
      NullElement.prototype.destroy = function() {}
      ,
      NullElement.prototype.sourceRectAtTime = function() {}
      ,
      NullElement.prototype.hide = function() {}
      ,
      extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement], NullElement);
      function SVGRendererBase() {}
      extendPrototype([BaseRenderer], SVGRendererBase),
      SVGRendererBase.prototype.createNull = function(e) {
          return new NullElement(e,this.globalData,this)
      }
      ,
      SVGRendererBase.prototype.createShape = function(e) {
          return new SVGShapeElement(e,this.globalData,this)
      }
      ,
      SVGRendererBase.prototype.createText = function(e) {
          return new SVGTextLottieElement(e,this.globalData,this)
      }
      ,
      SVGRendererBase.prototype.createImage = function(e) {
          return new IImageElement(e,this.globalData,this)
      }
      ,
      SVGRendererBase.prototype.createSolid = function(e) {
          return new ISolidElement(e,this.globalData,this)
      }
      ,
      SVGRendererBase.prototype.configAnimation = function(e) {
          this.svgElement.setAttribute("xmlns", "http://www.w3.org/2000/svg"),
          this.svgElement.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink"),
          this.renderConfig.viewBoxSize ? this.svgElement.setAttribute("viewBox", this.renderConfig.viewBoxSize) : this.svgElement.setAttribute("viewBox", "0 0 " + e.w + " " + e.h),
          this.renderConfig.viewBoxOnly || (this.svgElement.setAttribute("width", e.w),
          this.svgElement.setAttribute("height", e.h),
          this.svgElement.style.width = "100%",
          this.svgElement.style.height = "100%",
          this.svgElement.style.transform = "translate3d(0,0,0)",
          this.svgElement.style.contentVisibility = this.renderConfig.contentVisibility),
          this.renderConfig.width && this.svgElement.setAttribute("width", this.renderConfig.width),
          this.renderConfig.height && this.svgElement.setAttribute("height", this.renderConfig.height),
          this.renderConfig.className && this.svgElement.setAttribute("class", this.renderConfig.className),
          this.renderConfig.id && this.svgElement.setAttribute("id", this.renderConfig.id),
          this.renderConfig.focusable !== void 0 && this.svgElement.setAttribute("focusable", this.renderConfig.focusable),
          this.svgElement.setAttribute("preserveAspectRatio", this.renderConfig.preserveAspectRatio),
          this.animationItem.wrapper.appendChild(this.svgElement);
          var t = this.globalData.defs;
          this.setupGlobalData(e, t),
          this.globalData.progressiveLoad = this.renderConfig.progressiveLoad,
          this.data = e;
          var r = createNS("clipPath")
            , a = createNS("rect");
          a.setAttribute("width", e.w),
          a.setAttribute("height", e.h),
          a.setAttribute("x", 0),
          a.setAttribute("y", 0);
          var o = createElementID();
          r.setAttribute("id", o),
          r.appendChild(a),
          this.layerElement.setAttribute("clip-path", "url(" + getLocationHref() + "#" + o + ")"),
          t.appendChild(r),
          this.layers = e.layers,
          this.elements = createSizedArray(e.layers.length)
      }
      ,
      SVGRendererBase.prototype.destroy = function() {
          this.animationItem.wrapper && (this.animationItem.wrapper.innerText = ""),
          this.layerElement = null,
          this.globalData.defs = null;
          var e, t = this.layers ? this.layers.length : 0;
          for (e = 0; e < t; e += 1)
              this.elements[e] && this.elements[e].destroy && this.elements[e].destroy();
          this.elements.length = 0,
          this.destroyed = !0,
          this.animationItem = null
      }
      ,
      SVGRendererBase.prototype.updateContainerSize = function() {}
      ,
      SVGRendererBase.prototype.findIndexByInd = function(e) {
          var t = 0
            , r = this.layers.length;
          for (t = 0; t < r; t += 1)
              if (this.layers[t].ind === e)
                  return t;
          return -1
      }
      ,
      SVGRendererBase.prototype.buildItem = function(e) {
          var t = this.elements;
          if (!(t[e] || this.layers[e].ty === 99)) {
              t[e] = !0;
              var r = this.createItem(this.layers[e]);
              if (t[e] = r,
              getExpressionsPlugin() && (this.layers[e].ty === 0 && this.globalData.projectInterface.registerComposition(r),
              r.initExpressions()),
              this.appendElementInPos(r, e),
              this.layers[e].tt) {
                  var a = "tp"in this.layers[e] ? this.findIndexByInd(this.layers[e].tp) : e - 1;
                  if (a === -1)
                      return;
                  if (!this.elements[a] || this.elements[a] === !0)
                      this.buildItem(a),
                      this.addPendingElement(r);
                  else {
                      var o = t[a]
                        , l = o.getMatte(this.layers[e].tt);
                      r.setMatte(l)
                  }
              }
          }
      }
      ,
      SVGRendererBase.prototype.checkPendingElements = function() {
          for (; this.pendingElements.length; ) {
              var e = this.pendingElements.pop();
              if (e.checkParenting(),
              e.data.tt)
                  for (var t = 0, r = this.elements.length; t < r; ) {
                      if (this.elements[t] === e) {
                          var a = "tp"in e.data ? this.findIndexByInd(e.data.tp) : t - 1
                            , o = this.elements[a]
                            , l = o.getMatte(this.layers[t].tt);
                          e.setMatte(l);
                          break
                      }
                      t += 1
                  }
          }
      }
      ,
      SVGRendererBase.prototype.renderFrame = function(e) {
          if (!(this.renderedFrame === e || this.destroyed)) {
              e === null ? e = this.renderedFrame : this.renderedFrame = e,
              this.globalData.frameNum = e,
              this.globalData.frameId += 1,
              this.globalData.projectInterface.currentFrame = e,
              this.globalData._mdf = !1;
              var t, r = this.layers.length;
              for (this.completeLayers || this.checkLayers(e),
              t = r - 1; t >= 0; t -= 1)
                  (this.completeLayers || this.elements[t]) && this.elements[t].prepareFrame(e - this.layers[t].st);
              if (this.globalData._mdf)
                  for (t = 0; t < r; t += 1)
                      (this.completeLayers || this.elements[t]) && this.elements[t].renderFrame()
          }
      }
      ,
      SVGRendererBase.prototype.appendElementInPos = function(e, t) {
          var r = e.getBaseElement();
          if (r) {
              for (var a = 0, o; a < t; )
                  this.elements[a] && this.elements[a] !== !0 && this.elements[a].getBaseElement() && (o = this.elements[a].getBaseElement()),
                  a += 1;
              o ? this.layerElement.insertBefore(r, o) : this.layerElement.appendChild(r)
          }
      }
      ,
      SVGRendererBase.prototype.hide = function() {
          this.layerElement.style.display = "none"
      }
      ,
      SVGRendererBase.prototype.show = function() {
          this.layerElement.style.display = "block"
      }
      ;
      function ICompElement() {}
      extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement, RenderableDOMElement], ICompElement),
      ICompElement.prototype.initElement = function(e, t, r) {
          this.initFrame(),
          this.initBaseData(e, t, r),
          this.initTransform(e, t, r),
          this.initRenderable(),
          this.initHierarchy(),
          this.initRendererElement(),
          this.createContainerElements(),
          this.createRenderableComponents(),
          (this.data.xt || !t.progressiveLoad) && this.buildAllItems(),
          this.hide()
      }
      ,
      ICompElement.prototype.prepareFrame = function(e) {
          if (this._mdf = !1,
          this.prepareRenderableFrame(e),
          this.prepareProperties(e, this.isInRange),
          !(!this.isInRange && !this.data.xt)) {
              if (this.tm._placeholder)
                  this.renderedFrame = e / this.data.sr;
              else {
                  var t = this.tm.v;
                  t === this.data.op && (t = this.data.op - 1),
                  this.renderedFrame = t
              }
              var r, a = this.elements.length;
              for (this.completeLayers || this.checkLayers(this.renderedFrame),
              r = a - 1; r >= 0; r -= 1)
                  (this.completeLayers || this.elements[r]) && (this.elements[r].prepareFrame(this.renderedFrame - this.layers[r].st),
                  this.elements[r]._mdf && (this._mdf = !0))
          }
      }
      ,
      ICompElement.prototype.renderInnerContent = function() {
          var e, t = this.layers.length;
          for (e = 0; e < t; e += 1)
              (this.completeLayers || this.elements[e]) && this.elements[e].renderFrame()
      }
      ,
      ICompElement.prototype.setElements = function(e) {
          this.elements = e
      }
      ,
      ICompElement.prototype.getElements = function() {
          return this.elements
      }
      ,
      ICompElement.prototype.destroyElements = function() {
          var e, t = this.layers.length;
          for (e = 0; e < t; e += 1)
              this.elements[e] && this.elements[e].destroy()
      }
      ,
      ICompElement.prototype.destroy = function() {
          this.destroyElements(),
          this.destroyBaseElement()
      }
      ;
      function SVGCompElement(e, t, r) {
          this.layers = e.layers,
          this.supports3d = !0,
          this.completeLayers = !1,
          this.pendingElements = [],
          this.elements = this.layers ? createSizedArray(this.layers.length) : [],
          this.initElement(e, t, r),
          this.tm = e.tm ? PropertyFactory.getProp(this, e.tm, 0, t.frameRate, this) : {
              _placeholder: !0
          }
      }
      extendPrototype([SVGRendererBase, ICompElement, SVGBaseElement], SVGCompElement),
      SVGCompElement.prototype.createComp = function(e) {
          return new SVGCompElement(e,this.globalData,this)
      }
      ;
      function SVGRenderer(e, t) {
          this.animationItem = e,
          this.layers = null,
          this.renderedFrame = -1,
          this.svgElement = createNS("svg");
          var r = "";
          if (t && t.title) {
              var a = createNS("title")
                , o = createElementID();
              a.setAttribute("id", o),
              a.textContent = t.title,
              this.svgElement.appendChild(a),
              r += o
          }
          if (t && t.description) {
              var l = createNS("desc")
                , f = createElementID();
              l.setAttribute("id", f),
              l.textContent = t.description,
              this.svgElement.appendChild(l),
              r += " " + f
          }
          r && this.svgElement.setAttribute("aria-labelledby", r);
          var d = createNS("defs");
          this.svgElement.appendChild(d);
          var g = createNS("g");
          this.svgElement.appendChild(g),
          this.layerElement = g,
          this.renderConfig = {
              preserveAspectRatio: t && t.preserveAspectRatio || "xMidYMid meet",
              imagePreserveAspectRatio: t && t.imagePreserveAspectRatio || "xMidYMid slice",
              contentVisibility: t && t.contentVisibility || "visible",
              progressiveLoad: t && t.progressiveLoad || !1,
              hideOnTransparent: !(t && t.hideOnTransparent === !1),
              viewBoxOnly: t && t.viewBoxOnly || !1,
              viewBoxSize: t && t.viewBoxSize || !1,
              className: t && t.className || "",
              id: t && t.id || "",
              focusable: t && t.focusable,
              filterSize: {
                  width: t && t.filterSize && t.filterSize.width || "100%",
                  height: t && t.filterSize && t.filterSize.height || "100%",
                  x: t && t.filterSize && t.filterSize.x || "0%",
                  y: t && t.filterSize && t.filterSize.y || "0%"
              },
              width: t && t.width,
              height: t && t.height,
              runExpressions: !t || t.runExpressions === void 0 || t.runExpressions
          },
          this.globalData = {
              _mdf: !1,
              frameNum: -1,
              defs: d,
              renderConfig: this.renderConfig
          },
          this.elements = [],
          this.pendingElements = [],
          this.destroyed = !1,
          this.rendererType = "svg"
      }
      extendPrototype([SVGRendererBase], SVGRenderer),
      SVGRenderer.prototype.createComp = function(e) {
          return new SVGCompElement(e,this.globalData,this)
      }
      ;
      function ShapeTransformManager() {
          this.sequences = {},
          this.sequenceList = [],
          this.transform_key_count = 0
      }
      ShapeTransformManager.prototype = {
          addTransformSequence: function(t) {
              var r, a = t.length, o = "_";
              for (r = 0; r < a; r += 1)
                  o += t[r].transform.key + "_";
              var l = this.sequences[o];
              return l || (l = {
                  transforms: [].concat(t),
                  finalTransform: new Matrix,
                  _mdf: !1
              },
              this.sequences[o] = l,
              this.sequenceList.push(l)),
              l
          },
          processSequence: function(t, r) {
              for (var a = 0, o = t.transforms.length, l = r; a < o && !r; ) {
                  if (t.transforms[a].transform.mProps._mdf) {
                      l = !0;
                      break
                  }
                  a += 1
              }
              if (l)
                  for (t.finalTransform.reset(),
                  a = o - 1; a >= 0; a -= 1)
                      t.finalTransform.multiply(t.transforms[a].transform.mProps.v);
              t._mdf = l
          },
          processSequences: function(t) {
              var r, a = this.sequenceList.length;
              for (r = 0; r < a; r += 1)
                  this.processSequence(this.sequenceList[r], t)
          },
          getNewKey: function() {
              return this.transform_key_count += 1,
              "_" + this.transform_key_count
          }
      };
      var lumaLoader = function() {
          var t = "__lottie_element_luma_buffer"
            , r = null
            , a = null
            , o = null;
          function l() {
              var g = createNS("svg")
                , _ = createNS("filter")
                , v = createNS("feColorMatrix");
              return _.setAttribute("id", t),
              v.setAttribute("type", "matrix"),
              v.setAttribute("color-interpolation-filters", "sRGB"),
              v.setAttribute("values", "0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0"),
              _.appendChild(v),
              g.appendChild(_),
              g.setAttribute("id", t + "_svg"),
              featureSupport.svgLumaHidden && (g.style.display = "none"),
              g
          }
          function f() {
              r || (o = l(),
              document.body.appendChild(o),
              r = createTag("canvas"),
              a = r.getContext("2d"),
              a.filter = "url(#" + t + ")",
              a.fillStyle = "rgba(0,0,0,0)",
              a.fillRect(0, 0, 1, 1))
          }
          function d(g) {
              return r || f(),
              r.width = g.width,
              r.height = g.height,
              a.filter = "url(#" + t + ")",
              r
          }
          return {
              load: f,
              get: d
          }
      };
      function createCanvas(e, t) {
          if (featureSupport.offscreenCanvas)
              return new OffscreenCanvas(e,t);
          var r = createTag("canvas");
          return r.width = e,
          r.height = t,
          r
      }
      var assetLoader = function() {
          return {
              loadLumaCanvas: lumaLoader.load,
              getLumaCanvas: lumaLoader.get,
              createCanvas
          }
      }()
        , registeredEffects = {};
      function CVEffects(e) {
          var t, r = e.data.ef ? e.data.ef.length : 0;
          this.filters = [];
          var a;
          for (t = 0; t < r; t += 1) {
              a = null;
              var o = e.data.ef[t].ty;
              if (registeredEffects[o]) {
                  var l = registeredEffects[o].effect;
                  a = new l(e.effectsManager.effectElements[t],e)
              }
              a && this.filters.push(a)
          }
          this.filters.length && e.addRenderableComponent(this)
      }
      CVEffects.prototype.renderFrame = function(e) {
          var t, r = this.filters.length;
          for (t = 0; t < r; t += 1)
              this.filters[t].renderFrame(e)
      }
      ,
      CVEffects.prototype.getEffects = function(e) {
          var t, r = this.filters.length, a = [];
          for (t = 0; t < r; t += 1)
              this.filters[t].type === e && a.push(this.filters[t]);
          return a
      }
      ;
      function registerEffect(e, t) {
          registeredEffects[e] = {
              effect: t
          }
      }
      function CVMaskElement(e, t) {
          this.data = e,
          this.element = t,
          this.masksProperties = this.data.masksProperties || [],
          this.viewData = createSizedArray(this.masksProperties.length);
          var r, a = this.masksProperties.length, o = !1;
          for (r = 0; r < a; r += 1)
              this.masksProperties[r].mode !== "n" && (o = !0),
              this.viewData[r] = ShapePropertyFactory.getShapeProp(this.element, this.masksProperties[r], 3);
          this.hasMasks = o,
          o && this.element.addRenderableComponent(this)
      }
      CVMaskElement.prototype.renderFrame = function() {
          if (this.hasMasks) {
              var e = this.element.finalTransform.mat, t = this.element.canvasContext, r, a = this.masksProperties.length, o, l, f;
              for (t.beginPath(),
              r = 0; r < a; r += 1)
                  if (this.masksProperties[r].mode !== "n") {
                      this.masksProperties[r].inv && (t.moveTo(0, 0),
                      t.lineTo(this.element.globalData.compSize.w, 0),
                      t.lineTo(this.element.globalData.compSize.w, this.element.globalData.compSize.h),
                      t.lineTo(0, this.element.globalData.compSize.h),
                      t.lineTo(0, 0)),
                      f = this.viewData[r].v,
                      o = e.applyToPointArray(f.v[0][0], f.v[0][1], 0),
                      t.moveTo(o[0], o[1]);
                      var d, g = f._length;
                      for (d = 1; d < g; d += 1)
                          l = e.applyToTriplePoints(f.o[d - 1], f.i[d], f.v[d]),
                          t.bezierCurveTo(l[0], l[1], l[2], l[3], l[4], l[5]);
                      l = e.applyToTriplePoints(f.o[d - 1], f.i[0], f.v[0]),
                      t.bezierCurveTo(l[0], l[1], l[2], l[3], l[4], l[5])
                  }
              this.element.globalData.renderer.save(!0),
              t.clip()
          }
      }
      ,
      CVMaskElement.prototype.getMaskProperty = MaskElement.prototype.getMaskProperty,
      CVMaskElement.prototype.destroy = function() {
          this.element = null
      }
      ;
      function CVBaseElement() {}
      var operationsMap = {
          1: "source-in",
          2: "source-out",
          3: "source-in",
          4: "source-out"
      };
      CVBaseElement.prototype = {
          createElements: function() {},
          initRendererElement: function() {},
          createContainerElements: function() {
              if (this.data.tt >= 1) {
                  this.buffers = [];
                  var t = this.globalData.canvasContext
                    , r = assetLoader.createCanvas(t.canvas.width, t.canvas.height);
                  this.buffers.push(r);
                  var a = assetLoader.createCanvas(t.canvas.width, t.canvas.height);
                  this.buffers.push(a),
                  this.data.tt >= 3 && !document._isProxy && assetLoader.loadLumaCanvas()
              }
              this.canvasContext = this.globalData.canvasContext,
              this.transformCanvas = this.globalData.transformCanvas,
              this.renderableEffectsManager = new CVEffects(this),
              this.searchEffectTransforms()
          },
          createContent: function() {},
          setBlendMode: function() {
              var t = this.globalData;
              if (t.blendMode !== this.data.bm) {
                  t.blendMode = this.data.bm;
                  var r = getBlendMode(this.data.bm);
                  t.canvasContext.globalCompositeOperation = r
              }
          },
          createRenderableComponents: function() {
              this.maskManager = new CVMaskElement(this.data,this),
              this.transformEffects = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT)
          },
          hideElement: function() {
              !this.hidden && (!this.isInRange || this.isTransparent) && (this.hidden = !0)
          },
          showElement: function() {
              this.isInRange && !this.isTransparent && (this.hidden = !1,
              this._isFirstFrame = !0,
              this.maskManager._isFirstFrame = !0)
          },
          clearCanvas: function(t) {
              t.clearRect(this.transformCanvas.tx, this.transformCanvas.ty, this.transformCanvas.w * this.transformCanvas.sx, this.transformCanvas.h * this.transformCanvas.sy)
          },
          prepareLayer: function() {
              if (this.data.tt >= 1) {
                  var t = this.buffers[0]
                    , r = t.getContext("2d");
                  this.clearCanvas(r),
                  r.drawImage(this.canvasContext.canvas, 0, 0),
                  this.currentTransform = this.canvasContext.getTransform(),
                  this.canvasContext.setTransform(1, 0, 0, 1, 0, 0),
                  this.clearCanvas(this.canvasContext),
                  this.canvasContext.setTransform(this.currentTransform)
              }
          },
          exitLayer: function() {
              if (this.data.tt >= 1) {
                  var t = this.buffers[1]
                    , r = t.getContext("2d");
                  this.clearCanvas(r),
                  r.drawImage(this.canvasContext.canvas, 0, 0),
                  this.canvasContext.setTransform(1, 0, 0, 1, 0, 0),
                  this.clearCanvas(this.canvasContext),
                  this.canvasContext.setTransform(this.currentTransform);
                  var a = this.comp.getElementById("tp"in this.data ? this.data.tp : this.data.ind - 1);
                  if (a.renderFrame(!0),
                  this.canvasContext.setTransform(1, 0, 0, 1, 0, 0),
                  this.data.tt >= 3 && !document._isProxy) {
                      var o = assetLoader.getLumaCanvas(this.canvasContext.canvas)
                        , l = o.getContext("2d");
                      l.drawImage(this.canvasContext.canvas, 0, 0),
                      this.clearCanvas(this.canvasContext),
                      this.canvasContext.drawImage(o, 0, 0)
                  }
                  this.canvasContext.globalCompositeOperation = operationsMap[this.data.tt],
                  this.canvasContext.drawImage(t, 0, 0),
                  this.canvasContext.globalCompositeOperation = "destination-over",
                  this.canvasContext.drawImage(this.buffers[0], 0, 0),
                  this.canvasContext.setTransform(this.currentTransform),
                  this.canvasContext.globalCompositeOperation = "source-over"
              }
          },
          renderFrame: function(t) {
              if (!(this.hidden || this.data.hd) && !(this.data.td === 1 && !t)) {
                  this.renderTransform(),
                  this.renderRenderable(),
                  this.renderLocalTransform(),
                  this.setBlendMode();
                  var r = this.data.ty === 0;
                  this.prepareLayer(),
                  this.globalData.renderer.save(r),
                  this.globalData.renderer.ctxTransform(this.finalTransform.localMat.props),
                  this.globalData.renderer.ctxOpacity(this.finalTransform.localOpacity),
                  this.renderInnerContent(),
                  this.globalData.renderer.restore(r),
                  this.exitLayer(),
                  this.maskManager.hasMasks && this.globalData.renderer.restore(!0),
                  this._isFirstFrame && (this._isFirstFrame = !1)
              }
          },
          destroy: function() {
              this.canvasContext = null,
              this.data = null,
              this.globalData = null,
              this.maskManager.destroy()
          },
          mHelper: new Matrix
      },
      CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement,
      CVBaseElement.prototype.show = CVBaseElement.prototype.showElement;
      function CVShapeData(e, t, r, a) {
          this.styledShapes = [],
          this.tr = [0, 0, 0, 0, 0, 0];
          var o = 4;
          t.ty === "rc" ? o = 5 : t.ty === "el" ? o = 6 : t.ty === "sr" && (o = 7),
          this.sh = ShapePropertyFactory.getShapeProp(e, t, o, e);
          var l, f = r.length, d;
          for (l = 0; l < f; l += 1)
              r[l].closed || (d = {
                  transforms: a.addTransformSequence(r[l].transforms),
                  trNodes: []
              },
              this.styledShapes.push(d),
              r[l].elements.push(d))
      }
      CVShapeData.prototype.setAsAnimated = SVGShapeData.prototype.setAsAnimated;
      function CVShapeElement(e, t, r) {
          this.shapes = [],
          this.shapesData = e.shapes,
          this.stylesList = [],
          this.itemsData = [],
          this.prevViewData = [],
          this.shapeModifiers = [],
          this.processedElements = [],
          this.transformsManager = new ShapeTransformManager,
          this.initElement(e, t, r)
      }
      extendPrototype([BaseElement, TransformElement, CVBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableElement], CVShapeElement),
      CVShapeElement.prototype.initElement = RenderableDOMElement.prototype.initElement,
      CVShapeElement.prototype.transformHelper = {
          opacity: 1,
          _opMdf: !1
      },
      CVShapeElement.prototype.dashResetter = [],
      CVShapeElement.prototype.createContent = function() {
          this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, !0, [])
      }
      ,
      CVShapeElement.prototype.createStyleElement = function(e, t) {
          var r = {
              data: e,
              type: e.ty,
              preTransforms: this.transformsManager.addTransformSequence(t),
              transforms: [],
              elements: [],
              closed: e.hd === !0
          }
            , a = {};
          if (e.ty === "fl" || e.ty === "st" ? (a.c = PropertyFactory.getProp(this, e.c, 1, 255, this),
          a.c.k || (r.co = "rgb(" + bmFloor(a.c.v[0]) + "," + bmFloor(a.c.v[1]) + "," + bmFloor(a.c.v[2]) + ")")) : (e.ty === "gf" || e.ty === "gs") && (a.s = PropertyFactory.getProp(this, e.s, 1, null, this),
          a.e = PropertyFactory.getProp(this, e.e, 1, null, this),
          a.h = PropertyFactory.getProp(this, e.h || {
              k: 0
          }, 0, .01, this),
          a.a = PropertyFactory.getProp(this, e.a || {
              k: 0
          }, 0, degToRads, this),
          a.g = new GradientProperty(this,e.g,this)),
          a.o = PropertyFactory.getProp(this, e.o, 0, .01, this),
          e.ty === "st" || e.ty === "gs") {
              if (r.lc = lineCapEnum[e.lc || 2],
              r.lj = lineJoinEnum[e.lj || 2],
              e.lj == 1 && (r.ml = e.ml),
              a.w = PropertyFactory.getProp(this, e.w, 0, null, this),
              a.w.k || (r.wi = a.w.v),
              e.d) {
                  var o = new DashProperty(this,e.d,"canvas",this);
                  a.d = o,
                  a.d.k || (r.da = a.d.dashArray,
                  r.do = a.d.dashoffset[0])
              }
          } else
              r.r = e.r === 2 ? "evenodd" : "nonzero";
          return this.stylesList.push(r),
          a.style = r,
          a
      }
      ,
      CVShapeElement.prototype.createGroupElement = function() {
          var e = {
              it: [],
              prevViewData: []
          };
          return e
      }
      ,
      CVShapeElement.prototype.createTransformElement = function(e) {
          var t = {
              transform: {
                  opacity: 1,
                  _opMdf: !1,
                  key: this.transformsManager.getNewKey(),
                  op: PropertyFactory.getProp(this, e.o, 0, .01, this),
                  mProps: TransformPropertyFactory.getTransformProperty(this, e, this)
              }
          };
          return t
      }
      ,
      CVShapeElement.prototype.createShapeElement = function(e) {
          var t = new CVShapeData(this,e,this.stylesList,this.transformsManager);
          return this.shapes.push(t),
          this.addShapeToModifiers(t),
          t
      }
      ,
      CVShapeElement.prototype.reloadShapes = function() {
          this._isFirstFrame = !0;
          var e, t = this.itemsData.length;
          for (e = 0; e < t; e += 1)
              this.prevViewData[e] = this.itemsData[e];
          for (this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, !0, []),
          t = this.dynamicProperties.length,
          e = 0; e < t; e += 1)
              this.dynamicProperties[e].getValue();
          this.renderModifiers(),
          this.transformsManager.processSequences(this._isFirstFrame)
      }
      ,
      CVShapeElement.prototype.addTransformToStyleList = function(e) {
          var t, r = this.stylesList.length;
          for (t = 0; t < r; t += 1)
              this.stylesList[t].closed || this.stylesList[t].transforms.push(e)
      }
      ,
      CVShapeElement.prototype.removeTransformFromStyleList = function() {
          var e, t = this.stylesList.length;
          for (e = 0; e < t; e += 1)
              this.stylesList[e].closed || this.stylesList[e].transforms.pop()
      }
      ,
      CVShapeElement.prototype.closeStyles = function(e) {
          var t, r = e.length;
          for (t = 0; t < r; t += 1)
              e[t].closed = !0
      }
      ,
      CVShapeElement.prototype.searchShapes = function(e, t, r, a, o) {
          var l, f = e.length - 1, d, g, _ = [], v = [], S, b, P, x = [].concat(o);
          for (l = f; l >= 0; l -= 1) {
              if (S = this.searchProcessedElement(e[l]),
              S ? t[l] = r[S - 1] : e[l]._shouldRender = a,
              e[l].ty === "fl" || e[l].ty === "st" || e[l].ty === "gf" || e[l].ty === "gs")
                  S ? t[l].style.closed = !1 : t[l] = this.createStyleElement(e[l], x),
                  _.push(t[l].style);
              else if (e[l].ty === "gr") {
                  if (!S)
                      t[l] = this.createGroupElement(e[l]);
                  else
                      for (g = t[l].it.length,
                      d = 0; d < g; d += 1)
                          t[l].prevViewData[d] = t[l].it[d];
                  this.searchShapes(e[l].it, t[l].it, t[l].prevViewData, a, x)
              } else
                  e[l].ty === "tr" ? (S || (P = this.createTransformElement(e[l]),
                  t[l] = P),
                  x.push(t[l]),
                  this.addTransformToStyleList(t[l])) : e[l].ty === "sh" || e[l].ty === "rc" || e[l].ty === "el" || e[l].ty === "sr" ? S || (t[l] = this.createShapeElement(e[l])) : e[l].ty === "tm" || e[l].ty === "rd" || e[l].ty === "pb" || e[l].ty === "zz" || e[l].ty === "op" ? (S ? (b = t[l],
                  b.closed = !1) : (b = ShapeModifiers.getModifier(e[l].ty),
                  b.init(this, e[l]),
                  t[l] = b,
                  this.shapeModifiers.push(b)),
                  v.push(b)) : e[l].ty === "rp" && (S ? (b = t[l],
                  b.closed = !0) : (b = ShapeModifiers.getModifier(e[l].ty),
                  t[l] = b,
                  b.init(this, e, l, t),
                  this.shapeModifiers.push(b),
                  a = !1),
                  v.push(b));
              this.addProcessedElement(e[l], l + 1)
          }
          for (this.removeTransformFromStyleList(),
          this.closeStyles(_),
          f = v.length,
          l = 0; l < f; l += 1)
              v[l].closed = !0
      }
      ,
      CVShapeElement.prototype.renderInnerContent = function() {
          this.transformHelper.opacity = 1,
          this.transformHelper._opMdf = !1,
          this.renderModifiers(),
          this.transformsManager.processSequences(this._isFirstFrame),
          this.renderShape(this.transformHelper, this.shapesData, this.itemsData, !0)
      }
      ,
      CVShapeElement.prototype.renderShapeTransform = function(e, t) {
          (e._opMdf || t.op._mdf || this._isFirstFrame) && (t.opacity = e.opacity,
          t.opacity *= t.op.v,
          t._opMdf = !0)
      }
      ,
      CVShapeElement.prototype.drawLayer = function() {
          var e, t = this.stylesList.length, r, a, o, l, f, d, g = this.globalData.renderer, _ = this.globalData.canvasContext, v, S;
          for (e = 0; e < t; e += 1)
              if (S = this.stylesList[e],
              v = S.type,
              !((v === "st" || v === "gs") && S.wi === 0 || !S.data._shouldRender || S.coOp === 0 || this.globalData.currentGlobalAlpha === 0)) {
                  for (g.save(),
                  f = S.elements,
                  v === "st" || v === "gs" ? (g.ctxStrokeStyle(v === "st" ? S.co : S.grd),
                  g.ctxLineWidth(S.wi),
                  g.ctxLineCap(S.lc),
                  g.ctxLineJoin(S.lj),
                  g.ctxMiterLimit(S.ml || 0)) : g.ctxFillStyle(v === "fl" ? S.co : S.grd),
                  g.ctxOpacity(S.coOp),
                  v !== "st" && v !== "gs" && _.beginPath(),
                  g.ctxTransform(S.preTransforms.finalTransform.props),
                  a = f.length,
                  r = 0; r < a; r += 1) {
                      for ((v === "st" || v === "gs") && (_.beginPath(),
                      S.da && (_.setLineDash(S.da),
                      _.lineDashOffset = S.do)),
                      d = f[r].trNodes,
                      l = d.length,
                      o = 0; o < l; o += 1)
                          d[o].t === "m" ? _.moveTo(d[o].p[0], d[o].p[1]) : d[o].t === "c" ? _.bezierCurveTo(d[o].pts[0], d[o].pts[1], d[o].pts[2], d[o].pts[3], d[o].pts[4], d[o].pts[5]) : _.closePath();
                      (v === "st" || v === "gs") && (g.ctxStroke(),
                      S.da && _.setLineDash(this.dashResetter))
                  }
                  v !== "st" && v !== "gs" && this.globalData.renderer.ctxFill(S.r),
                  g.restore()
              }
      }
      ,
      CVShapeElement.prototype.renderShape = function(e, t, r, a) {
          var o, l = t.length - 1, f;
          for (f = e,
          o = l; o >= 0; o -= 1)
              t[o].ty === "tr" ? (f = r[o].transform,
              this.renderShapeTransform(e, f)) : t[o].ty === "sh" || t[o].ty === "el" || t[o].ty === "rc" || t[o].ty === "sr" ? this.renderPath(t[o], r[o]) : t[o].ty === "fl" ? this.renderFill(t[o], r[o], f) : t[o].ty === "st" ? this.renderStroke(t[o], r[o], f) : t[o].ty === "gf" || t[o].ty === "gs" ? this.renderGradientFill(t[o], r[o], f) : t[o].ty === "gr" ? this.renderShape(f, t[o].it, r[o].it) : t[o].ty;
          a && this.drawLayer()
      }
      ,
      CVShapeElement.prototype.renderStyledShape = function(e, t) {
          if (this._isFirstFrame || t._mdf || e.transforms._mdf) {
              var r = e.trNodes, a = t.paths, o, l, f, d = a._length;
              r.length = 0;
              var g = e.transforms.finalTransform;
              for (f = 0; f < d; f += 1) {
                  var _ = a.shapes[f];
                  if (_ && _.v) {
                      for (l = _._length,
                      o = 1; o < l; o += 1)
                          o === 1 && r.push({
                              t: "m",
                              p: g.applyToPointArray(_.v[0][0], _.v[0][1], 0)
                          }),
                          r.push({
                              t: "c",
                              pts: g.applyToTriplePoints(_.o[o - 1], _.i[o], _.v[o])
                          });
                      l === 1 && r.push({
                          t: "m",
                          p: g.applyToPointArray(_.v[0][0], _.v[0][1], 0)
                      }),
                      _.c && l && (r.push({
                          t: "c",
                          pts: g.applyToTriplePoints(_.o[o - 1], _.i[0], _.v[0])
                      }),
                      r.push({
                          t: "z"
                      }))
                  }
              }
              e.trNodes = r
          }
      }
      ,
      CVShapeElement.prototype.renderPath = function(e, t) {
          if (e.hd !== !0 && e._shouldRender) {
              var r, a = t.styledShapes.length;
              for (r = 0; r < a; r += 1)
                  this.renderStyledShape(t.styledShapes[r], t.sh)
          }
      }
      ,
      CVShapeElement.prototype.renderFill = function(e, t, r) {
          var a = t.style;
          (t.c._mdf || this._isFirstFrame) && (a.co = "rgb(" + bmFloor(t.c.v[0]) + "," + bmFloor(t.c.v[1]) + "," + bmFloor(t.c.v[2]) + ")"),
          (t.o._mdf || r._opMdf || this._isFirstFrame) && (a.coOp = t.o.v * r.opacity)
      }
      ,
      CVShapeElement.prototype.renderGradientFill = function(e, t, r) {
          var a = t.style, o;
          if (!a.grd || t.g._mdf || t.s._mdf || t.e._mdf || e.t !== 1 && (t.h._mdf || t.a._mdf)) {
              var l = this.globalData.canvasContext
                , f = t.s.v
                , d = t.e.v;
              if (e.t === 1)
                  o = l.createLinearGradient(f[0], f[1], d[0], d[1]);
              else {
                  var g = Math.sqrt(Math.pow(f[0] - d[0], 2) + Math.pow(f[1] - d[1], 2))
                    , _ = Math.atan2(d[1] - f[1], d[0] - f[0])
                    , v = t.h.v;
                  v >= 1 ? v = .99 : v <= -1 && (v = -.99);
                  var S = g * v
                    , b = Math.cos(_ + t.a.v) * S + f[0]
                    , P = Math.sin(_ + t.a.v) * S + f[1];
                  o = l.createRadialGradient(b, P, 0, f[0], f[1], g)
              }
              var x, E = e.g.p, I = t.g.c, C = 1;
              for (x = 0; x < E; x += 1)
                  t.g._hasOpacity && t.g._collapsable && (C = t.g.o[x * 2 + 1]),
                  o.addColorStop(I[x * 4] / 100, "rgba(" + I[x * 4 + 1] + "," + I[x * 4 + 2] + "," + I[x * 4 + 3] + "," + C + ")");
              a.grd = o
          }
          a.coOp = t.o.v * r.opacity
      }
      ,
      CVShapeElement.prototype.renderStroke = function(e, t, r) {
          var a = t.style
            , o = t.d;
          o && (o._mdf || this._isFirstFrame) && (a.da = o.dashArray,
          a.do = o.dashoffset[0]),
          (t.c._mdf || this._isFirstFrame) && (a.co = "rgb(" + bmFloor(t.c.v[0]) + "," + bmFloor(t.c.v[1]) + "," + bmFloor(t.c.v[2]) + ")"),
          (t.o._mdf || r._opMdf || this._isFirstFrame) && (a.coOp = t.o.v * r.opacity),
          (t.w._mdf || this._isFirstFrame) && (a.wi = t.w.v)
      }
      ,
      CVShapeElement.prototype.destroy = function() {
          this.shapesData = null,
          this.globalData = null,
          this.canvasContext = null,
          this.stylesList.length = 0,
          this.itemsData.length = 0
      }
      ;
      function CVTextElement(e, t, r) {
          this.textSpans = [],
          this.yOffset = 0,
          this.fillColorAnim = !1,
          this.strokeColorAnim = !1,
          this.strokeWidthAnim = !1,
          this.stroke = !1,
          this.fill = !1,
          this.justifyOffset = 0,
          this.currentRender = null,
          this.renderType = "canvas",
          this.values = {
              fill: "rgba(0,0,0,0)",
              stroke: "rgba(0,0,0,0)",
              sWidth: 0,
              fValue: ""
          },
          this.initElement(e, t, r)
      }
      extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement, ITextElement], CVTextElement),
      CVTextElement.prototype.tHelper = createTag("canvas").getContext("2d"),
      CVTextElement.prototype.buildNewText = function() {
          var e = this.textProperty.currentData;
          this.renderedLetters = createSizedArray(e.l ? e.l.length : 0);
          var t = !1;
          e.fc ? (t = !0,
          this.values.fill = this.buildColor(e.fc)) : this.values.fill = "rgba(0,0,0,0)",
          this.fill = t;
          var r = !1;
          e.sc && (r = !0,
          this.values.stroke = this.buildColor(e.sc),
          this.values.sWidth = e.sw);
          var a = this.globalData.fontManager.getFontByName(e.f), o, l, f = e.l, d = this.mHelper;
          this.stroke = r,
          this.values.fValue = e.finalSize + "px " + this.globalData.fontManager.getFontByName(e.f).fFamily,
          l = e.finalText.length;
          var g, _, v, S, b, P, x, E, I, C, A = this.data.singleShape, T = e.tr * .001 * e.finalSize, w = 0, M = 0, F = !0, O = 0;
          for (o = 0; o < l; o += 1) {
              g = this.globalData.fontManager.getCharData(e.finalText[o], a.fStyle, this.globalData.fontManager.getFontByName(e.f).fFamily),
              _ = g && g.data || {},
              d.reset(),
              A && f[o].n && (w = -T,
              M += e.yOffset,
              M += F ? 1 : 0,
              F = !1),
              b = _.shapes ? _.shapes[0].it : [],
              x = b.length,
              d.scale(e.finalSize / 100, e.finalSize / 100),
              A && this.applyTextPropertiesToMatrix(e, d, f[o].line, w, M),
              I = createSizedArray(x - 1);
              var $ = 0;
              for (P = 0; P < x; P += 1)
                  if (b[P].ty === "sh") {
                      for (S = b[P].ks.k.i.length,
                      E = b[P].ks.k,
                      C = [],
                      v = 1; v < S; v += 1)
                          v === 1 && C.push(d.applyToX(E.v[0][0], E.v[0][1], 0), d.applyToY(E.v[0][0], E.v[0][1], 0)),
                          C.push(d.applyToX(E.o[v - 1][0], E.o[v - 1][1], 0), d.applyToY(E.o[v - 1][0], E.o[v - 1][1], 0), d.applyToX(E.i[v][0], E.i[v][1], 0), d.applyToY(E.i[v][0], E.i[v][1], 0), d.applyToX(E.v[v][0], E.v[v][1], 0), d.applyToY(E.v[v][0], E.v[v][1], 0));
                      C.push(d.applyToX(E.o[v - 1][0], E.o[v - 1][1], 0), d.applyToY(E.o[v - 1][0], E.o[v - 1][1], 0), d.applyToX(E.i[0][0], E.i[0][1], 0), d.applyToY(E.i[0][0], E.i[0][1], 0), d.applyToX(E.v[0][0], E.v[0][1], 0), d.applyToY(E.v[0][0], E.v[0][1], 0)),
                      I[$] = C,
                      $ += 1
                  }
              A && (w += f[o].l,
              w += T),
              this.textSpans[O] ? this.textSpans[O].elem = I : this.textSpans[O] = {
                  elem: I
              },
              O += 1
          }
      }
      ,
      CVTextElement.prototype.renderInnerContent = function() {
          this.validateText();
          var e = this.canvasContext;
          e.font = this.values.fValue,
          this.globalData.renderer.ctxLineCap("butt"),
          this.globalData.renderer.ctxLineJoin("miter"),
          this.globalData.renderer.ctxMiterLimit(4),
          this.data.singleShape || this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
          var t, r, a, o, l, f, d = this.textAnimator.renderedLetters, g = this.textProperty.currentData.l;
          r = g.length;
          var _, v = null, S = null, b = null, P, x, E = this.globalData.renderer;
          for (t = 0; t < r; t += 1)
              if (!g[t].n) {
                  if (_ = d[t],
                  _ && (E.save(),
                  E.ctxTransform(_.p),
                  E.ctxOpacity(_.o)),
                  this.fill) {
                      for (_ && _.fc ? v !== _.fc && (E.ctxFillStyle(_.fc),
                      v = _.fc) : v !== this.values.fill && (v = this.values.fill,
                      E.ctxFillStyle(this.values.fill)),
                      P = this.textSpans[t].elem,
                      o = P.length,
                      this.globalData.canvasContext.beginPath(),
                      a = 0; a < o; a += 1)
                          for (x = P[a],
                          f = x.length,
                          this.globalData.canvasContext.moveTo(x[0], x[1]),
                          l = 2; l < f; l += 6)
                              this.globalData.canvasContext.bezierCurveTo(x[l], x[l + 1], x[l + 2], x[l + 3], x[l + 4], x[l + 5]);
                      this.globalData.canvasContext.closePath(),
                      E.ctxFill()
                  }
                  if (this.stroke) {
                      for (_ && _.sw ? b !== _.sw && (b = _.sw,
                      E.ctxLineWidth(_.sw)) : b !== this.values.sWidth && (b = this.values.sWidth,
                      E.ctxLineWidth(this.values.sWidth)),
                      _ && _.sc ? S !== _.sc && (S = _.sc,
                      E.ctxStrokeStyle(_.sc)) : S !== this.values.stroke && (S = this.values.stroke,
                      E.ctxStrokeStyle(this.values.stroke)),
                      P = this.textSpans[t].elem,
                      o = P.length,
                      this.globalData.canvasContext.beginPath(),
                      a = 0; a < o; a += 1)
                          for (x = P[a],
                          f = x.length,
                          this.globalData.canvasContext.moveTo(x[0], x[1]),
                          l = 2; l < f; l += 6)
                              this.globalData.canvasContext.bezierCurveTo(x[l], x[l + 1], x[l + 2], x[l + 3], x[l + 4], x[l + 5]);
                      this.globalData.canvasContext.closePath(),
                      E.ctxStroke()
                  }
                  _ && this.globalData.renderer.restore()
              }
      }
      ;
      function CVImageElement(e, t, r) {
          this.assetData = t.getAssetData(e.refId),
          this.img = t.imageLoader.getAsset(this.assetData),
          this.initElement(e, t, r)
      }
      extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVImageElement),
      CVImageElement.prototype.initElement = SVGShapeElement.prototype.initElement,
      CVImageElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame,
      CVImageElement.prototype.createContent = function() {
          if (this.img.width && (this.assetData.w !== this.img.width || this.assetData.h !== this.img.height)) {
              var e = createTag("canvas");
              e.width = this.assetData.w,
              e.height = this.assetData.h;
              var t = e.getContext("2d"), r = this.img.width, a = this.img.height, o = r / a, l = this.assetData.w / this.assetData.h, f, d, g = this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio;
              o > l && g === "xMidYMid slice" || o < l && g !== "xMidYMid slice" ? (d = a,
              f = d * l) : (f = r,
              d = f / l),
              t.drawImage(this.img, (r - f) / 2, (a - d) / 2, f, d, 0, 0, this.assetData.w, this.assetData.h),
              this.img = e
          }
      }
      ,
      CVImageElement.prototype.renderInnerContent = function() {
          this.canvasContext.drawImage(this.img, 0, 0)
      }
      ,
      CVImageElement.prototype.destroy = function() {
          this.img = null
      }
      ;
      function CVSolidElement(e, t, r) {
          this.initElement(e, t, r)
      }
      extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVSolidElement),
      CVSolidElement.prototype.initElement = SVGShapeElement.prototype.initElement,
      CVSolidElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame,
      CVSolidElement.prototype.renderInnerContent = function() {
          this.globalData.renderer.ctxFillStyle(this.data.sc),
          this.globalData.renderer.ctxFillRect(0, 0, this.data.sw, this.data.sh)
      }
      ;
      function CanvasRendererBase() {}
      extendPrototype([BaseRenderer], CanvasRendererBase),
      CanvasRendererBase.prototype.createShape = function(e) {
          return new CVShapeElement(e,this.globalData,this)
      }
      ,
      CanvasRendererBase.prototype.createText = function(e) {
          return new CVTextElement(e,this.globalData,this)
      }
      ,
      CanvasRendererBase.prototype.createImage = function(e) {
          return new CVImageElement(e,this.globalData,this)
      }
      ,
      CanvasRendererBase.prototype.createSolid = function(e) {
          return new CVSolidElement(e,this.globalData,this)
      }
      ,
      CanvasRendererBase.prototype.createNull = SVGRenderer.prototype.createNull,
      CanvasRendererBase.prototype.ctxTransform = function(e) {
          e[0] === 1 && e[1] === 0 && e[4] === 0 && e[5] === 1 && e[12] === 0 && e[13] === 0 || this.canvasContext.transform(e[0], e[1], e[4], e[5], e[12], e[13])
      }
      ,
      CanvasRendererBase.prototype.ctxOpacity = function(e) {
          this.canvasContext.globalAlpha *= e < 0 ? 0 : e
      }
      ,
      CanvasRendererBase.prototype.ctxFillStyle = function(e) {
          this.canvasContext.fillStyle = e
      }
      ,
      CanvasRendererBase.prototype.ctxStrokeStyle = function(e) {
          this.canvasContext.strokeStyle = e
      }
      ,
      CanvasRendererBase.prototype.ctxLineWidth = function(e) {
          this.canvasContext.lineWidth = e
      }
      ,
      CanvasRendererBase.prototype.ctxLineCap = function(e) {
          this.canvasContext.lineCap = e
      }
      ,
      CanvasRendererBase.prototype.ctxLineJoin = function(e) {
          this.canvasContext.lineJoin = e
      }
      ,
      CanvasRendererBase.prototype.ctxMiterLimit = function(e) {
          this.canvasContext.miterLimit = e
      }
      ,
      CanvasRendererBase.prototype.ctxFill = function(e) {
          this.canvasContext.fill(e)
      }
      ,
      CanvasRendererBase.prototype.ctxFillRect = function(e, t, r, a) {
          this.canvasContext.fillRect(e, t, r, a)
      }
      ,
      CanvasRendererBase.prototype.ctxStroke = function() {
          this.canvasContext.stroke()
      }
      ,
      CanvasRendererBase.prototype.reset = function() {
          if (!this.renderConfig.clearCanvas) {
              this.canvasContext.restore();
              return
          }
          this.contextData.reset()
      }
      ,
      CanvasRendererBase.prototype.save = function() {
          this.canvasContext.save()
      }
      ,
      CanvasRendererBase.prototype.restore = function(e) {
          if (!this.renderConfig.clearCanvas) {
              this.canvasContext.restore();
              return
          }
          e && (this.globalData.blendMode = "source-over"),
          this.contextData.restore(e)
      }
      ,
      CanvasRendererBase.prototype.configAnimation = function(e) {
          if (this.animationItem.wrapper) {
              this.animationItem.container = createTag("canvas");
              var t = this.animationItem.container.style;
              t.width = "100%",
              t.height = "100%";
              var r = "0px 0px 0px";
              t.transformOrigin = r,
              t.mozTransformOrigin = r,
              t.webkitTransformOrigin = r,
              t["-webkit-transform"] = r,
              t.contentVisibility = this.renderConfig.contentVisibility,
              this.animationItem.wrapper.appendChild(this.animationItem.container),
              this.canvasContext = this.animationItem.container.getContext("2d"),
              this.renderConfig.className && this.animationItem.container.setAttribute("class", this.renderConfig.className),
              this.renderConfig.id && this.animationItem.container.setAttribute("id", this.renderConfig.id)
          } else
              this.canvasContext = this.renderConfig.context;
          this.contextData.setContext(this.canvasContext),
          this.data = e,
          this.layers = e.layers,
          this.transformCanvas = {
              w: e.w,
              h: e.h,
              sx: 0,
              sy: 0,
              tx: 0,
              ty: 0
          },
          this.setupGlobalData(e, document.body),
          this.globalData.canvasContext = this.canvasContext,
          this.globalData.renderer = this,
          this.globalData.isDashed = !1,
          this.globalData.progressiveLoad = this.renderConfig.progressiveLoad,
          this.globalData.transformCanvas = this.transformCanvas,
          this.elements = createSizedArray(e.layers.length),
          this.updateContainerSize()
      }
      ,
      CanvasRendererBase.prototype.updateContainerSize = function(e, t) {
          this.reset();
          var r, a;
          e ? (r = e,
          a = t,
          this.canvasContext.canvas.width = r,
          this.canvasContext.canvas.height = a) : (this.animationItem.wrapper && this.animationItem.container ? (r = this.animationItem.wrapper.offsetWidth,
          a = this.animationItem.wrapper.offsetHeight) : (r = this.canvasContext.canvas.width,
          a = this.canvasContext.canvas.height),
          this.canvasContext.canvas.width = r * this.renderConfig.dpr,
          this.canvasContext.canvas.height = a * this.renderConfig.dpr);
          var o, l;
          if (this.renderConfig.preserveAspectRatio.indexOf("meet") !== -1 || this.renderConfig.preserveAspectRatio.indexOf("slice") !== -1) {
              var f = this.renderConfig.preserveAspectRatio.split(" ")
                , d = f[1] || "meet"
                , g = f[0] || "xMidYMid"
                , _ = g.substr(0, 4)
                , v = g.substr(4);
              o = r / a,
              l = this.transformCanvas.w / this.transformCanvas.h,
              l > o && d === "meet" || l < o && d === "slice" ? (this.transformCanvas.sx = r / (this.transformCanvas.w / this.renderConfig.dpr),
              this.transformCanvas.sy = r / (this.transformCanvas.w / this.renderConfig.dpr)) : (this.transformCanvas.sx = a / (this.transformCanvas.h / this.renderConfig.dpr),
              this.transformCanvas.sy = a / (this.transformCanvas.h / this.renderConfig.dpr)),
              _ === "xMid" && (l < o && d === "meet" || l > o && d === "slice") ? this.transformCanvas.tx = (r - this.transformCanvas.w * (a / this.transformCanvas.h)) / 2 * this.renderConfig.dpr : _ === "xMax" && (l < o && d === "meet" || l > o && d === "slice") ? this.transformCanvas.tx = (r - this.transformCanvas.w * (a / this.transformCanvas.h)) * this.renderConfig.dpr : this.transformCanvas.tx = 0,
              v === "YMid" && (l > o && d === "meet" || l < o && d === "slice") ? this.transformCanvas.ty = (a - this.transformCanvas.h * (r / this.transformCanvas.w)) / 2 * this.renderConfig.dpr : v === "YMax" && (l > o && d === "meet" || l < o && d === "slice") ? this.transformCanvas.ty = (a - this.transformCanvas.h * (r / this.transformCanvas.w)) * this.renderConfig.dpr : this.transformCanvas.ty = 0
          } else
              this.renderConfig.preserveAspectRatio === "none" ? (this.transformCanvas.sx = r / (this.transformCanvas.w / this.renderConfig.dpr),
              this.transformCanvas.sy = a / (this.transformCanvas.h / this.renderConfig.dpr),
              this.transformCanvas.tx = 0,
              this.transformCanvas.ty = 0) : (this.transformCanvas.sx = this.renderConfig.dpr,
              this.transformCanvas.sy = this.renderConfig.dpr,
              this.transformCanvas.tx = 0,
              this.transformCanvas.ty = 0);
          this.transformCanvas.props = [this.transformCanvas.sx, 0, 0, 0, 0, this.transformCanvas.sy, 0, 0, 0, 0, 1, 0, this.transformCanvas.tx, this.transformCanvas.ty, 0, 1],
          this.ctxTransform(this.transformCanvas.props),
          this.canvasContext.beginPath(),
          this.canvasContext.rect(0, 0, this.transformCanvas.w, this.transformCanvas.h),
          this.canvasContext.closePath(),
          this.canvasContext.clip(),
          this.renderFrame(this.renderedFrame, !0)
      }
      ,
      CanvasRendererBase.prototype.destroy = function() {
          this.renderConfig.clearCanvas && this.animationItem.wrapper && (this.animationItem.wrapper.innerText = "");
          var e, t = this.layers ? this.layers.length : 0;
          for (e = t - 1; e >= 0; e -= 1)
              this.elements[e] && this.elements[e].destroy && this.elements[e].destroy();
          this.elements.length = 0,
          this.globalData.canvasContext = null,
          this.animationItem.container = null,
          this.destroyed = !0
      }
      ,
      CanvasRendererBase.prototype.renderFrame = function(e, t) {
          if (!(this.renderedFrame === e && this.renderConfig.clearCanvas === !0 && !t || this.destroyed || e === -1)) {
              this.renderedFrame = e,
              this.globalData.frameNum = e - this.animationItem._isFirstFrame,
              this.globalData.frameId += 1,
              this.globalData._mdf = !this.renderConfig.clearCanvas || t,
              this.globalData.projectInterface.currentFrame = e;
              var r, a = this.layers.length;
              for (this.completeLayers || this.checkLayers(e),
              r = a - 1; r >= 0; r -= 1)
                  (this.completeLayers || this.elements[r]) && this.elements[r].prepareFrame(e - this.layers[r].st);
              if (this.globalData._mdf) {
                  for (this.renderConfig.clearCanvas === !0 ? this.canvasContext.clearRect(0, 0, this.transformCanvas.w, this.transformCanvas.h) : this.save(),
                  r = a - 1; r >= 0; r -= 1)
                      (this.completeLayers || this.elements[r]) && this.elements[r].renderFrame();
                  this.renderConfig.clearCanvas !== !0 && this.restore()
              }
          }
      }
      ,
      CanvasRendererBase.prototype.buildItem = function(e) {
          var t = this.elements;
          if (!(t[e] || this.layers[e].ty === 99)) {
              var r = this.createItem(this.layers[e], this, this.globalData);
              t[e] = r,
              r.initExpressions()
          }
      }
      ,
      CanvasRendererBase.prototype.checkPendingElements = function() {
          for (; this.pendingElements.length; ) {
              var e = this.pendingElements.pop();
              e.checkParenting()
          }
      }
      ,
      CanvasRendererBase.prototype.hide = function() {
          this.animationItem.container.style.display = "none"
      }
      ,
      CanvasRendererBase.prototype.show = function() {
          this.animationItem.container.style.display = "block"
      }
      ;
      function CanvasContext() {
          this.opacity = -1,
          this.transform = createTypedArray("float32", 16),
          this.fillStyle = "",
          this.strokeStyle = "",
          this.lineWidth = "",
          this.lineCap = "",
          this.lineJoin = "",
          this.miterLimit = "",
          this.id = Math.random()
      }
      function CVContextData() {
          this.stack = [],
          this.cArrPos = 0,
          this.cTr = new Matrix;
          var e, t = 15;
          for (e = 0; e < t; e += 1) {
              var r = new CanvasContext;
              this.stack[e] = r
          }
          this._length = t,
          this.nativeContext = null,
          this.transformMat = new Matrix,
          this.currentOpacity = 1,
          this.currentFillStyle = "",
          this.appliedFillStyle = "",
          this.currentStrokeStyle = "",
          this.appliedStrokeStyle = "",
          this.currentLineWidth = "",
          this.appliedLineWidth = "",
          this.currentLineCap = "",
          this.appliedLineCap = "",
          this.currentLineJoin = "",
          this.appliedLineJoin = "",
          this.appliedMiterLimit = "",
          this.currentMiterLimit = ""
      }
      CVContextData.prototype.duplicate = function() {
          var e = this._length * 2
            , t = 0;
          for (t = this._length; t < e; t += 1)
              this.stack[t] = new CanvasContext;
          this._length = e
      }
      ,
      CVContextData.prototype.reset = function() {
          this.cArrPos = 0,
          this.cTr.reset(),
          this.stack[this.cArrPos].opacity = 1
      }
      ,
      CVContextData.prototype.restore = function(e) {
          this.cArrPos -= 1;
          var t = this.stack[this.cArrPos], r = t.transform, a, o = this.cTr.props;
          for (a = 0; a < 16; a += 1)
              o[a] = r[a];
          if (e) {
              this.nativeContext.restore();
              var l = this.stack[this.cArrPos + 1];
              this.appliedFillStyle = l.fillStyle,
              this.appliedStrokeStyle = l.strokeStyle,
              this.appliedLineWidth = l.lineWidth,
              this.appliedLineCap = l.lineCap,
              this.appliedLineJoin = l.lineJoin,
              this.appliedMiterLimit = l.miterLimit
          }
          this.nativeContext.setTransform(r[0], r[1], r[4], r[5], r[12], r[13]),
          (e || t.opacity !== -1 && this.currentOpacity !== t.opacity) && (this.nativeContext.globalAlpha = t.opacity,
          this.currentOpacity = t.opacity),
          this.currentFillStyle = t.fillStyle,
          this.currentStrokeStyle = t.strokeStyle,
          this.currentLineWidth = t.lineWidth,
          this.currentLineCap = t.lineCap,
          this.currentLineJoin = t.lineJoin,
          this.currentMiterLimit = t.miterLimit
      }
      ,
      CVContextData.prototype.save = function(e) {
          e && this.nativeContext.save();
          var t = this.cTr.props;
          this._length <= this.cArrPos && this.duplicate();
          var r = this.stack[this.cArrPos], a;
          for (a = 0; a < 16; a += 1)
              r.transform[a] = t[a];
          this.cArrPos += 1;
          var o = this.stack[this.cArrPos];
          o.opacity = r.opacity,
          o.fillStyle = r.fillStyle,
          o.strokeStyle = r.strokeStyle,
          o.lineWidth = r.lineWidth,
          o.lineCap = r.lineCap,
          o.lineJoin = r.lineJoin,
          o.miterLimit = r.miterLimit
      }
      ,
      CVContextData.prototype.setOpacity = function(e) {
          this.stack[this.cArrPos].opacity = e
      }
      ,
      CVContextData.prototype.setContext = function(e) {
          this.nativeContext = e
      }
      ,
      CVContextData.prototype.fillStyle = function(e) {
          this.stack[this.cArrPos].fillStyle !== e && (this.currentFillStyle = e,
          this.stack[this.cArrPos].fillStyle = e)
      }
      ,
      CVContextData.prototype.strokeStyle = function(e) {
          this.stack[this.cArrPos].strokeStyle !== e && (this.currentStrokeStyle = e,
          this.stack[this.cArrPos].strokeStyle = e)
      }
      ,
      CVContextData.prototype.lineWidth = function(e) {
          this.stack[this.cArrPos].lineWidth !== e && (this.currentLineWidth = e,
          this.stack[this.cArrPos].lineWidth = e)
      }
      ,
      CVContextData.prototype.lineCap = function(e) {
          this.stack[this.cArrPos].lineCap !== e && (this.currentLineCap = e,
          this.stack[this.cArrPos].lineCap = e)
      }
      ,
      CVContextData.prototype.lineJoin = function(e) {
          this.stack[this.cArrPos].lineJoin !== e && (this.currentLineJoin = e,
          this.stack[this.cArrPos].lineJoin = e)
      }
      ,
      CVContextData.prototype.miterLimit = function(e) {
          this.stack[this.cArrPos].miterLimit !== e && (this.currentMiterLimit = e,
          this.stack[this.cArrPos].miterLimit = e)
      }
      ,
      CVContextData.prototype.transform = function(e) {
          this.transformMat.cloneFromProps(e);
          var t = this.cTr;
          this.transformMat.multiply(t),
          t.cloneFromProps(this.transformMat.props);
          var r = t.props;
          this.nativeContext.setTransform(r[0], r[1], r[4], r[5], r[12], r[13])
      }
      ,
      CVContextData.prototype.opacity = function(e) {
          var t = this.stack[this.cArrPos].opacity;
          t *= e < 0 ? 0 : e,
          this.stack[this.cArrPos].opacity !== t && (this.currentOpacity !== e && (this.nativeContext.globalAlpha = e,
          this.currentOpacity = e),
          this.stack[this.cArrPos].opacity = t)
      }
      ,
      CVContextData.prototype.fill = function(e) {
          this.appliedFillStyle !== this.currentFillStyle && (this.appliedFillStyle = this.currentFillStyle,
          this.nativeContext.fillStyle = this.appliedFillStyle),
          this.nativeContext.fill(e)
      }
      ,
      CVContextData.prototype.fillRect = function(e, t, r, a) {
          this.appliedFillStyle !== this.currentFillStyle && (this.appliedFillStyle = this.currentFillStyle,
          this.nativeContext.fillStyle = this.appliedFillStyle),
          this.nativeContext.fillRect(e, t, r, a)
      }
      ,
      CVContextData.prototype.stroke = function() {
          this.appliedStrokeStyle !== this.currentStrokeStyle && (this.appliedStrokeStyle = this.currentStrokeStyle,
          this.nativeContext.strokeStyle = this.appliedStrokeStyle),
          this.appliedLineWidth !== this.currentLineWidth && (this.appliedLineWidth = this.currentLineWidth,
          this.nativeContext.lineWidth = this.appliedLineWidth),
          this.appliedLineCap !== this.currentLineCap && (this.appliedLineCap = this.currentLineCap,
          this.nativeContext.lineCap = this.appliedLineCap),
          this.appliedLineJoin !== this.currentLineJoin && (this.appliedLineJoin = this.currentLineJoin,
          this.nativeContext.lineJoin = this.appliedLineJoin),
          this.appliedMiterLimit !== this.currentMiterLimit && (this.appliedMiterLimit = this.currentMiterLimit,
          this.nativeContext.miterLimit = this.appliedMiterLimit),
          this.nativeContext.stroke()
      }
      ;
      function CVCompElement(e, t, r) {
          this.completeLayers = !1,
          this.layers = e.layers,
          this.pendingElements = [],
          this.elements = createSizedArray(this.layers.length),
          this.initElement(e, t, r),
          this.tm = e.tm ? PropertyFactory.getProp(this, e.tm, 0, t.frameRate, this) : {
              _placeholder: !0
          }
      }
      extendPrototype([CanvasRendererBase, ICompElement, CVBaseElement], CVCompElement),
      CVCompElement.prototype.renderInnerContent = function() {
          var e = this.canvasContext;
          e.beginPath(),
          e.moveTo(0, 0),
          e.lineTo(this.data.w, 0),
          e.lineTo(this.data.w, this.data.h),
          e.lineTo(0, this.data.h),
          e.lineTo(0, 0),
          e.clip();
          var t, r = this.layers.length;
          for (t = r - 1; t >= 0; t -= 1)
              (this.completeLayers || this.elements[t]) && this.elements[t].renderFrame()
      }
      ,
      CVCompElement.prototype.destroy = function() {
          var e, t = this.layers.length;
          for (e = t - 1; e >= 0; e -= 1)
              this.elements[e] && this.elements[e].destroy();
          this.layers = null,
          this.elements = null
      }
      ,
      CVCompElement.prototype.createComp = function(e) {
          return new CVCompElement(e,this.globalData,this)
      }
      ;
      function CanvasRenderer(e, t) {
          this.animationItem = e,
          this.renderConfig = {
              clearCanvas: t && t.clearCanvas !== void 0 ? t.clearCanvas : !0,
              context: t && t.context || null,
              progressiveLoad: t && t.progressiveLoad || !1,
              preserveAspectRatio: t && t.preserveAspectRatio || "xMidYMid meet",
              imagePreserveAspectRatio: t && t.imagePreserveAspectRatio || "xMidYMid slice",
              contentVisibility: t && t.contentVisibility || "visible",
              className: t && t.className || "",
              id: t && t.id || "",
              runExpressions: !t || t.runExpressions === void 0 || t.runExpressions
          },
          this.renderConfig.dpr = t && t.dpr || 1,
          this.animationItem.wrapper && (this.renderConfig.dpr = t && t.dpr || window.devicePixelRatio || 1),
          this.renderedFrame = -1,
          this.globalData = {
              frameNum: -1,
              _mdf: !1,
              renderConfig: this.renderConfig,
              currentGlobalAlpha: -1
          },
          this.contextData = new CVContextData,
          this.elements = [],
          this.pendingElements = [],
          this.transformMat = new Matrix,
          this.completeLayers = !1,
          this.rendererType = "canvas",
          this.renderConfig.clearCanvas && (this.ctxTransform = this.contextData.transform.bind(this.contextData),
          this.ctxOpacity = this.contextData.opacity.bind(this.contextData),
          this.ctxFillStyle = this.contextData.fillStyle.bind(this.contextData),
          this.ctxStrokeStyle = this.contextData.strokeStyle.bind(this.contextData),
          this.ctxLineWidth = this.contextData.lineWidth.bind(this.contextData),
          this.ctxLineCap = this.contextData.lineCap.bind(this.contextData),
          this.ctxLineJoin = this.contextData.lineJoin.bind(this.contextData),
          this.ctxMiterLimit = this.contextData.miterLimit.bind(this.contextData),
          this.ctxFill = this.contextData.fill.bind(this.contextData),
          this.ctxFillRect = this.contextData.fillRect.bind(this.contextData),
          this.ctxStroke = this.contextData.stroke.bind(this.contextData),
          this.save = this.contextData.save.bind(this.contextData))
      }
      extendPrototype([CanvasRendererBase], CanvasRenderer),
      CanvasRenderer.prototype.createComp = function(e) {
          return new CVCompElement(e,this.globalData,this)
      }
      ;
      function HBaseElement() {}
      HBaseElement.prototype = {
          checkBlendMode: function() {},
          initRendererElement: function() {
              this.baseElement = createTag(this.data.tg || "div"),
              this.data.hasMask ? (this.svgElement = createNS("svg"),
              this.layerElement = createNS("g"),
              this.maskedElement = this.layerElement,
              this.svgElement.appendChild(this.layerElement),
              this.baseElement.appendChild(this.svgElement)) : this.layerElement = this.baseElement,
              styleDiv(this.baseElement)
          },
          createContainerElements: function() {
              this.renderableEffectsManager = new CVEffects(this),
              this.transformedElement = this.baseElement,
              this.maskedElement = this.layerElement,
              this.data.ln && this.layerElement.setAttribute("id", this.data.ln),
              this.data.cl && this.layerElement.setAttribute("class", this.data.cl),
              this.data.bm !== 0 && this.setBlendMode()
          },
          renderElement: function() {
              var t = this.transformedElement ? this.transformedElement.style : {};
              if (this.finalTransform._matMdf) {
                  var r = this.finalTransform.mat.toCSS();
                  t.transform = r,
                  t.webkitTransform = r
              }
              this.finalTransform._opMdf && (t.opacity = this.finalTransform.mProp.o.v)
          },
          renderFrame: function() {
              this.data.hd || this.hidden || (this.renderTransform(),
              this.renderRenderable(),
              this.renderElement(),
              this.renderInnerContent(),
              this._isFirstFrame && (this._isFirstFrame = !1))
          },
          destroy: function() {
              this.layerElement = null,
              this.transformedElement = null,
              this.matteElement && (this.matteElement = null),
              this.maskManager && (this.maskManager.destroy(),
              this.maskManager = null)
          },
          createRenderableComponents: function() {
              this.maskManager = new MaskElement(this.data,this,this.globalData)
          },
          addEffects: function() {},
          setMatte: function() {}
      },
      HBaseElement.prototype.getBaseElement = SVGBaseElement.prototype.getBaseElement,
      HBaseElement.prototype.destroyBaseElement = HBaseElement.prototype.destroy,
      HBaseElement.prototype.buildElementParenting = BaseRenderer.prototype.buildElementParenting;
      function HSolidElement(e, t, r) {
          this.initElement(e, t, r)
      }
      extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], HSolidElement),
      HSolidElement.prototype.createContent = function() {
          var e;
          this.data.hasMask ? (e = createNS("rect"),
          e.setAttribute("width", this.data.sw),
          e.setAttribute("height", this.data.sh),
          e.setAttribute("fill", this.data.sc),
          this.svgElement.setAttribute("width", this.data.sw),
          this.svgElement.setAttribute("height", this.data.sh)) : (e = createTag("div"),
          e.style.width = this.data.sw + "px",
          e.style.height = this.data.sh + "px",
          e.style.backgroundColor = this.data.sc),
          this.layerElement.appendChild(e)
      }
      ;
      function HShapeElement(e, t, r) {
          this.shapes = [],
          this.shapesData = e.shapes,
          this.stylesList = [],
          this.shapeModifiers = [],
          this.itemsData = [],
          this.processedElements = [],
          this.animatedContents = [],
          this.shapesContainer = createNS("g"),
          this.initElement(e, t, r),
          this.prevViewData = [],
          this.currentBBox = {
              x: 999999,
              y: -999999,
              h: 0,
              w: 0
          }
      }
      extendPrototype([BaseElement, TransformElement, HSolidElement, SVGShapeElement, HBaseElement, HierarchyElement, FrameElement, RenderableElement], HShapeElement),
      HShapeElement.prototype._renderShapeFrame = HShapeElement.prototype.renderInnerContent,
      HShapeElement.prototype.createContent = function() {
          var e;
          if (this.baseElement.style.fontSize = 0,
          this.data.hasMask)
              this.layerElement.appendChild(this.shapesContainer),
              e = this.svgElement;
          else {
              e = createNS("svg");
              var t = this.comp.data ? this.comp.data : this.globalData.compSize;
              e.setAttribute("width", t.w),
              e.setAttribute("height", t.h),
              e.appendChild(this.shapesContainer),
              this.layerElement.appendChild(e)
          }
          this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.shapesContainer, 0, [], !0),
          this.filterUniqueShapes(),
          this.shapeCont = e
      }
      ,
      HShapeElement.prototype.getTransformedPoint = function(e, t) {
          var r, a = e.length;
          for (r = 0; r < a; r += 1)
              t = e[r].mProps.v.applyToPointArray(t[0], t[1], 0);
          return t
      }
      ,
      HShapeElement.prototype.calculateShapeBoundingBox = function(e, t) {
          var r = e.sh.v, a = e.transformers, o, l = r._length, f, d, g, _;
          if (!(l <= 1)) {
              for (o = 0; o < l - 1; o += 1)
                  f = this.getTransformedPoint(a, r.v[o]),
                  d = this.getTransformedPoint(a, r.o[o]),
                  g = this.getTransformedPoint(a, r.i[o + 1]),
                  _ = this.getTransformedPoint(a, r.v[o + 1]),
                  this.checkBounds(f, d, g, _, t);
              r.c && (f = this.getTransformedPoint(a, r.v[o]),
              d = this.getTransformedPoint(a, r.o[o]),
              g = this.getTransformedPoint(a, r.i[0]),
              _ = this.getTransformedPoint(a, r.v[0]),
              this.checkBounds(f, d, g, _, t))
          }
      }
      ,
      HShapeElement.prototype.checkBounds = function(e, t, r, a, o) {
          this.getBoundsOfCurve(e, t, r, a);
          var l = this.shapeBoundingBox;
          o.x = bmMin(l.left, o.x),
          o.xMax = bmMax(l.right, o.xMax),
          o.y = bmMin(l.top, o.y),
          o.yMax = bmMax(l.bottom, o.yMax)
      }
      ,
      HShapeElement.prototype.shapeBoundingBox = {
          left: 0,
          right: 0,
          top: 0,
          bottom: 0
      },
      HShapeElement.prototype.tempBoundingBox = {
          x: 0,
          xMax: 0,
          y: 0,
          yMax: 0,
          width: 0,
          height: 0
      },
      HShapeElement.prototype.getBoundsOfCurve = function(e, t, r, a) {
          for (var o = [[e[0], a[0]], [e[1], a[1]]], l, f, d, g, _, v, S, b = 0; b < 2; ++b)
              f = 6 * e[b] - 12 * t[b] + 6 * r[b],
              l = -3 * e[b] + 9 * t[b] - 9 * r[b] + 3 * a[b],
              d = 3 * t[b] - 3 * e[b],
              f |= 0,
              l |= 0,
              d |= 0,
              l === 0 && f === 0 || (l === 0 ? (g = -d / f,
              g > 0 && g < 1 && o[b].push(this.calculateF(g, e, t, r, a, b))) : (_ = f * f - 4 * d * l,
              _ >= 0 && (v = (-f + bmSqrt(_)) / (2 * l),
              v > 0 && v < 1 && o[b].push(this.calculateF(v, e, t, r, a, b)),
              S = (-f - bmSqrt(_)) / (2 * l),
              S > 0 && S < 1 && o[b].push(this.calculateF(S, e, t, r, a, b)))));
          this.shapeBoundingBox.left = bmMin.apply(null, o[0]),
          this.shapeBoundingBox.top = bmMin.apply(null, o[1]),
          this.shapeBoundingBox.right = bmMax.apply(null, o[0]),
          this.shapeBoundingBox.bottom = bmMax.apply(null, o[1])
      }
      ,
      HShapeElement.prototype.calculateF = function(e, t, r, a, o, l) {
          return bmPow(1 - e, 3) * t[l] + 3 * bmPow(1 - e, 2) * e * r[l] + 3 * (1 - e) * bmPow(e, 2) * a[l] + bmPow(e, 3) * o[l]
      }
      ,
      HShapeElement.prototype.calculateBoundingBox = function(e, t) {
          var r, a = e.length;
          for (r = 0; r < a; r += 1)
              e[r] && e[r].sh ? this.calculateShapeBoundingBox(e[r], t) : e[r] && e[r].it ? this.calculateBoundingBox(e[r].it, t) : e[r] && e[r].style && e[r].w && this.expandStrokeBoundingBox(e[r].w, t)
      }
      ,
      HShapeElement.prototype.expandStrokeBoundingBox = function(e, t) {
          var r = 0;
          if (e.keyframes) {
              for (var a = 0; a < e.keyframes.length; a += 1) {
                  var o = e.keyframes[a].s;
                  o > r && (r = o)
              }
              r *= e.mult
          } else
              r = e.v * e.mult;
          t.x -= r,
          t.xMax += r,
          t.y -= r,
          t.yMax += r
      }
      ,
      HShapeElement.prototype.currentBoxContains = function(e) {
          return this.currentBBox.x <= e.x && this.currentBBox.y <= e.y && this.currentBBox.width + this.currentBBox.x >= e.x + e.width && this.currentBBox.height + this.currentBBox.y >= e.y + e.height
      }
      ,
      HShapeElement.prototype.renderInnerContent = function() {
          if (this._renderShapeFrame(),
          !this.hidden && (this._isFirstFrame || this._mdf)) {
              var e = this.tempBoundingBox
                , t = 999999;
              if (e.x = t,
              e.xMax = -t,
              e.y = t,
              e.yMax = -t,
              this.calculateBoundingBox(this.itemsData, e),
              e.width = e.xMax < e.x ? 0 : e.xMax - e.x,
              e.height = e.yMax < e.y ? 0 : e.yMax - e.y,
              this.currentBoxContains(e))
                  return;
              var r = !1;
              if (this.currentBBox.w !== e.width && (this.currentBBox.w = e.width,
              this.shapeCont.setAttribute("width", e.width),
              r = !0),
              this.currentBBox.h !== e.height && (this.currentBBox.h = e.height,
              this.shapeCont.setAttribute("height", e.height),
              r = !0),
              r || this.currentBBox.x !== e.x || this.currentBBox.y !== e.y) {
                  this.currentBBox.w = e.width,
                  this.currentBBox.h = e.height,
                  this.currentBBox.x = e.x,
                  this.currentBBox.y = e.y,
                  this.shapeCont.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h);
                  var a = this.shapeCont.style
                    , o = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)";
                  a.transform = o,
                  a.webkitTransform = o
              }
          }
      }
      ;
      function HTextElement(e, t, r) {
          this.textSpans = [],
          this.textPaths = [],
          this.currentBBox = {
              x: 999999,
              y: -999999,
              h: 0,
              w: 0
          },
          this.renderType = "svg",
          this.isMasked = !1,
          this.initElement(e, t, r)
      }
      extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], HTextElement),
      HTextElement.prototype.createContent = function() {
          if (this.isMasked = this.checkMasks(),
          this.isMasked) {
              this.renderType = "svg",
              this.compW = this.comp.data.w,
              this.compH = this.comp.data.h,
              this.svgElement.setAttribute("width", this.compW),
              this.svgElement.setAttribute("height", this.compH);
              var e = createNS("g");
              this.maskedElement.appendChild(e),
              this.innerElem = e
          } else
              this.renderType = "html",
              this.innerElem = this.layerElement;
          this.checkParenting()
      }
      ,
      HTextElement.prototype.buildNewText = function() {
          var e = this.textProperty.currentData;
          this.renderedLetters = createSizedArray(e.l ? e.l.length : 0);
          var t = this.innerElem.style
            , r = e.fc ? this.buildColor(e.fc) : "rgba(0,0,0,0)";
          t.fill = r,
          t.color = r,
          e.sc && (t.stroke = this.buildColor(e.sc),
          t.strokeWidth = e.sw + "px");
          var a = this.globalData.fontManager.getFontByName(e.f);
          if (!this.globalData.fontManager.chars)
              if (t.fontSize = e.finalSize + "px",
              t.lineHeight = e.finalSize + "px",
              a.fClass)
                  this.innerElem.className = a.fClass;
              else {
                  t.fontFamily = a.fFamily;
                  var o = e.fWeight
                    , l = e.fStyle;
                  t.fontStyle = l,
                  t.fontWeight = o
              }
          var f, d, g = e.l;
          d = g.length;
          var _, v, S, b = this.mHelper, P, x = "", E = 0;
          for (f = 0; f < d; f += 1) {
              if (this.globalData.fontManager.chars ? (this.textPaths[E] ? _ = this.textPaths[E] : (_ = createNS("path"),
              _.setAttribute("stroke-linecap", lineCapEnum[1]),
              _.setAttribute("stroke-linejoin", lineJoinEnum[2]),
              _.setAttribute("stroke-miterlimit", "4")),
              this.isMasked || (this.textSpans[E] ? (v = this.textSpans[E],
              S = v.children[0]) : (v = createTag("div"),
              v.style.lineHeight = 0,
              S = createNS("svg"),
              S.appendChild(_),
              styleDiv(v)))) : this.isMasked ? _ = this.textPaths[E] ? this.textPaths[E] : createNS("text") : this.textSpans[E] ? (v = this.textSpans[E],
              _ = this.textPaths[E]) : (v = createTag("span"),
              styleDiv(v),
              _ = createTag("span"),
              styleDiv(_),
              v.appendChild(_)),
              this.globalData.fontManager.chars) {
                  var I = this.globalData.fontManager.getCharData(e.finalText[f], a.fStyle, this.globalData.fontManager.getFontByName(e.f).fFamily), C;
                  if (I ? C = I.data : C = null,
                  b.reset(),
                  C && C.shapes && C.shapes.length && (P = C.shapes[0].it,
                  b.scale(e.finalSize / 100, e.finalSize / 100),
                  x = this.createPathShape(b, P),
                  _.setAttribute("d", x)),
                  this.isMasked)
                      this.innerElem.appendChild(_);
                  else {
                      if (this.innerElem.appendChild(v),
                      C && C.shapes) {
                          document.body.appendChild(S);
                          var A = S.getBBox();
                          S.setAttribute("width", A.width + 2),
                          S.setAttribute("height", A.height + 2),
                          S.setAttribute("viewBox", A.x - 1 + " " + (A.y - 1) + " " + (A.width + 2) + " " + (A.height + 2));
                          var T = S.style
                            , w = "translate(" + (A.x - 1) + "px," + (A.y - 1) + "px)";
                          T.transform = w,
                          T.webkitTransform = w,
                          g[f].yOffset = A.y - 1
                      } else
                          S.setAttribute("width", 1),
                          S.setAttribute("height", 1);
                      v.appendChild(S)
                  }
              } else if (_.textContent = g[f].val,
              _.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"),
              this.isMasked)
                  this.innerElem.appendChild(_);
              else {
                  this.innerElem.appendChild(v);
                  var M = _.style
                    , F = "translate3d(0," + -e.finalSize / 1.2 + "px,0)";
                  M.transform = F,
                  M.webkitTransform = F
              }
              this.isMasked ? this.textSpans[E] = _ : this.textSpans[E] = v,
              this.textSpans[E].style.display = "block",
              this.textPaths[E] = _,
              E += 1
          }
          for (; E < this.textSpans.length; )
              this.textSpans[E].style.display = "none",
              E += 1
      }
      ,
      HTextElement.prototype.renderInnerContent = function() {
          this.validateText();
          var e;
          if (this.data.singleShape) {
              if (!this._isFirstFrame && !this.lettersChangedFlag)
                  return;
              if (this.isMasked && this.finalTransform._matMdf) {
                  this.svgElement.setAttribute("viewBox", -this.finalTransform.mProp.p.v[0] + " " + -this.finalTransform.mProp.p.v[1] + " " + this.compW + " " + this.compH),
                  e = this.svgElement.style;
                  var t = "translate(" + -this.finalTransform.mProp.p.v[0] + "px," + -this.finalTransform.mProp.p.v[1] + "px)";
                  e.transform = t,
                  e.webkitTransform = t
              }
          }
          if (this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag),
          !(!this.lettersChangedFlag && !this.textAnimator.lettersChangedFlag)) {
              var r, a, o = 0, l = this.textAnimator.renderedLetters, f = this.textProperty.currentData.l;
              a = f.length;
              var d, g, _;
              for (r = 0; r < a; r += 1)
                  f[r].n ? o += 1 : (g = this.textSpans[r],
                  _ = this.textPaths[r],
                  d = l[o],
                  o += 1,
                  d._mdf.m && (this.isMasked ? g.setAttribute("transform", d.m) : (g.style.webkitTransform = d.m,
                  g.style.transform = d.m)),
                  g.style.opacity = d.o,
                  d.sw && d._mdf.sw && _.setAttribute("stroke-width", d.sw),
                  d.sc && d._mdf.sc && _.setAttribute("stroke", d.sc),
                  d.fc && d._mdf.fc && (_.setAttribute("fill", d.fc),
                  _.style.color = d.fc));
              if (this.innerElem.getBBox && !this.hidden && (this._isFirstFrame || this._mdf)) {
                  var v = this.innerElem.getBBox();
                  this.currentBBox.w !== v.width && (this.currentBBox.w = v.width,
                  this.svgElement.setAttribute("width", v.width)),
                  this.currentBBox.h !== v.height && (this.currentBBox.h = v.height,
                  this.svgElement.setAttribute("height", v.height));
                  var S = 1;
                  if (this.currentBBox.w !== v.width + S * 2 || this.currentBBox.h !== v.height + S * 2 || this.currentBBox.x !== v.x - S || this.currentBBox.y !== v.y - S) {
                      this.currentBBox.w = v.width + S * 2,
                      this.currentBBox.h = v.height + S * 2,
                      this.currentBBox.x = v.x - S,
                      this.currentBBox.y = v.y - S,
                      this.svgElement.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h),
                      e = this.svgElement.style;
                      var b = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)";
                      e.transform = b,
                      e.webkitTransform = b
                  }
              }
          }
      }
      ;
      function HCameraElement(e, t, r) {
          this.initFrame(),
          this.initBaseData(e, t, r),
          this.initHierarchy();
          var a = PropertyFactory.getProp;
          if (this.pe = a(this, e.pe, 0, 0, this),
          e.ks.p.s ? (this.px = a(this, e.ks.p.x, 1, 0, this),
          this.py = a(this, e.ks.p.y, 1, 0, this),
          this.pz = a(this, e.ks.p.z, 1, 0, this)) : this.p = a(this, e.ks.p, 1, 0, this),
          e.ks.a && (this.a = a(this, e.ks.a, 1, 0, this)),
          e.ks.or.k.length && e.ks.or.k[0].to) {
              var o, l = e.ks.or.k.length;
              for (o = 0; o < l; o += 1)
                  e.ks.or.k[o].to = null,
                  e.ks.or.k[o].ti = null
          }
          this.or = a(this, e.ks.or, 1, degToRads, this),
          this.or.sh = !0,
          this.rx = a(this, e.ks.rx, 0, degToRads, this),
          this.ry = a(this, e.ks.ry, 0, degToRads, this),
          this.rz = a(this, e.ks.rz, 0, degToRads, this),
          this.mat = new Matrix,
          this._prevMat = new Matrix,
          this._isFirstFrame = !0,
          this.finalTransform = {
              mProp: this
          }
      }
      extendPrototype([BaseElement, FrameElement, HierarchyElement], HCameraElement),
      HCameraElement.prototype.setup = function() {
          var e, t = this.comp.threeDElements.length, r, a, o;
          for (e = 0; e < t; e += 1)
              if (r = this.comp.threeDElements[e],
              r.type === "3d") {
                  a = r.perspectiveElem.style,
                  o = r.container.style;
                  var l = this.pe.v + "px"
                    , f = "0px 0px 0px"
                    , d = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
                  a.perspective = l,
                  a.webkitPerspective = l,
                  o.transformOrigin = f,
                  o.mozTransformOrigin = f,
                  o.webkitTransformOrigin = f,
                  a.transform = d,
                  a.webkitTransform = d
              }
      }
      ,
      HCameraElement.prototype.createElements = function() {}
      ,
      HCameraElement.prototype.hide = function() {}
      ,
      HCameraElement.prototype.renderFrame = function() {
          var e = this._isFirstFrame, t, r;
          if (this.hierarchy)
              for (r = this.hierarchy.length,
              t = 0; t < r; t += 1)
                  e = this.hierarchy[t].finalTransform.mProp._mdf || e;
          if (e || this.pe._mdf || this.p && this.p._mdf || this.px && (this.px._mdf || this.py._mdf || this.pz._mdf) || this.rx._mdf || this.ry._mdf || this.rz._mdf || this.or._mdf || this.a && this.a._mdf) {
              if (this.mat.reset(),
              this.hierarchy)
                  for (r = this.hierarchy.length - 1,
                  t = r; t >= 0; t -= 1) {
                      var a = this.hierarchy[t].finalTransform.mProp;
                      this.mat.translate(-a.p.v[0], -a.p.v[1], a.p.v[2]),
                      this.mat.rotateX(-a.or.v[0]).rotateY(-a.or.v[1]).rotateZ(a.or.v[2]),
                      this.mat.rotateX(-a.rx.v).rotateY(-a.ry.v).rotateZ(a.rz.v),
                      this.mat.scale(1 / a.s.v[0], 1 / a.s.v[1], 1 / a.s.v[2]),
                      this.mat.translate(a.a.v[0], a.a.v[1], a.a.v[2])
                  }
              if (this.p ? this.mat.translate(-this.p.v[0], -this.p.v[1], this.p.v[2]) : this.mat.translate(-this.px.v, -this.py.v, this.pz.v),
              this.a) {
                  var o;
                  this.p ? o = [this.p.v[0] - this.a.v[0], this.p.v[1] - this.a.v[1], this.p.v[2] - this.a.v[2]] : o = [this.px.v - this.a.v[0], this.py.v - this.a.v[1], this.pz.v - this.a.v[2]];
                  var l = Math.sqrt(Math.pow(o[0], 2) + Math.pow(o[1], 2) + Math.pow(o[2], 2))
                    , f = [o[0] / l, o[1] / l, o[2] / l]
                    , d = Math.sqrt(f[2] * f[2] + f[0] * f[0])
                    , g = Math.atan2(f[1], d)
                    , _ = Math.atan2(f[0], -f[2]);
                  this.mat.rotateY(_).rotateX(-g)
              }
              this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v),
              this.mat.rotateX(-this.or.v[0]).rotateY(-this.or.v[1]).rotateZ(this.or.v[2]),
              this.mat.translate(this.globalData.compSize.w / 2, this.globalData.compSize.h / 2, 0),
              this.mat.translate(0, 0, this.pe.v);
              var v = !this._prevMat.equals(this.mat);
              if ((v || this.pe._mdf) && this.comp.threeDElements) {
                  r = this.comp.threeDElements.length;
                  var S, b, P;
                  for (t = 0; t < r; t += 1)
                      if (S = this.comp.threeDElements[t],
                      S.type === "3d") {
                          if (v) {
                              var x = this.mat.toCSS();
                              P = S.container.style,
                              P.transform = x,
                              P.webkitTransform = x
                          }
                          this.pe._mdf && (b = S.perspectiveElem.style,
                          b.perspective = this.pe.v + "px",
                          b.webkitPerspective = this.pe.v + "px")
                      }
                  this.mat.clone(this._prevMat)
              }
          }
          this._isFirstFrame = !1
      }
      ,
      HCameraElement.prototype.prepareFrame = function(e) {
          this.prepareProperties(e, !0)
      }
      ,
      HCameraElement.prototype.destroy = function() {}
      ,
      HCameraElement.prototype.getBaseElement = function() {
          return null
      }
      ;
      function HImageElement(e, t, r) {
          this.assetData = t.getAssetData(e.refId),
          this.initElement(e, t, r)
      }
      extendPrototype([BaseElement, TransformElement, HBaseElement, HSolidElement, HierarchyElement, FrameElement, RenderableElement], HImageElement),
      HImageElement.prototype.createContent = function() {
          var e = this.globalData.getAssetsPath(this.assetData)
            , t = new Image;
          this.data.hasMask ? (this.imageElem = createNS("image"),
          this.imageElem.setAttribute("width", this.assetData.w + "px"),
          this.imageElem.setAttribute("height", this.assetData.h + "px"),
          this.imageElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", e),
          this.layerElement.appendChild(this.imageElem),
          this.baseElement.setAttribute("width", this.assetData.w),
          this.baseElement.setAttribute("height", this.assetData.h)) : this.layerElement.appendChild(t),
          t.crossOrigin = "anonymous",
          t.src = e,
          this.data.ln && this.baseElement.setAttribute("id", this.data.ln)
      }
      ;
      function HybridRendererBase(e, t) {
          this.animationItem = e,
          this.layers = null,
          this.renderedFrame = -1,
          this.renderConfig = {
              className: t && t.className || "",
              imagePreserveAspectRatio: t && t.imagePreserveAspectRatio || "xMidYMid slice",
              hideOnTransparent: !(t && t.hideOnTransparent === !1),
              filterSize: {
                  width: t && t.filterSize && t.filterSize.width || "400%",
                  height: t && t.filterSize && t.filterSize.height || "400%",
                  x: t && t.filterSize && t.filterSize.x || "-100%",
                  y: t && t.filterSize && t.filterSize.y || "-100%"
              }
          },
          this.globalData = {
              _mdf: !1,
              frameNum: -1,
              renderConfig: this.renderConfig
          },
          this.pendingElements = [],
          this.elements = [],
          this.threeDElements = [],
          this.destroyed = !1,
          this.camera = null,
          this.supports3d = !0,
          this.rendererType = "html"
      }
      extendPrototype([BaseRenderer], HybridRendererBase),
      HybridRendererBase.prototype.buildItem = SVGRenderer.prototype.buildItem,
      HybridRendererBase.prototype.checkPendingElements = function() {
          for (; this.pendingElements.length; ) {
              var e = this.pendingElements.pop();
              e.checkParenting()
          }
      }
      ,
      HybridRendererBase.prototype.appendElementInPos = function(e, t) {
          var r = e.getBaseElement();
          if (r) {
              var a = this.layers[t];
              if (!a.ddd || !this.supports3d)
                  if (this.threeDElements)
                      this.addTo3dContainer(r, t);
                  else {
                      for (var o = 0, l, f, d; o < t; )
                          this.elements[o] && this.elements[o] !== !0 && this.elements[o].getBaseElement && (f = this.elements[o],
                          d = this.layers[o].ddd ? this.getThreeDContainerByPos(o) : f.getBaseElement(),
                          l = d || l),
                          o += 1;
                      l ? (!a.ddd || !this.supports3d) && this.layerElement.insertBefore(r, l) : (!a.ddd || !this.supports3d) && this.layerElement.appendChild(r)
                  }
              else
                  this.addTo3dContainer(r, t)
          }
      }
      ,
      HybridRendererBase.prototype.createShape = function(e) {
          return this.supports3d ? new HShapeElement(e,this.globalData,this) : new SVGShapeElement(e,this.globalData,this)
      }
      ,
      HybridRendererBase.prototype.createText = function(e) {
          return this.supports3d ? new HTextElement(e,this.globalData,this) : new SVGTextLottieElement(e,this.globalData,this)
      }
      ,
      HybridRendererBase.prototype.createCamera = function(e) {
          return this.camera = new HCameraElement(e,this.globalData,this),
          this.camera
      }
      ,
      HybridRendererBase.prototype.createImage = function(e) {
          return this.supports3d ? new HImageElement(e,this.globalData,this) : new IImageElement(e,this.globalData,this)
      }
      ,
      HybridRendererBase.prototype.createSolid = function(e) {
          return this.supports3d ? new HSolidElement(e,this.globalData,this) : new ISolidElement(e,this.globalData,this)
      }
      ,
      HybridRendererBase.prototype.createNull = SVGRenderer.prototype.createNull,
      HybridRendererBase.prototype.getThreeDContainerByPos = function(e) {
          for (var t = 0, r = this.threeDElements.length; t < r; ) {
              if (this.threeDElements[t].startPos <= e && this.threeDElements[t].endPos >= e)
                  return this.threeDElements[t].perspectiveElem;
              t += 1
          }
          return null
      }
      ,
      HybridRendererBase.prototype.createThreeDContainer = function(e, t) {
          var r = createTag("div"), a, o;
          styleDiv(r);
          var l = createTag("div");
          if (styleDiv(l),
          t === "3d") {
              a = r.style,
              a.width = this.globalData.compSize.w + "px",
              a.height = this.globalData.compSize.h + "px";
              var f = "50% 50%";
              a.webkitTransformOrigin = f,
              a.mozTransformOrigin = f,
              a.transformOrigin = f,
              o = l.style;
              var d = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
              o.transform = d,
              o.webkitTransform = d
          }
          r.appendChild(l);
          var g = {
              container: l,
              perspectiveElem: r,
              startPos: e,
              endPos: e,
              type: t
          };
          return this.threeDElements.push(g),
          g
      }
      ,
      HybridRendererBase.prototype.build3dContainers = function() {
          var e, t = this.layers.length, r, a = "";
          for (e = 0; e < t; e += 1)
              this.layers[e].ddd && this.layers[e].ty !== 3 ? (a !== "3d" && (a = "3d",
              r = this.createThreeDContainer(e, "3d")),
              r.endPos = Math.max(r.endPos, e)) : (a !== "2d" && (a = "2d",
              r = this.createThreeDContainer(e, "2d")),
              r.endPos = Math.max(r.endPos, e));
          for (t = this.threeDElements.length,
          e = t - 1; e >= 0; e -= 1)
              this.resizerElem.appendChild(this.threeDElements[e].perspectiveElem)
      }
      ,
      HybridRendererBase.prototype.addTo3dContainer = function(e, t) {
          for (var r = 0, a = this.threeDElements.length; r < a; ) {
              if (t <= this.threeDElements[r].endPos) {
                  for (var o = this.threeDElements[r].startPos, l; o < t; )
                      this.elements[o] && this.elements[o].getBaseElement && (l = this.elements[o].getBaseElement()),
                      o += 1;
                  l ? this.threeDElements[r].container.insertBefore(e, l) : this.threeDElements[r].container.appendChild(e);
                  break
              }
              r += 1
          }
      }
      ,
      HybridRendererBase.prototype.configAnimation = function(e) {
          var t = createTag("div")
            , r = this.animationItem.wrapper
            , a = t.style;
          a.width = e.w + "px",
          a.height = e.h + "px",
          this.resizerElem = t,
          styleDiv(t),
          a.transformStyle = "flat",
          a.mozTransformStyle = "flat",
          a.webkitTransformStyle = "flat",
          this.renderConfig.className && t.setAttribute("class", this.renderConfig.className),
          r.appendChild(t),
          a.overflow = "hidden";
          var o = createNS("svg");
          o.setAttribute("width", "1"),
          o.setAttribute("height", "1"),
          styleDiv(o),
          this.resizerElem.appendChild(o);
          var l = createNS("defs");
          o.appendChild(l),
          this.data = e,
          this.setupGlobalData(e, o),
          this.globalData.defs = l,
          this.layers = e.layers,
          this.layerElement = this.resizerElem,
          this.build3dContainers(),
          this.updateContainerSize()
      }
      ,
      HybridRendererBase.prototype.destroy = function() {
          this.animationItem.wrapper && (this.animationItem.wrapper.innerText = ""),
          this.animationItem.container = null,
          this.globalData.defs = null;
          var e, t = this.layers ? this.layers.length : 0;
          for (e = 0; e < t; e += 1)
              this.elements[e] && this.elements[e].destroy && this.elements[e].destroy();
          this.elements.length = 0,
          this.destroyed = !0,
          this.animationItem = null
      }
      ,
      HybridRendererBase.prototype.updateContainerSize = function() {
          var e = this.animationItem.wrapper.offsetWidth, t = this.animationItem.wrapper.offsetHeight, r = e / t, a = this.globalData.compSize.w / this.globalData.compSize.h, o, l, f, d;
          a > r ? (o = e / this.globalData.compSize.w,
          l = e / this.globalData.compSize.w,
          f = 0,
          d = (t - this.globalData.compSize.h * (e / this.globalData.compSize.w)) / 2) : (o = t / this.globalData.compSize.h,
          l = t / this.globalData.compSize.h,
          f = (e - this.globalData.compSize.w * (t / this.globalData.compSize.h)) / 2,
          d = 0);
          var g = this.resizerElem.style;
          g.webkitTransform = "matrix3d(" + o + ",0,0,0,0," + l + ",0,0,0,0,1,0," + f + "," + d + ",0,1)",
          g.transform = g.webkitTransform
      }
      ,
      HybridRendererBase.prototype.renderFrame = SVGRenderer.prototype.renderFrame,
      HybridRendererBase.prototype.hide = function() {
          this.resizerElem.style.display = "none"
      }
      ,
      HybridRendererBase.prototype.show = function() {
          this.resizerElem.style.display = "block"
      }
      ,
      HybridRendererBase.prototype.initItems = function() {
          if (this.buildAllItems(),
          this.camera)
              this.camera.setup();
          else {
              var e = this.globalData.compSize.w, t = this.globalData.compSize.h, r, a = this.threeDElements.length;
              for (r = 0; r < a; r += 1) {
                  var o = this.threeDElements[r].perspectiveElem.style;
                  o.webkitPerspective = Math.sqrt(Math.pow(e, 2) + Math.pow(t, 2)) + "px",
                  o.perspective = o.webkitPerspective
              }
          }
      }
      ,
      HybridRendererBase.prototype.searchExtraCompositions = function(e) {
          var t, r = e.length, a = createTag("div");
          for (t = 0; t < r; t += 1)
              if (e[t].xt) {
                  var o = this.createComp(e[t], a, this.globalData.comp, null);
                  o.initExpressions(),
                  this.globalData.projectInterface.registerComposition(o)
              }
      }
      ;
      function HCompElement(e, t, r) {
          this.layers = e.layers,
          this.supports3d = !e.hasMask,
          this.completeLayers = !1,
          this.pendingElements = [],
          this.elements = this.layers ? createSizedArray(this.layers.length) : [],
          this.initElement(e, t, r),
          this.tm = e.tm ? PropertyFactory.getProp(this, e.tm, 0, t.frameRate, this) : {
              _placeholder: !0
          }
      }
      extendPrototype([HybridRendererBase, ICompElement, HBaseElement], HCompElement),
      HCompElement.prototype._createBaseContainerElements = HCompElement.prototype.createContainerElements,
      HCompElement.prototype.createContainerElements = function() {
          this._createBaseContainerElements(),
          this.data.hasMask ? (this.svgElement.setAttribute("width", this.data.w),
          this.svgElement.setAttribute("height", this.data.h),
          this.transformedElement = this.baseElement) : this.transformedElement = this.layerElement
      }
      ,
      HCompElement.prototype.addTo3dContainer = function(e, t) {
          for (var r = 0, a; r < t; )
              this.elements[r] && this.elements[r].getBaseElement && (a = this.elements[r].getBaseElement()),
              r += 1;
          a ? this.layerElement.insertBefore(e, a) : this.layerElement.appendChild(e)
      }
      ,
      HCompElement.prototype.createComp = function(e) {
          return this.supports3d ? new HCompElement(e,this.globalData,this) : new SVGCompElement(e,this.globalData,this)
      }
      ;
      function HybridRenderer(e, t) {
          this.animationItem = e,
          this.layers = null,
          this.renderedFrame = -1,
          this.renderConfig = {
              className: t && t.className || "",
              imagePreserveAspectRatio: t && t.imagePreserveAspectRatio || "xMidYMid slice",
              hideOnTransparent: !(t && t.hideOnTransparent === !1),
              filterSize: {
                  width: t && t.filterSize && t.filterSize.width || "400%",
                  height: t && t.filterSize && t.filterSize.height || "400%",
                  x: t && t.filterSize && t.filterSize.x || "-100%",
                  y: t && t.filterSize && t.filterSize.y || "-100%"
              },
              runExpressions: !t || t.runExpressions === void 0 || t.runExpressions
          },
          this.globalData = {
              _mdf: !1,
              frameNum: -1,
              renderConfig: this.renderConfig
          },
          this.pendingElements = [],
          this.elements = [],
          this.threeDElements = [],
          this.destroyed = !1,
          this.camera = null,
          this.supports3d = !0,
          this.rendererType = "html"
      }
      extendPrototype([HybridRendererBase], HybridRenderer),
      HybridRenderer.prototype.createComp = function(e) {
          return this.supports3d ? new HCompElement(e,this.globalData,this) : new SVGCompElement(e,this.globalData,this)
      }
      ;
      var CompExpressionInterface = function() {
          return function(e) {
              function t(r) {
                  for (var a = 0, o = e.layers.length; a < o; ) {
                      if (e.layers[a].nm === r || e.layers[a].ind === r)
                          return e.elements[a].layerInterface;
                      a += 1
                  }
                  return null
              }
              return Object.defineProperty(t, "_name", {
                  value: e.data.nm
              }),
              t.layer = t,
              t.pixelAspect = 1,
              t.height = e.data.h || e.globalData.compSize.h,
              t.width = e.data.w || e.globalData.compSize.w,
              t.pixelAspect = 1,
              t.frameDuration = 1 / e.globalData.frameRate,
              t.displayStartTime = 0,
              t.numLayers = e.layers.length,
              t
          }
      }();
      function _typeof$2(e) {
          "@babel/helpers - typeof";
          return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$2 = function(r) {
              return typeof r
          }
          : _typeof$2 = function(r) {
              return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r
          }
          ,
          _typeof$2(e)
      }
      function seedRandom(e, t) {
          var r = this, a = 256, o = 6, l = 52, f = "random", d = t.pow(a, o), g = t.pow(2, l), _ = g * 2, v = a - 1, S;
          function b(T, w, M) {
              var F = [];
              w = w === !0 ? {
                  entropy: !0
              } : w || {};
              var O = I(E(w.entropy ? [T, A(e)] : T === null ? C() : T, 3), F)
                , $ = new P(F)
                , j = function() {
                  for (var Y = $.g(o), W = d, Z = 0; Y < g; )
                      Y = (Y + Z) * a,
                      W *= a,
                      Z = $.g(1);
                  for (; Y >= _; )
                      Y /= 2,
                      W /= 2,
                      Z >>>= 1;
                  return (Y + Z) / W
              };
              return j.int32 = function() {
                  return $.g(4) | 0
              }
              ,
              j.quick = function() {
                  return $.g(4) / 4294967296
              }
              ,
              j.double = j,
              I(A($.S), e),
              (w.pass || M || function(K, Y, W, Z) {
                  return Z && (Z.S && x(Z, $),
                  K.state = function() {
                      return x($, {})
                  }
                  ),
                  W ? (t[f] = K,
                  Y) : K
              }
              )(j, O, "global"in w ? w.global : this == t, w.state)
          }
          t["seed" + f] = b;
          function P(T) {
              var w, M = T.length, F = this, O = 0, $ = F.i = F.j = 0, j = F.S = [];
              for (M || (T = [M++]); O < a; )
                  j[O] = O++;
              for (O = 0; O < a; O++)
                  j[O] = j[$ = v & $ + T[O % M] + (w = j[O])],
                  j[$] = w;
              F.g = function(K) {
                  for (var Y, W = 0, Z = F.i, ee = F.j, X = F.S; K--; )
                      Y = X[Z = v & Z + 1],
                      W = W * a + X[v & (X[Z] = X[ee = v & ee + Y]) + (X[ee] = Y)];
                  return F.i = Z,
                  F.j = ee,
                  W
              }
          }
          function x(T, w) {
              return w.i = T.i,
              w.j = T.j,
              w.S = T.S.slice(),
              w
          }
          function E(T, w) {
              var M = [], F = _typeof$2(T), O;
              if (w && F == "object")
                  for (O in T)
                      try {
                          M.push(E(T[O], w - 1))
                      } catch {}
              return M.length ? M : F == "string" ? T : T + "\0"
          }
          function I(T, w) {
              for (var M = T + "", F, O = 0; O < M.length; )
                  w[v & O] = v & (F ^= w[v & O] * 19) + M.charCodeAt(O++);
              return A(w)
          }
          function C() {
              try {
                  var T = new Uint8Array(a);
                  return (r.crypto || r.msCrypto).getRandomValues(T),
                  A(T)
              } catch {
                  var w = r.navigator
                    , M = w && w.plugins;
                  return [+new Date, r, M, r.screen, A(e)]
              }
          }
          function A(T) {
              return String.fromCharCode.apply(0, T)
          }
          I(t.random(), e)
      }
      function initialize$2(e) {
          seedRandom([], e)
      }
      var propTypes = {
          SHAPE: "shape"
      };
      function _typeof$1(e) {
          "@babel/helpers - typeof";
          return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$1 = function(r) {
              return typeof r
          }
          : _typeof$1 = function(r) {
              return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r
          }
          ,
          _typeof$1(e)
      }
      var ExpressionManager = function() {
          var ob = {}
            , Math = BMMath
            , window = null
            , document = null
            , XMLHttpRequest = null
            , fetch = null
            , frames = null
            , _lottieGlobal = {};
          initialize$2(BMMath);
          function resetFrame() {
              _lottieGlobal = {}
          }
          function $bm_isInstanceOfArray(e) {
              return e.constructor === Array || e.constructor === Float32Array
          }
          function isNumerable(e, t) {
              return e === "number" || t instanceof Number || e === "boolean" || e === "string"
          }
          function $bm_neg(e) {
              var t = _typeof$1(e);
              if (t === "number" || e instanceof Number || t === "boolean")
                  return -e;
              if ($bm_isInstanceOfArray(e)) {
                  var r, a = e.length, o = [];
                  for (r = 0; r < a; r += 1)
                      o[r] = -e[r];
                  return o
              }
              return e.propType ? e.v : -e
          }
          var easeInBez = BezierFactory.getBezierEasing(.333, 0, .833, .833, "easeIn").get
            , easeOutBez = BezierFactory.getBezierEasing(.167, .167, .667, 1, "easeOut").get
            , easeInOutBez = BezierFactory.getBezierEasing(.33, 0, .667, 1, "easeInOut").get;
          function sum(e, t) {
              var r = _typeof$1(e)
                , a = _typeof$1(t);
              if (isNumerable(r, e) && isNumerable(a, t) || r === "string" || a === "string")
                  return e + t;
              if ($bm_isInstanceOfArray(e) && isNumerable(a, t))
                  return e = e.slice(0),
                  e[0] += t,
                  e;
              if (isNumerable(r, e) && $bm_isInstanceOfArray(t))
                  return t = t.slice(0),
                  t[0] = e + t[0],
                  t;
              if ($bm_isInstanceOfArray(e) && $bm_isInstanceOfArray(t)) {
                  for (var o = 0, l = e.length, f = t.length, d = []; o < l || o < f; )
                      (typeof e[o] == "number" || e[o]instanceof Number) && (typeof t[o] == "number" || t[o]instanceof Number) ? d[o] = e[o] + t[o] : d[o] = t[o] === void 0 ? e[o] : e[o] || t[o],
                      o += 1;
                  return d
              }
              return 0
          }
          var add = sum;
          function sub(e, t) {
              var r = _typeof$1(e)
                , a = _typeof$1(t);
              if (isNumerable(r, e) && isNumerable(a, t))
                  return r === "string" && (e = parseInt(e, 10)),
                  a === "string" && (t = parseInt(t, 10)),
                  e - t;
              if ($bm_isInstanceOfArray(e) && isNumerable(a, t))
                  return e = e.slice(0),
                  e[0] -= t,
                  e;
              if (isNumerable(r, e) && $bm_isInstanceOfArray(t))
                  return t = t.slice(0),
                  t[0] = e - t[0],
                  t;
              if ($bm_isInstanceOfArray(e) && $bm_isInstanceOfArray(t)) {
                  for (var o = 0, l = e.length, f = t.length, d = []; o < l || o < f; )
                      (typeof e[o] == "number" || e[o]instanceof Number) && (typeof t[o] == "number" || t[o]instanceof Number) ? d[o] = e[o] - t[o] : d[o] = t[o] === void 0 ? e[o] : e[o] || t[o],
                      o += 1;
                  return d
              }
              return 0
          }
          function mul(e, t) {
              var r = _typeof$1(e), a = _typeof$1(t), o;
              if (isNumerable(r, e) && isNumerable(a, t))
                  return e * t;
              var l, f;
              if ($bm_isInstanceOfArray(e) && isNumerable(a, t)) {
                  for (f = e.length,
                  o = createTypedArray("float32", f),
                  l = 0; l < f; l += 1)
                      o[l] = e[l] * t;
                  return o
              }
              if (isNumerable(r, e) && $bm_isInstanceOfArray(t)) {
                  for (f = t.length,
                  o = createTypedArray("float32", f),
                  l = 0; l < f; l += 1)
                      o[l] = e * t[l];
                  return o
              }
              return 0
          }
          function div(e, t) {
              var r = _typeof$1(e), a = _typeof$1(t), o;
              if (isNumerable(r, e) && isNumerable(a, t))
                  return e / t;
              var l, f;
              if ($bm_isInstanceOfArray(e) && isNumerable(a, t)) {
                  for (f = e.length,
                  o = createTypedArray("float32", f),
                  l = 0; l < f; l += 1)
                      o[l] = e[l] / t;
                  return o
              }
              if (isNumerable(r, e) && $bm_isInstanceOfArray(t)) {
                  for (f = t.length,
                  o = createTypedArray("float32", f),
                  l = 0; l < f; l += 1)
                      o[l] = e / t[l];
                  return o
              }
              return 0
          }
          function mod(e, t) {
              return typeof e == "string" && (e = parseInt(e, 10)),
              typeof t == "string" && (t = parseInt(t, 10)),
              e % t
          }
          var $bm_sum = sum
            , $bm_sub = sub
            , $bm_mul = mul
            , $bm_div = div
            , $bm_mod = mod;
          function clamp(e, t, r) {
              if (t > r) {
                  var a = r;
                  r = t,
                  t = a
              }
              return Math.min(Math.max(e, t), r)
          }
          function radiansToDegrees(e) {
              return e / degToRads
          }
          var radians_to_degrees = radiansToDegrees;
          function degreesToRadians(e) {
              return e * degToRads
          }
          var degrees_to_radians = radiansToDegrees
            , helperLengthArray = [0, 0, 0, 0, 0, 0];
          function length(e, t) {
              if (typeof e == "number" || e instanceof Number)
                  return t = t || 0,
                  Math.abs(e - t);
              t || (t = helperLengthArray);
              var r, a = Math.min(e.length, t.length), o = 0;
              for (r = 0; r < a; r += 1)
                  o += Math.pow(t[r] - e[r], 2);
              return Math.sqrt(o)
          }
          function normalize(e) {
              return div(e, length(e))
          }
          function rgbToHsl(e) {
              var t = e[0], r = e[1], a = e[2], o = Math.max(t, r, a), l = Math.min(t, r, a), f, d, g = (o + l) / 2;
              if (o === l)
                  f = 0,
                  d = 0;
              else {
                  var _ = o - l;
                  switch (d = g > .5 ? _ / (2 - o - l) : _ / (o + l),
                  o) {
                  case t:
                      f = (r - a) / _ + (r < a ? 6 : 0);
                      break;
                  case r:
                      f = (a - t) / _ + 2;
                      break;
                  case a:
                      f = (t - r) / _ + 4;
                      break
                  }
                  f /= 6
              }
              return [f, d, g, e[3]]
          }
          function hue2rgb(e, t, r) {
              return r < 0 && (r += 1),
              r > 1 && (r -= 1),
              r < 1 / 6 ? e + (t - e) * 6 * r : r < 1 / 2 ? t : r < 2 / 3 ? e + (t - e) * (2 / 3 - r) * 6 : e
          }
          function hslToRgb(e) {
              var t = e[0], r = e[1], a = e[2], o, l, f;
              if (r === 0)
                  o = a,
                  f = a,
                  l = a;
              else {
                  var d = a < .5 ? a * (1 + r) : a + r - a * r
                    , g = 2 * a - d;
                  o = hue2rgb(g, d, t + 1 / 3),
                  l = hue2rgb(g, d, t),
                  f = hue2rgb(g, d, t - 1 / 3)
              }
              return [o, l, f, e[3]]
          }
          function linear(e, t, r, a, o) {
              if ((a === void 0 || o === void 0) && (a = t,
              o = r,
              t = 0,
              r = 1),
              r < t) {
                  var l = r;
                  r = t,
                  t = l
              }
              if (e <= t)
                  return a;
              if (e >= r)
                  return o;
              var f = r === t ? 0 : (e - t) / (r - t);
              if (!a.length)
                  return a + (o - a) * f;
              var d, g = a.length, _ = createTypedArray("float32", g);
              for (d = 0; d < g; d += 1)
                  _[d] = a[d] + (o[d] - a[d]) * f;
              return _
          }
          function random(e, t) {
              if (t === void 0 && (e === void 0 ? (e = 0,
              t = 1) : (t = e,
              e = void 0)),
              t.length) {
                  var r, a = t.length;
                  e || (e = createTypedArray("float32", a));
                  var o = createTypedArray("float32", a)
                    , l = BMMath.random();
                  for (r = 0; r < a; r += 1)
                      o[r] = e[r] + l * (t[r] - e[r]);
                  return o
              }
              e === void 0 && (e = 0);
              var f = BMMath.random();
              return e + f * (t - e)
          }
          function createPath(e, t, r, a) {
              var o, l = e.length, f = shapePool.newElement();
              f.setPathData(!!a, l);
              var d = [0, 0], g, _;
              for (o = 0; o < l; o += 1)
                  g = t && t[o] ? t[o] : d,
                  _ = r && r[o] ? r[o] : d,
                  f.setTripleAt(e[o][0], e[o][1], _[0] + e[o][0], _[1] + e[o][1], g[0] + e[o][0], g[1] + e[o][1], o, !0);
              return f
          }
          function initiateExpression(elem, data, property) {
              function noOp(e) {
                  return e
              }
              if (!elem.globalData.renderConfig.runExpressions)
                  return noOp;
              var val = data.x, needsVelocity = /velocity(?![\w\d])/.test(val), _needsRandom = val.indexOf("random") !== -1, elemType = elem.data.ty, transform, $bm_transform, content, effect, thisProperty = property;
              thisProperty.valueAtTime = thisProperty.getValueAtTime,
              Object.defineProperty(thisProperty, "value", {
                  get: function() {
                      return thisProperty.v
                  }
              }),
              elem.comp.frameDuration = 1 / elem.comp.globalData.frameRate,
              elem.comp.displayStartTime = 0;
              var inPoint = elem.data.ip / elem.comp.globalData.frameRate, outPoint = elem.data.op / elem.comp.globalData.frameRate, width = elem.data.sw ? elem.data.sw : 0, height = elem.data.sh ? elem.data.sh : 0, name = elem.data.nm, loopIn, loop_in, loopOut, loop_out, smooth, toWorld, fromWorld, fromComp, toComp, fromCompToSurface, position, rotation, anchorPoint, scale, thisLayer, thisComp, mask, valueAtTime, velocityAtTime, scoped_bm_rt, expression_function = eval("[function _expression_function(){" + val + ";scoped_bm_rt=$bm_rt}]")[0], numKeys = property.kf ? data.k.length : 0, active = !this.data || this.data.hd !== !0, wiggle = (function e(t, r) {
                  var a, o, l = this.pv.length ? this.pv.length : 1, f = createTypedArray("float32", l);
                  t = 5;
                  var d = Math.floor(time * t);
                  for (a = 0,
                  o = 0; a < d; ) {
                      for (o = 0; o < l; o += 1)
                          f[o] += -r + r * 2 * BMMath.random();
                      a += 1
                  }
                  var g = time * t
                    , _ = g - Math.floor(g)
                    , v = createTypedArray("float32", l);
                  if (l > 1) {
                      for (o = 0; o < l; o += 1)
                          v[o] = this.pv[o] + f[o] + (-r + r * 2 * BMMath.random()) * _;
                      return v
                  }
                  return this.pv + f[0] + (-r + r * 2 * BMMath.random()) * _
              }
              ).bind(this);
              thisProperty.loopIn && (loopIn = thisProperty.loopIn.bind(thisProperty),
              loop_in = loopIn),
              thisProperty.loopOut && (loopOut = thisProperty.loopOut.bind(thisProperty),
              loop_out = loopOut),
              thisProperty.smooth && (smooth = thisProperty.smooth.bind(thisProperty));
              function loopInDuration(e, t) {
                  return loopIn(e, t, !0)
              }
              function loopOutDuration(e, t) {
                  return loopOut(e, t, !0)
              }
              this.getValueAtTime && (valueAtTime = this.getValueAtTime.bind(this)),
              this.getVelocityAtTime && (velocityAtTime = this.getVelocityAtTime.bind(this));
              var comp = elem.comp.globalData.projectInterface.bind(elem.comp.globalData.projectInterface);
              function lookAt(e, t) {
                  var r = [t[0] - e[0], t[1] - e[1], t[2] - e[2]]
                    , a = Math.atan2(r[0], Math.sqrt(r[1] * r[1] + r[2] * r[2])) / degToRads
                    , o = -Math.atan2(r[1], r[2]) / degToRads;
                  return [o, a, 0]
              }
              function easeOut(e, t, r, a, o) {
                  return applyEase(easeOutBez, e, t, r, a, o)
              }
              function easeIn(e, t, r, a, o) {
                  return applyEase(easeInBez, e, t, r, a, o)
              }
              function ease(e, t, r, a, o) {
                  return applyEase(easeInOutBez, e, t, r, a, o)
              }
              function applyEase(e, t, r, a, o, l) {
                  o === void 0 ? (o = r,
                  l = a) : t = (t - r) / (a - r),
                  t > 1 ? t = 1 : t < 0 && (t = 0);
                  var f = e(t);
                  if ($bm_isInstanceOfArray(o)) {
                      var d, g = o.length, _ = createTypedArray("float32", g);
                      for (d = 0; d < g; d += 1)
                          _[d] = (l[d] - o[d]) * f + o[d];
                      return _
                  }
                  return (l - o) * f + o
              }
              function nearestKey(e) {
                  var t, r = data.k.length, a, o;
                  if (!data.k.length || typeof data.k[0] == "number")
                      a = 0,
                      o = 0;
                  else if (a = -1,
                  e *= elem.comp.globalData.frameRate,
                  e < data.k[0].t)
                      a = 1,
                      o = data.k[0].t;
                  else {
                      for (t = 0; t < r - 1; t += 1)
                          if (e === data.k[t].t) {
                              a = t + 1,
                              o = data.k[t].t;
                              break
                          } else if (e > data.k[t].t && e < data.k[t + 1].t) {
                              e - data.k[t].t > data.k[t + 1].t - e ? (a = t + 2,
                              o = data.k[t + 1].t) : (a = t + 1,
                              o = data.k[t].t);
                              break
                          }
                      a === -1 && (a = t + 1,
                      o = data.k[t].t)
                  }
                  var l = {};
                  return l.index = a,
                  l.time = o / elem.comp.globalData.frameRate,
                  l
              }
              function key(e) {
                  var t, r, a;
                  if (!data.k.length || typeof data.k[0] == "number")
                      throw new Error("The property has no keyframe at index " + e);
                  e -= 1,
                  t = {
                      time: data.k[e].t / elem.comp.globalData.frameRate,
                      value: []
                  };
                  var o = Object.prototype.hasOwnProperty.call(data.k[e], "s") ? data.k[e].s : data.k[e - 1].e;
                  for (a = o.length,
                  r = 0; r < a; r += 1)
                      t[r] = o[r],
                      t.value[r] = o[r];
                  return t
              }
              function framesToTime(e, t) {
                  return t || (t = elem.comp.globalData.frameRate),
                  e / t
              }
              function timeToFrames(e, t) {
                  return !e && e !== 0 && (e = time),
                  t || (t = elem.comp.globalData.frameRate),
                  e * t
              }
              function seedRandom(e) {
                  BMMath.seedrandom(randSeed + e)
              }
              function sourceRectAtTime() {
                  return elem.sourceRectAtTime()
              }
              function substring(e, t) {
                  return typeof value == "string" ? t === void 0 ? value.substring(e) : value.substring(e, t) : ""
              }
              function substr(e, t) {
                  return typeof value == "string" ? t === void 0 ? value.substr(e) : value.substr(e, t) : ""
              }
              function posterizeTime(e) {
                  time = e === 0 ? 0 : Math.floor(time * e) / e,
                  value = valueAtTime(time)
              }
              var time, velocity, value, text, textIndex, textTotal, selectorValue, index = elem.data.ind, hasParent = !!(elem.hierarchy && elem.hierarchy.length), parent, randSeed = Math.floor(Math.random() * 1e6), globalData = elem.globalData;
              function executeExpression(e) {
                  return value = e,
                  this.frameExpressionId === elem.globalData.frameId && this.propType !== "textSelector" ? value : (this.propType === "textSelector" && (textIndex = this.textIndex,
                  textTotal = this.textTotal,
                  selectorValue = this.selectorValue),
                  thisLayer || (text = elem.layerInterface.text,
                  thisLayer = elem.layerInterface,
                  thisComp = elem.comp.compInterface,
                  toWorld = thisLayer.toWorld.bind(thisLayer),
                  fromWorld = thisLayer.fromWorld.bind(thisLayer),
                  fromComp = thisLayer.fromComp.bind(thisLayer),
                  toComp = thisLayer.toComp.bind(thisLayer),
                  mask = thisLayer.mask ? thisLayer.mask.bind(thisLayer) : null,
                  fromCompToSurface = fromComp),
                  transform || (transform = elem.layerInterface("ADBE Transform Group"),
                  $bm_transform = transform,
                  transform && (anchorPoint = transform.anchorPoint)),
                  elemType === 4 && !content && (content = thisLayer("ADBE Root Vectors Group")),
                  effect || (effect = thisLayer(4)),
                  hasParent = !!(elem.hierarchy && elem.hierarchy.length),
                  hasParent && !parent && (parent = elem.hierarchy[0].layerInterface),
                  time = this.comp.renderedFrame / this.comp.globalData.frameRate,
                  _needsRandom && seedRandom(randSeed + time),
                  needsVelocity && (velocity = velocityAtTime(time)),
                  expression_function(),
                  this.frameExpressionId = elem.globalData.frameId,
                  scoped_bm_rt = scoped_bm_rt.propType === propTypes.SHAPE ? scoped_bm_rt.v : scoped_bm_rt,
                  scoped_bm_rt)
              }
              return executeExpression.__preventDeadCodeRemoval = [$bm_transform, anchorPoint, time, velocity, inPoint, outPoint, width, height, name, loop_in, loop_out, smooth, toComp, fromCompToSurface, toWorld, fromWorld, mask, position, rotation, scale, thisComp, numKeys, active, wiggle, loopInDuration, loopOutDuration, comp, lookAt, easeOut, easeIn, ease, nearestKey, key, text, textIndex, textTotal, selectorValue, framesToTime, timeToFrames, sourceRectAtTime, substring, substr, posterizeTime, index, globalData],
              executeExpression
          }
          return ob.initiateExpression = initiateExpression,
          ob.__preventDeadCodeRemoval = [window, document, XMLHttpRequest, fetch, frames, $bm_neg, add, $bm_sum, $bm_sub, $bm_mul, $bm_div, $bm_mod, clamp, radians_to_degrees, degreesToRadians, degrees_to_radians, normalize, rgbToHsl, hslToRgb, linear, random, createPath, _lottieGlobal],
          ob.resetFrame = resetFrame,
          ob
      }()
        , Expressions = function() {
          var e = {};
          e.initExpressions = t,
          e.resetFrame = ExpressionManager.resetFrame;
          function t(r) {
              var a = 0
                , o = [];
              function l() {
                  a += 1
              }
              function f() {
                  a -= 1,
                  a === 0 && g()
              }
              function d(_) {
                  o.indexOf(_) === -1 && o.push(_)
              }
              function g() {
                  var _, v = o.length;
                  for (_ = 0; _ < v; _ += 1)
                      o[_].release();
                  o.length = 0
              }
              r.renderer.compInterface = CompExpressionInterface(r.renderer),
              r.renderer.globalData.projectInterface.registerComposition(r.renderer),
              r.renderer.globalData.pushExpression = l,
              r.renderer.globalData.popExpression = f,
              r.renderer.globalData.registerExpressionProperty = d
          }
          return e
      }()
        , MaskManagerInterface = function() {
          function e(r, a) {
              this._mask = r,
              this._data = a
          }
          Object.defineProperty(e.prototype, "maskPath", {
              get: function() {
                  return this._mask.prop.k && this._mask.prop.getValue(),
                  this._mask.prop
              }
          }),
          Object.defineProperty(e.prototype, "maskOpacity", {
              get: function() {
                  return this._mask.op.k && this._mask.op.getValue(),
                  this._mask.op.v * 100
              }
          });
          var t = function(a) {
              var o = createSizedArray(a.viewData.length), l, f = a.viewData.length;
              for (l = 0; l < f; l += 1)
                  o[l] = new e(a.viewData[l],a.masksProperties[l]);
              var d = function(_) {
                  for (l = 0; l < f; ) {
                      if (a.masksProperties[l].nm === _)
                          return o[l];
                      l += 1
                  }
                  return null
              };
              return d
          };
          return t
      }()
        , ExpressionPropertyInterface = function() {
          var e = {
              pv: 0,
              v: 0,
              mult: 1
          }
            , t = {
              pv: [0, 0, 0],
              v: [0, 0, 0],
              mult: 1
          };
          function r(f, d, g) {
              Object.defineProperty(f, "velocity", {
                  get: function() {
                      return d.getVelocityAtTime(d.comp.currentFrame)
                  }
              }),
              f.numKeys = d.keyframes ? d.keyframes.length : 0,
              f.key = function(_) {
                  if (!f.numKeys)
                      return 0;
                  var v = "";
                  "s"in d.keyframes[_ - 1] ? v = d.keyframes[_ - 1].s : "e"in d.keyframes[_ - 2] ? v = d.keyframes[_ - 2].e : v = d.keyframes[_ - 2].s;
                  var S = g === "unidimensional" ? new Number(v) : Object.assign({}, v);
                  return S.time = d.keyframes[_ - 1].t / d.elem.comp.globalData.frameRate,
                  S.value = g === "unidimensional" ? v[0] : v,
                  S
              }
              ,
              f.valueAtTime = d.getValueAtTime,
              f.speedAtTime = d.getSpeedAtTime,
              f.velocityAtTime = d.getVelocityAtTime,
              f.propertyGroup = d.propertyGroup
          }
          function a(f) {
              (!f || !("pv"in f)) && (f = e);
              var d = 1 / f.mult
                , g = f.pv * d
                , _ = new Number(g);
              return _.value = g,
              r(_, f, "unidimensional"),
              function() {
                  return f.k && f.getValue(),
                  g = f.v * d,
                  _.value !== g && (_ = new Number(g),
                  _.value = g,
                  r(_, f, "unidimensional")),
                  _
              }
          }
          function o(f) {
              (!f || !("pv"in f)) && (f = t);
              var d = 1 / f.mult
                , g = f.data && f.data.l || f.pv.length
                , _ = createTypedArray("float32", g)
                , v = createTypedArray("float32", g);
              return _.value = v,
              r(_, f, "multidimensional"),
              function() {
                  f.k && f.getValue();
                  for (var S = 0; S < g; S += 1)
                      v[S] = f.v[S] * d,
                      _[S] = v[S];
                  return _
              }
          }
          function l() {
              return e
          }
          return function(f) {
              return f ? f.propType === "unidimensional" ? a(f) : o(f) : l
          }
      }()
        , TransformExpressionInterface = function() {
          return function(e) {
              function t(f) {
                  switch (f) {
                  case "scale":
                  case "Scale":
                  case "ADBE Scale":
                  case 6:
                      return t.scale;
                  case "rotation":
                  case "Rotation":
                  case "ADBE Rotation":
                  case "ADBE Rotate Z":
                  case 10:
                      return t.rotation;
                  case "ADBE Rotate X":
                      return t.xRotation;
                  case "ADBE Rotate Y":
                      return t.yRotation;
                  case "position":
                  case "Position":
                  case "ADBE Position":
                  case 2:
                      return t.position;
                  case "ADBE Position_0":
                      return t.xPosition;
                  case "ADBE Position_1":
                      return t.yPosition;
                  case "ADBE Position_2":
                      return t.zPosition;
                  case "anchorPoint":
                  case "AnchorPoint":
                  case "Anchor Point":
                  case "ADBE AnchorPoint":
                  case 1:
                      return t.anchorPoint;
                  case "opacity":
                  case "Opacity":
                  case 11:
                      return t.opacity;
                  default:
                      return null
                  }
              }
              Object.defineProperty(t, "rotation", {
                  get: ExpressionPropertyInterface(e.r || e.rz)
              }),
              Object.defineProperty(t, "zRotation", {
                  get: ExpressionPropertyInterface(e.rz || e.r)
              }),
              Object.defineProperty(t, "xRotation", {
                  get: ExpressionPropertyInterface(e.rx)
              }),
              Object.defineProperty(t, "yRotation", {
                  get: ExpressionPropertyInterface(e.ry)
              }),
              Object.defineProperty(t, "scale", {
                  get: ExpressionPropertyInterface(e.s)
              });
              var r, a, o, l;
              return e.p ? l = ExpressionPropertyInterface(e.p) : (r = ExpressionPropertyInterface(e.px),
              a = ExpressionPropertyInterface(e.py),
              e.pz && (o = ExpressionPropertyInterface(e.pz))),
              Object.defineProperty(t, "position", {
                  get: function() {
                      return e.p ? l() : [r(), a(), o ? o() : 0]
                  }
              }),
              Object.defineProperty(t, "xPosition", {
                  get: ExpressionPropertyInterface(e.px)
              }),
              Object.defineProperty(t, "yPosition", {
                  get: ExpressionPropertyInterface(e.py)
              }),
              Object.defineProperty(t, "zPosition", {
                  get: ExpressionPropertyInterface(e.pz)
              }),
              Object.defineProperty(t, "anchorPoint", {
                  get: ExpressionPropertyInterface(e.a)
              }),
              Object.defineProperty(t, "opacity", {
                  get: ExpressionPropertyInterface(e.o)
              }),
              Object.defineProperty(t, "skew", {
                  get: ExpressionPropertyInterface(e.sk)
              }),
              Object.defineProperty(t, "skewAxis", {
                  get: ExpressionPropertyInterface(e.sa)
              }),
              Object.defineProperty(t, "orientation", {
                  get: ExpressionPropertyInterface(e.or)
              }),
              t
          }
      }()
        , LayerExpressionInterface = function() {
          function e(_) {
              var v = new Matrix;
              if (_ !== void 0) {
                  var S = this._elem.finalTransform.mProp.getValueAtTime(_);
                  S.clone(v)
              } else {
                  var b = this._elem.finalTransform.mProp;
                  b.applyToMatrix(v)
              }
              return v
          }
          function t(_, v) {
              var S = this.getMatrix(v);
              return S.props[12] = 0,
              S.props[13] = 0,
              S.props[14] = 0,
              this.applyPoint(S, _)
          }
          function r(_, v) {
              var S = this.getMatrix(v);
              return this.applyPoint(S, _)
          }
          function a(_, v) {
              var S = this.getMatrix(v);
              return S.props[12] = 0,
              S.props[13] = 0,
              S.props[14] = 0,
              this.invertPoint(S, _)
          }
          function o(_, v) {
              var S = this.getMatrix(v);
              return this.invertPoint(S, _)
          }
          function l(_, v) {
              if (this._elem.hierarchy && this._elem.hierarchy.length) {
                  var S, b = this._elem.hierarchy.length;
                  for (S = 0; S < b; S += 1)
                      this._elem.hierarchy[S].finalTransform.mProp.applyToMatrix(_)
              }
              return _.applyToPointArray(v[0], v[1], v[2] || 0)
          }
          function f(_, v) {
              if (this._elem.hierarchy && this._elem.hierarchy.length) {
                  var S, b = this._elem.hierarchy.length;
                  for (S = 0; S < b; S += 1)
                      this._elem.hierarchy[S].finalTransform.mProp.applyToMatrix(_)
              }
              return _.inversePoint(v)
          }
          function d(_) {
              var v = new Matrix;
              if (v.reset(),
              this._elem.finalTransform.mProp.applyToMatrix(v),
              this._elem.hierarchy && this._elem.hierarchy.length) {
                  var S, b = this._elem.hierarchy.length;
                  for (S = 0; S < b; S += 1)
                      this._elem.hierarchy[S].finalTransform.mProp.applyToMatrix(v);
                  return v.inversePoint(_)
              }
              return v.inversePoint(_)
          }
          function g() {
              return [1, 1, 1, 1]
          }
          return function(_) {
              var v;
              function S(E) {
                  P.mask = new MaskManagerInterface(E,_)
              }
              function b(E) {
                  P.effect = E
              }
              function P(E) {
                  switch (E) {
                  case "ADBE Root Vectors Group":
                  case "Contents":
                  case 2:
                      return P.shapeInterface;
                  case 1:
                  case 6:
                  case "Transform":
                  case "transform":
                  case "ADBE Transform Group":
                      return v;
                  case 4:
                  case "ADBE Effect Parade":
                  case "effects":
                  case "Effects":
                      return P.effect;
                  case "ADBE Text Properties":
                      return P.textInterface;
                  default:
                      return null
                  }
              }
              P.getMatrix = e,
              P.invertPoint = f,
              P.applyPoint = l,
              P.toWorld = r,
              P.toWorldVec = t,
              P.fromWorld = o,
              P.fromWorldVec = a,
              P.toComp = r,
              P.fromComp = d,
              P.sampleImage = g,
              P.sourceRectAtTime = _.sourceRectAtTime.bind(_),
              P._elem = _,
              v = TransformExpressionInterface(_.finalTransform.mProp);
              var x = getDescriptor(v, "anchorPoint");
              return Object.defineProperties(P, {
                  hasParent: {
                      get: function() {
                          return _.hierarchy.length
                      }
                  },
                  parent: {
                      get: function() {
                          return _.hierarchy[0].layerInterface
                      }
                  },
                  rotation: getDescriptor(v, "rotation"),
                  scale: getDescriptor(v, "scale"),
                  position: getDescriptor(v, "position"),
                  opacity: getDescriptor(v, "opacity"),
                  anchorPoint: x,
                  anchor_point: x,
                  transform: {
                      get: function() {
                          return v
                      }
                  },
                  active: {
                      get: function() {
                          return _.isInRange
                      }
                  }
              }),
              P.startTime = _.data.st,
              P.index = _.data.ind,
              P.source = _.data.refId,
              P.height = _.data.ty === 0 ? _.data.h : 100,
              P.width = _.data.ty === 0 ? _.data.w : 100,
              P.inPoint = _.data.ip / _.comp.globalData.frameRate,
              P.outPoint = _.data.op / _.comp.globalData.frameRate,
              P._name = _.data.nm,
              P.registerMaskInterface = S,
              P.registerEffectsInterface = b,
              P
          }
      }()
        , propertyGroupFactory = function() {
          return function(e, t) {
              return function(r) {
                  return r = r === void 0 ? 1 : r,
                  r <= 0 ? e : t(r - 1)
              }
          }
      }()
        , PropertyInterface = function() {
          return function(e, t) {
              var r = {
                  _name: e
              };
              function a(o) {
                  return o = o === void 0 ? 1 : o,
                  o <= 0 ? r : t(o - 1)
              }
              return a
          }
      }()
        , EffectsExpressionInterface = function() {
          var e = {
              createEffectsInterface: t
          };
          function t(o, l) {
              if (o.effectsManager) {
                  var f = [], d = o.data.ef, g, _ = o.effectsManager.effectElements.length;
                  for (g = 0; g < _; g += 1)
                      f.push(r(d[g], o.effectsManager.effectElements[g], l, o));
                  var v = o.data.ef || []
                    , S = function(P) {
                      for (g = 0,
                      _ = v.length; g < _; ) {
                          if (P === v[g].nm || P === v[g].mn || P === v[g].ix)
                              return f[g];
                          g += 1
                      }
                      return null
                  };
                  return Object.defineProperty(S, "numProperties", {
                      get: function() {
                          return v.length
                      }
                  }),
                  S
              }
              return null
          }
          function r(o, l, f, d) {
              function g(P) {
                  for (var x = o.ef, E = 0, I = x.length; E < I; ) {
                      if (P === x[E].nm || P === x[E].mn || P === x[E].ix)
                          return x[E].ty === 5 ? v[E] : v[E]();
                      E += 1
                  }
                  throw new Error
              }
              var _ = propertyGroupFactory(g, f), v = [], S, b = o.ef.length;
              for (S = 0; S < b; S += 1)
                  o.ef[S].ty === 5 ? v.push(r(o.ef[S], l.effectElements[S], l.effectElements[S].propertyGroup, d)) : v.push(a(l.effectElements[S], o.ef[S].ty, d, _));
              return o.mn === "ADBE Color Control" && Object.defineProperty(g, "color", {
                  get: function() {
                      return v[0]()
                  }
              }),
              Object.defineProperties(g, {
                  numProperties: {
                      get: function() {
                          return o.np
                      }
                  },
                  _name: {
                      value: o.nm
                  },
                  propertyGroup: {
                      value: _
                  }
              }),
              g.enabled = o.en !== 0,
              g.active = g.enabled,
              g
          }
          function a(o, l, f, d) {
              var g = ExpressionPropertyInterface(o.p);
              function _() {
                  return l === 10 ? f.comp.compInterface(o.p.v) : g()
              }
              return o.p.setGroupProperty && o.p.setGroupProperty(PropertyInterface("", d)),
              _
          }
          return e
      }()
        , ShapePathInterface = function() {
          return function(t, r, a) {
              var o = r.sh;
              function l(d) {
                  return d === "Shape" || d === "shape" || d === "Path" || d === "path" || d === "ADBE Vector Shape" || d === 2 ? l.path : null
              }
              var f = propertyGroupFactory(l, a);
              return o.setGroupProperty(PropertyInterface("Path", f)),
              Object.defineProperties(l, {
                  path: {
                      get: function() {
                          return o.k && o.getValue(),
                          o
                      }
                  },
                  shape: {
                      get: function() {
                          return o.k && o.getValue(),
                          o
                      }
                  },
                  _name: {
                      value: t.nm
                  },
                  ix: {
                      value: t.ix
                  },
                  propertyIndex: {
                      value: t.ix
                  },
                  mn: {
                      value: t.mn
                  },
                  propertyGroup: {
                      value: a
                  }
              }),
              l
          }
      }()
        , ShapeExpressionInterface = function() {
          function e(x, E, I) {
              var C = [], A, T = x ? x.length : 0;
              for (A = 0; A < T; A += 1)
                  x[A].ty === "gr" ? C.push(r(x[A], E[A], I)) : x[A].ty === "fl" ? C.push(a(x[A], E[A], I)) : x[A].ty === "st" ? C.push(f(x[A], E[A], I)) : x[A].ty === "tm" ? C.push(d(x[A], E[A], I)) : x[A].ty === "tr" || (x[A].ty === "el" ? C.push(_(x[A], E[A], I)) : x[A].ty === "sr" ? C.push(v(x[A], E[A], I)) : x[A].ty === "sh" ? C.push(ShapePathInterface(x[A], E[A], I)) : x[A].ty === "rc" ? C.push(S(x[A], E[A], I)) : x[A].ty === "rd" ? C.push(b(x[A], E[A], I)) : x[A].ty === "rp" ? C.push(P(x[A], E[A], I)) : x[A].ty === "gf" ? C.push(o(x[A], E[A], I)) : C.push(l(x[A], E[A])));
              return C
          }
          function t(x, E, I) {
              var C, A = function(M) {
                  for (var F = 0, O = C.length; F < O; ) {
                      if (C[F]._name === M || C[F].mn === M || C[F].propertyIndex === M || C[F].ix === M || C[F].ind === M)
                          return C[F];
                      F += 1
                  }
                  return typeof M == "number" ? C[M - 1] : null
              };
              A.propertyGroup = propertyGroupFactory(A, I),
              C = e(x.it, E.it, A.propertyGroup),
              A.numProperties = C.length;
              var T = g(x.it[x.it.length - 1], E.it[E.it.length - 1], A.propertyGroup);
              return A.transform = T,
              A.propertyIndex = x.cix,
              A._name = x.nm,
              A
          }
          function r(x, E, I) {
              var C = function(M) {
                  switch (M) {
                  case "ADBE Vectors Group":
                  case "Contents":
                  case 2:
                      return C.content;
                  default:
                      return C.transform
                  }
              };
              C.propertyGroup = propertyGroupFactory(C, I);
              var A = t(x, E, C.propertyGroup)
                , T = g(x.it[x.it.length - 1], E.it[E.it.length - 1], C.propertyGroup);
              return C.content = A,
              C.transform = T,
              Object.defineProperty(C, "_name", {
                  get: function() {
                      return x.nm
                  }
              }),
              C.numProperties = x.np,
              C.propertyIndex = x.ix,
              C.nm = x.nm,
              C.mn = x.mn,
              C
          }
          function a(x, E, I) {
              function C(A) {
                  return A === "Color" || A === "color" ? C.color : A === "Opacity" || A === "opacity" ? C.opacity : null
              }
              return Object.defineProperties(C, {
                  color: {
                      get: ExpressionPropertyInterface(E.c)
                  },
                  opacity: {
                      get: ExpressionPropertyInterface(E.o)
                  },
                  _name: {
                      value: x.nm
                  },
                  mn: {
                      value: x.mn
                  }
              }),
              E.c.setGroupProperty(PropertyInterface("Color", I)),
              E.o.setGroupProperty(PropertyInterface("Opacity", I)),
              C
          }
          function o(x, E, I) {
              function C(A) {
                  return A === "Start Point" || A === "start point" ? C.startPoint : A === "End Point" || A === "end point" ? C.endPoint : A === "Opacity" || A === "opacity" ? C.opacity : null
              }
              return Object.defineProperties(C, {
                  startPoint: {
                      get: ExpressionPropertyInterface(E.s)
                  },
                  endPoint: {
                      get: ExpressionPropertyInterface(E.e)
                  },
                  opacity: {
                      get: ExpressionPropertyInterface(E.o)
                  },
                  type: {
                      get: function() {
                          return "a"
                      }
                  },
                  _name: {
                      value: x.nm
                  },
                  mn: {
                      value: x.mn
                  }
              }),
              E.s.setGroupProperty(PropertyInterface("Start Point", I)),
              E.e.setGroupProperty(PropertyInterface("End Point", I)),
              E.o.setGroupProperty(PropertyInterface("Opacity", I)),
              C
          }
          function l() {
              function x() {
                  return null
              }
              return x
          }
          function f(x, E, I) {
              var C = propertyGroupFactory(O, I)
                , A = propertyGroupFactory(F, C);
              function T($) {
                  Object.defineProperty(F, x.d[$].nm, {
                      get: ExpressionPropertyInterface(E.d.dataProps[$].p)
                  })
              }
              var w, M = x.d ? x.d.length : 0, F = {};
              for (w = 0; w < M; w += 1)
                  T(w),
                  E.d.dataProps[w].p.setGroupProperty(A);
              function O($) {
                  return $ === "Color" || $ === "color" ? O.color : $ === "Opacity" || $ === "opacity" ? O.opacity : $ === "Stroke Width" || $ === "stroke width" ? O.strokeWidth : null
              }
              return Object.defineProperties(O, {
                  color: {
                      get: ExpressionPropertyInterface(E.c)
                  },
                  opacity: {
                      get: ExpressionPropertyInterface(E.o)
                  },
                  strokeWidth: {
                      get: ExpressionPropertyInterface(E.w)
                  },
                  dash: {
                      get: function() {
                          return F
                      }
                  },
                  _name: {
                      value: x.nm
                  },
                  mn: {
                      value: x.mn
                  }
              }),
              E.c.setGroupProperty(PropertyInterface("Color", C)),
              E.o.setGroupProperty(PropertyInterface("Opacity", C)),
              E.w.setGroupProperty(PropertyInterface("Stroke Width", C)),
              O
          }
          function d(x, E, I) {
              function C(T) {
                  return T === x.e.ix || T === "End" || T === "end" ? C.end : T === x.s.ix ? C.start : T === x.o.ix ? C.offset : null
              }
              var A = propertyGroupFactory(C, I);
              return C.propertyIndex = x.ix,
              E.s.setGroupProperty(PropertyInterface("Start", A)),
              E.e.setGroupProperty(PropertyInterface("End", A)),
              E.o.setGroupProperty(PropertyInterface("Offset", A)),
              C.propertyIndex = x.ix,
              C.propertyGroup = I,
              Object.defineProperties(C, {
                  start: {
                      get: ExpressionPropertyInterface(E.s)
                  },
                  end: {
                      get: ExpressionPropertyInterface(E.e)
                  },
                  offset: {
                      get: ExpressionPropertyInterface(E.o)
                  },
                  _name: {
                      value: x.nm
                  }
              }),
              C.mn = x.mn,
              C
          }
          function g(x, E, I) {
              function C(T) {
                  return x.a.ix === T || T === "Anchor Point" ? C.anchorPoint : x.o.ix === T || T === "Opacity" ? C.opacity : x.p.ix === T || T === "Position" ? C.position : x.r.ix === T || T === "Rotation" || T === "ADBE Vector Rotation" ? C.rotation : x.s.ix === T || T === "Scale" ? C.scale : x.sk && x.sk.ix === T || T === "Skew" ? C.skew : x.sa && x.sa.ix === T || T === "Skew Axis" ? C.skewAxis : null
              }
              var A = propertyGroupFactory(C, I);
              return E.transform.mProps.o.setGroupProperty(PropertyInterface("Opacity", A)),
              E.transform.mProps.p.setGroupProperty(PropertyInterface("Position", A)),
              E.transform.mProps.a.setGroupProperty(PropertyInterface("Anchor Point", A)),
              E.transform.mProps.s.setGroupProperty(PropertyInterface("Scale", A)),
              E.transform.mProps.r.setGroupProperty(PropertyInterface("Rotation", A)),
              E.transform.mProps.sk && (E.transform.mProps.sk.setGroupProperty(PropertyInterface("Skew", A)),
              E.transform.mProps.sa.setGroupProperty(PropertyInterface("Skew Angle", A))),
              E.transform.op.setGroupProperty(PropertyInterface("Opacity", A)),
              Object.defineProperties(C, {
                  opacity: {
                      get: ExpressionPropertyInterface(E.transform.mProps.o)
                  },
                  position: {
                      get: ExpressionPropertyInterface(E.transform.mProps.p)
                  },
                  anchorPoint: {
                      get: ExpressionPropertyInterface(E.transform.mProps.a)
                  },
                  scale: {
                      get: ExpressionPropertyInterface(E.transform.mProps.s)
                  },
                  rotation: {
                      get: ExpressionPropertyInterface(E.transform.mProps.r)
                  },
                  skew: {
                      get: ExpressionPropertyInterface(E.transform.mProps.sk)
                  },
                  skewAxis: {
                      get: ExpressionPropertyInterface(E.transform.mProps.sa)
                  },
                  _name: {
                      value: x.nm
                  }
              }),
              C.ty = "tr",
              C.mn = x.mn,
              C.propertyGroup = I,
              C
          }
          function _(x, E, I) {
              function C(w) {
                  return x.p.ix === w ? C.position : x.s.ix === w ? C.size : null
              }
              var A = propertyGroupFactory(C, I);
              C.propertyIndex = x.ix;
              var T = E.sh.ty === "tm" ? E.sh.prop : E.sh;
              return T.s.setGroupProperty(PropertyInterface("Size", A)),
              T.p.setGroupProperty(PropertyInterface("Position", A)),
              Object.defineProperties(C, {
                  size: {
                      get: ExpressionPropertyInterface(T.s)
                  },
                  position: {
                      get: ExpressionPropertyInterface(T.p)
                  },
                  _name: {
                      value: x.nm
                  }
              }),
              C.mn = x.mn,
              C
          }
          function v(x, E, I) {
              function C(w) {
                  return x.p.ix === w ? C.position : x.r.ix === w ? C.rotation : x.pt.ix === w ? C.points : x.or.ix === w || w === "ADBE Vector Star Outer Radius" ? C.outerRadius : x.os.ix === w ? C.outerRoundness : x.ir && (x.ir.ix === w || w === "ADBE Vector Star Inner Radius") ? C.innerRadius : x.is && x.is.ix === w ? C.innerRoundness : null
              }
              var A = propertyGroupFactory(C, I)
                , T = E.sh.ty === "tm" ? E.sh.prop : E.sh;
              return C.propertyIndex = x.ix,
              T.or.setGroupProperty(PropertyInterface("Outer Radius", A)),
              T.os.setGroupProperty(PropertyInterface("Outer Roundness", A)),
              T.pt.setGroupProperty(PropertyInterface("Points", A)),
              T.p.setGroupProperty(PropertyInterface("Position", A)),
              T.r.setGroupProperty(PropertyInterface("Rotation", A)),
              x.ir && (T.ir.setGroupProperty(PropertyInterface("Inner Radius", A)),
              T.is.setGroupProperty(PropertyInterface("Inner Roundness", A))),
              Object.defineProperties(C, {
                  position: {
                      get: ExpressionPropertyInterface(T.p)
                  },
                  rotation: {
                      get: ExpressionPropertyInterface(T.r)
                  },
                  points: {
                      get: ExpressionPropertyInterface(T.pt)
                  },
                  outerRadius: {
                      get: ExpressionPropertyInterface(T.or)
                  },
                  outerRoundness: {
                      get: ExpressionPropertyInterface(T.os)
                  },
                  innerRadius: {
                      get: ExpressionPropertyInterface(T.ir)
                  },
                  innerRoundness: {
                      get: ExpressionPropertyInterface(T.is)
                  },
                  _name: {
                      value: x.nm
                  }
              }),
              C.mn = x.mn,
              C
          }
          function S(x, E, I) {
              function C(w) {
                  return x.p.ix === w ? C.position : x.r.ix === w ? C.roundness : x.s.ix === w || w === "Size" || w === "ADBE Vector Rect Size" ? C.size : null
              }
              var A = propertyGroupFactory(C, I)
                , T = E.sh.ty === "tm" ? E.sh.prop : E.sh;
              return C.propertyIndex = x.ix,
              T.p.setGroupProperty(PropertyInterface("Position", A)),
              T.s.setGroupProperty(PropertyInterface("Size", A)),
              T.r.setGroupProperty(PropertyInterface("Rotation", A)),
              Object.defineProperties(C, {
                  position: {
                      get: ExpressionPropertyInterface(T.p)
                  },
                  roundness: {
                      get: ExpressionPropertyInterface(T.r)
                  },
                  size: {
                      get: ExpressionPropertyInterface(T.s)
                  },
                  _name: {
                      value: x.nm
                  }
              }),
              C.mn = x.mn,
              C
          }
          function b(x, E, I) {
              function C(w) {
                  return x.r.ix === w || w === "Round Corners 1" ? C.radius : null
              }
              var A = propertyGroupFactory(C, I)
                , T = E;
              return C.propertyIndex = x.ix,
              T.rd.setGroupProperty(PropertyInterface("Radius", A)),
              Object.defineProperties(C, {
                  radius: {
                      get: ExpressionPropertyInterface(T.rd)
                  },
                  _name: {
                      value: x.nm
                  }
              }),
              C.mn = x.mn,
              C
          }
          function P(x, E, I) {
              function C(w) {
                  return x.c.ix === w || w === "Copies" ? C.copies : x.o.ix === w || w === "Offset" ? C.offset : null
              }
              var A = propertyGroupFactory(C, I)
                , T = E;
              return C.propertyIndex = x.ix,
              T.c.setGroupProperty(PropertyInterface("Copies", A)),
              T.o.setGroupProperty(PropertyInterface("Offset", A)),
              Object.defineProperties(C, {
                  copies: {
                      get: ExpressionPropertyInterface(T.c)
                  },
                  offset: {
                      get: ExpressionPropertyInterface(T.o)
                  },
                  _name: {
                      value: x.nm
                  }
              }),
              C.mn = x.mn,
              C
          }
          return function(x, E, I) {
              var C;
              function A(w) {
                  if (typeof w == "number")
                      return w = w === void 0 ? 1 : w,
                      w === 0 ? I : C[w - 1];
                  for (var M = 0, F = C.length; M < F; ) {
                      if (C[M]._name === w)
                          return C[M];
                      M += 1
                  }
                  return null
              }
              function T() {
                  return I
              }
              return A.propertyGroup = propertyGroupFactory(A, T),
              C = e(x, E, A.propertyGroup),
              A.numProperties = C.length,
              A._name = "Contents",
              A
          }
      }()
        , TextExpressionInterface = function() {
          return function(e) {
              var t;
              function r(a) {
                  switch (a) {
                  case "ADBE Text Document":
                      return r.sourceText;
                  default:
                      return null
                  }
              }
              return Object.defineProperty(r, "sourceText", {
                  get: function() {
                      e.textProperty.getValue();
                      var o = e.textProperty.currentData.t;
                      return (!t || o !== t.value) && (t = new String(o),
                      t.value = o || new String(o),
                      Object.defineProperty(t, "style", {
                          get: function() {
                              return {
                                  fillColor: e.textProperty.currentData.fc
                              }
                          }
                      })),
                      t
                  }
              }),
              r
          }
      }();
      function _typeof(e) {
          "@babel/helpers - typeof";
          return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof = function(r) {
              return typeof r
          }
          : _typeof = function(r) {
              return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r
          }
          ,
          _typeof(e)
      }
      var FootageInterface = function() {
          var e = function(a) {
              var o = ""
                , l = a.getFootageData();
              function f() {
                  return o = "",
                  l = a.getFootageData(),
                  d
              }
              function d(g) {
                  if (l[g])
                      return o = g,
                      l = l[g],
                      _typeof(l) === "object" ? d : l;
                  var _ = g.indexOf(o);
                  if (_ !== -1) {
                      var v = parseInt(g.substr(_ + o.length), 10);
                      return l = l[v],
                      _typeof(l) === "object" ? d : l
                  }
                  return ""
              }
              return f
          }
            , t = function(a) {
              function o(l) {
                  return l === "Outline" ? o.outlineInterface() : null
              }
              return o._name = "Outline",
              o.outlineInterface = e(a),
              o
          };
          return function(r) {
              function a(o) {
                  return o === "Data" ? a.dataInterface : null
              }
              return a._name = "Data",
              a.dataInterface = t(r),
              a
          }
      }()
        , interfaces = {
          layer: LayerExpressionInterface,
          effects: EffectsExpressionInterface,
          comp: CompExpressionInterface,
          shape: ShapeExpressionInterface,
          text: TextExpressionInterface,
          footage: FootageInterface
      };
      function getInterface(e) {
          return interfaces[e] || null
      }
      var expressionHelpers = function() {
          function e(f, d, g) {
              d.x && (g.k = !0,
              g.x = !0,
              g.initiateExpression = ExpressionManager.initiateExpression,
              g.effectsSequence.push(g.initiateExpression(f, d, g).bind(g)))
          }
          function t(f) {
              return f *= this.elem.globalData.frameRate,
              f -= this.offsetTime,
              f !== this._cachingAtTime.lastFrame && (this._cachingAtTime.lastIndex = this._cachingAtTime.lastFrame < f ? this._cachingAtTime.lastIndex : 0,
              this._cachingAtTime.value = this.interpolateValue(f, this._cachingAtTime),
              this._cachingAtTime.lastFrame = f),
              this._cachingAtTime.value
          }
          function r(f) {
              var d = -.01
                , g = this.getValueAtTime(f)
                , _ = this.getValueAtTime(f + d)
                , v = 0;
              if (g.length) {
                  var S;
                  for (S = 0; S < g.length; S += 1)
                      v += Math.pow(_[S] - g[S], 2);
                  v = Math.sqrt(v) * 100
              } else
                  v = 0;
              return v
          }
          function a(f) {
              if (this.vel !== void 0)
                  return this.vel;
              var d = -.001, g = this.getValueAtTime(f), _ = this.getValueAtTime(f + d), v;
              if (g.length) {
                  v = createTypedArray("float32", g.length);
                  var S;
                  for (S = 0; S < g.length; S += 1)
                      v[S] = (_[S] - g[S]) / d
              } else
                  v = (_ - g) / d;
              return v
          }
          function o() {
              return this.pv
          }
          function l(f) {
              this.propertyGroup = f
          }
          return {
              searchExpressions: e,
              getSpeedAtTime: r,
              getVelocityAtTime: a,
              getValueAtTime: t,
              getStaticValueAtTime: o,
              setGroupProperty: l
          }
      }();
      function addPropertyDecorator() {
          function e(b, P, x) {
              if (!this.k || !this.keyframes)
                  return this.pv;
              b = b ? b.toLowerCase() : "";
              var E = this.comp.renderedFrame
                , I = this.keyframes
                , C = I[I.length - 1].t;
              if (E <= C)
                  return this.pv;
              var A, T;
              x ? (P ? A = Math.abs(C - this.elem.comp.globalData.frameRate * P) : A = Math.max(0, C - this.elem.data.ip),
              T = C - A) : ((!P || P > I.length - 1) && (P = I.length - 1),
              T = I[I.length - 1 - P].t,
              A = C - T);
              var w, M, F;
              if (b === "pingpong") {
                  var O = Math.floor((E - T) / A);
                  if (O % 2 !== 0)
                      return this.getValueAtTime((A - (E - T) % A + T) / this.comp.globalData.frameRate, 0)
              } else if (b === "offset") {
                  var $ = this.getValueAtTime(T / this.comp.globalData.frameRate, 0)
                    , j = this.getValueAtTime(C / this.comp.globalData.frameRate, 0)
                    , K = this.getValueAtTime(((E - T) % A + T) / this.comp.globalData.frameRate, 0)
                    , Y = Math.floor((E - T) / A);
                  if (this.pv.length) {
                      for (F = new Array($.length),
                      M = F.length,
                      w = 0; w < M; w += 1)
                          F[w] = (j[w] - $[w]) * Y + K[w];
                      return F
                  }
                  return (j - $) * Y + K
              } else if (b === "continue") {
                  var W = this.getValueAtTime(C / this.comp.globalData.frameRate, 0)
                    , Z = this.getValueAtTime((C - .001) / this.comp.globalData.frameRate, 0);
                  if (this.pv.length) {
                      for (F = new Array(W.length),
                      M = F.length,
                      w = 0; w < M; w += 1)
                          F[w] = W[w] + (W[w] - Z[w]) * ((E - C) / this.comp.globalData.frameRate) / 5e-4;
                      return F
                  }
                  return W + (W - Z) * ((E - C) / .001)
              }
              return this.getValueAtTime(((E - T) % A + T) / this.comp.globalData.frameRate, 0)
          }
          function t(b, P, x) {
              if (!this.k)
                  return this.pv;
              b = b ? b.toLowerCase() : "";
              var E = this.comp.renderedFrame
                , I = this.keyframes
                , C = I[0].t;
              if (E >= C)
                  return this.pv;
              var A, T;
              x ? (P ? A = Math.abs(this.elem.comp.globalData.frameRate * P) : A = Math.max(0, this.elem.data.op - C),
              T = C + A) : ((!P || P > I.length - 1) && (P = I.length - 1),
              T = I[P].t,
              A = T - C);
              var w, M, F;
              if (b === "pingpong") {
                  var O = Math.floor((C - E) / A);
                  if (O % 2 === 0)
                      return this.getValueAtTime(((C - E) % A + C) / this.comp.globalData.frameRate, 0)
              } else if (b === "offset") {
                  var $ = this.getValueAtTime(C / this.comp.globalData.frameRate, 0)
                    , j = this.getValueAtTime(T / this.comp.globalData.frameRate, 0)
                    , K = this.getValueAtTime((A - (C - E) % A + C) / this.comp.globalData.frameRate, 0)
                    , Y = Math.floor((C - E) / A) + 1;
                  if (this.pv.length) {
                      for (F = new Array($.length),
                      M = F.length,
                      w = 0; w < M; w += 1)
                          F[w] = K[w] - (j[w] - $[w]) * Y;
                      return F
                  }
                  return K - (j - $) * Y
              } else if (b === "continue") {
                  var W = this.getValueAtTime(C / this.comp.globalData.frameRate, 0)
                    , Z = this.getValueAtTime((C + .001) / this.comp.globalData.frameRate, 0);
                  if (this.pv.length) {
                      for (F = new Array(W.length),
                      M = F.length,
                      w = 0; w < M; w += 1)
                          F[w] = W[w] + (W[w] - Z[w]) * (C - E) / .001;
                      return F
                  }
                  return W + (W - Z) * (C - E) / .001
              }
              return this.getValueAtTime((A - ((C - E) % A + C)) / this.comp.globalData.frameRate, 0)
          }
          function r(b, P) {
              if (!this.k)
                  return this.pv;
              if (b = (b || .4) * .5,
              P = Math.floor(P || 5),
              P <= 1)
                  return this.pv;
              var x = this.comp.renderedFrame / this.comp.globalData.frameRate, E = x - b, I = x + b, C = P > 1 ? (I - E) / (P - 1) : 1, A = 0, T = 0, w;
              this.pv.length ? w = createTypedArray("float32", this.pv.length) : w = 0;
              for (var M; A < P; ) {
                  if (M = this.getValueAtTime(E + A * C),
                  this.pv.length)
                      for (T = 0; T < this.pv.length; T += 1)
                          w[T] += M[T];
                  else
                      w += M;
                  A += 1
              }
              if (this.pv.length)
                  for (T = 0; T < this.pv.length; T += 1)
                      w[T] /= P;
              else
                  w /= P;
              return w
          }
          function a(b) {
              this._transformCachingAtTime || (this._transformCachingAtTime = {
                  v: new Matrix
              });
              var P = this._transformCachingAtTime.v;
              if (P.cloneFromProps(this.pre.props),
              this.appliedTransformations < 1) {
                  var x = this.a.getValueAtTime(b);
                  P.translate(-x[0] * this.a.mult, -x[1] * this.a.mult, x[2] * this.a.mult)
              }
              if (this.appliedTransformations < 2) {
                  var E = this.s.getValueAtTime(b);
                  P.scale(E[0] * this.s.mult, E[1] * this.s.mult, E[2] * this.s.mult)
              }
              if (this.sk && this.appliedTransformations < 3) {
                  var I = this.sk.getValueAtTime(b)
                    , C = this.sa.getValueAtTime(b);
                  P.skewFromAxis(-I * this.sk.mult, C * this.sa.mult)
              }
              if (this.r && this.appliedTransformations < 4) {
                  var A = this.r.getValueAtTime(b);
                  P.rotate(-A * this.r.mult)
              } else if (!this.r && this.appliedTransformations < 4) {
                  var T = this.rz.getValueAtTime(b)
                    , w = this.ry.getValueAtTime(b)
                    , M = this.rx.getValueAtTime(b)
                    , F = this.or.getValueAtTime(b);
                  P.rotateZ(-T * this.rz.mult).rotateY(w * this.ry.mult).rotateX(M * this.rx.mult).rotateZ(-F[2] * this.or.mult).rotateY(F[1] * this.or.mult).rotateX(F[0] * this.or.mult)
              }
              if (this.data.p && this.data.p.s) {
                  var O = this.px.getValueAtTime(b)
                    , $ = this.py.getValueAtTime(b);
                  if (this.data.p.z) {
                      var j = this.pz.getValueAtTime(b);
                      P.translate(O * this.px.mult, $ * this.py.mult, -j * this.pz.mult)
                  } else
                      P.translate(O * this.px.mult, $ * this.py.mult, 0)
              } else {
                  var K = this.p.getValueAtTime(b);
                  P.translate(K[0] * this.p.mult, K[1] * this.p.mult, -K[2] * this.p.mult)
              }
              return P
          }
          function o() {
              return this.v.clone(new Matrix)
          }
          var l = TransformPropertyFactory.getTransformProperty;
          TransformPropertyFactory.getTransformProperty = function(b, P, x) {
              var E = l(b, P, x);
              return E.dynamicProperties.length ? E.getValueAtTime = a.bind(E) : E.getValueAtTime = o.bind(E),
              E.setGroupProperty = expressionHelpers.setGroupProperty,
              E
          }
          ;
          var f = PropertyFactory.getProp;
          PropertyFactory.getProp = function(b, P, x, E, I) {
              var C = f(b, P, x, E, I);
              C.kf ? C.getValueAtTime = expressionHelpers.getValueAtTime.bind(C) : C.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(C),
              C.setGroupProperty = expressionHelpers.setGroupProperty,
              C.loopOut = e,
              C.loopIn = t,
              C.smooth = r,
              C.getVelocityAtTime = expressionHelpers.getVelocityAtTime.bind(C),
              C.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(C),
              C.numKeys = P.a === 1 ? P.k.length : 0,
              C.propertyIndex = P.ix;
              var A = 0;
              return x !== 0 && (A = createTypedArray("float32", P.a === 1 ? P.k[0].s.length : P.k.length)),
              C._cachingAtTime = {
                  lastFrame: initialDefaultFrame,
                  lastIndex: 0,
                  value: A
              },
              expressionHelpers.searchExpressions(b, P, C),
              C.k && I.addDynamicProperty(C),
              C
          }
          ;
          function d(b) {
              return this._cachingAtTime || (this._cachingAtTime = {
                  shapeValue: shapePool.clone(this.pv),
                  lastIndex: 0,
                  lastTime: initialDefaultFrame
              }),
              b *= this.elem.globalData.frameRate,
              b -= this.offsetTime,
              b !== this._cachingAtTime.lastTime && (this._cachingAtTime.lastIndex = this._cachingAtTime.lastTime < b ? this._caching.lastIndex : 0,
              this._cachingAtTime.lastTime = b,
              this.interpolateShape(b, this._cachingAtTime.shapeValue, this._cachingAtTime)),
              this._cachingAtTime.shapeValue
          }
          var g = ShapePropertyFactory.getConstructorFunction()
            , _ = ShapePropertyFactory.getKeyframedConstructorFunction();
          function v() {}
          v.prototype = {
              vertices: function(P, x) {
                  this.k && this.getValue();
                  var E = this.v;
                  x !== void 0 && (E = this.getValueAtTime(x, 0));
                  var I, C = E._length, A = E[P], T = E.v, w = createSizedArray(C);
                  for (I = 0; I < C; I += 1)
                      P === "i" || P === "o" ? w[I] = [A[I][0] - T[I][0], A[I][1] - T[I][1]] : w[I] = [A[I][0], A[I][1]];
                  return w
              },
              points: function(P) {
                  return this.vertices("v", P)
              },
              inTangents: function(P) {
                  return this.vertices("i", P)
              },
              outTangents: function(P) {
                  return this.vertices("o", P)
              },
              isClosed: function() {
                  return this.v.c
              },
              pointOnPath: function(P, x) {
                  var E = this.v;
                  x !== void 0 && (E = this.getValueAtTime(x, 0)),
                  this._segmentsLength || (this._segmentsLength = bez.getSegmentsLength(E));
                  for (var I = this._segmentsLength, C = I.lengths, A = I.totalLength * P, T = 0, w = C.length, M = 0, F; T < w; ) {
                      if (M + C[T].addedLength > A) {
                          var O = T
                            , $ = E.c && T === w - 1 ? 0 : T + 1
                            , j = (A - M) / C[T].addedLength;
                          F = bez.getPointInSegment(E.v[O], E.v[$], E.o[O], E.i[$], j, C[T]);
                          break
                      } else
                          M += C[T].addedLength;
                      T += 1
                  }
                  return F || (F = E.c ? [E.v[0][0], E.v[0][1]] : [E.v[E._length - 1][0], E.v[E._length - 1][1]]),
                  F
              },
              vectorOnPath: function(P, x, E) {
                  P == 1 ? P = this.v.c : P == 0 && (P = .999);
                  var I = this.pointOnPath(P, x)
                    , C = this.pointOnPath(P + .001, x)
                    , A = C[0] - I[0]
                    , T = C[1] - I[1]
                    , w = Math.sqrt(Math.pow(A, 2) + Math.pow(T, 2));
                  if (w === 0)
                      return [0, 0];
                  var M = E === "tangent" ? [A / w, T / w] : [-T / w, A / w];
                  return M
              },
              tangentOnPath: function(P, x) {
                  return this.vectorOnPath(P, x, "tangent")
              },
              normalOnPath: function(P, x) {
                  return this.vectorOnPath(P, x, "normal")
              },
              setGroupProperty: expressionHelpers.setGroupProperty,
              getValueAtTime: expressionHelpers.getStaticValueAtTime
          },
          extendPrototype([v], g),
          extendPrototype([v], _),
          _.prototype.getValueAtTime = d,
          _.prototype.initiateExpression = ExpressionManager.initiateExpression;
          var S = ShapePropertyFactory.getShapeProp;
          ShapePropertyFactory.getShapeProp = function(b, P, x, E, I) {
              var C = S(b, P, x, E, I);
              return C.propertyIndex = P.ix,
              C.lock = !1,
              x === 3 ? expressionHelpers.searchExpressions(b, P.pt, C) : x === 4 && expressionHelpers.searchExpressions(b, P.ks, C),
              C.k && b.addDynamicProperty(C),
              C
          }
      }
      function initialize$1() {
          addPropertyDecorator()
      }
      function addDecorator() {
          function e() {
              return this.data.d.x ? (this.calculateExpression = ExpressionManager.initiateExpression.bind(this)(this.elem, this.data.d, this),
              this.addEffect(this.getExpressionValue.bind(this)),
              !0) : null
          }
          TextProperty.prototype.getExpressionValue = function(t, r) {
              var a = this.calculateExpression(r);
              if (t.t !== a) {
                  var o = {};
                  return this.copyData(o, t),
                  o.t = a.toString(),
                  o.__complete = !1,
                  o
              }
              return t
          }
          ,
          TextProperty.prototype.searchProperty = function() {
              var t = this.searchKeyframes()
                , r = this.searchExpressions();
              return this.kf = t || r,
              this.kf
          }
          ,
          TextProperty.prototype.searchExpressions = e
      }
      function initialize() {
          addDecorator()
      }
      function SVGComposableEffect() {}
      SVGComposableEffect.prototype = {
          createMergeNode: function e(t, r) {
              var a = createNS("feMerge");
              a.setAttribute("result", t);
              var o, l;
              for (l = 0; l < r.length; l += 1)
                  o = createNS("feMergeNode"),
                  o.setAttribute("in", r[l]),
                  a.appendChild(o),
                  a.appendChild(o);
              return a
          }
      };
      var linearFilterValue = "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0";
      function SVGTintFilter(e, t, r, a, o) {
          this.filterManager = t;
          var l = createNS("feColorMatrix");
          l.setAttribute("type", "matrix"),
          l.setAttribute("color-interpolation-filters", "linearRGB"),
          l.setAttribute("values", linearFilterValue + " 1 0"),
          this.linearFilter = l,
          l.setAttribute("result", a + "_tint_1"),
          e.appendChild(l),
          l = createNS("feColorMatrix"),
          l.setAttribute("type", "matrix"),
          l.setAttribute("color-interpolation-filters", "sRGB"),
          l.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"),
          l.setAttribute("result", a + "_tint_2"),
          e.appendChild(l),
          this.matrixFilter = l;
          var f = this.createMergeNode(a, [o, a + "_tint_1", a + "_tint_2"]);
          e.appendChild(f)
      }
      extendPrototype([SVGComposableEffect], SVGTintFilter),
      SVGTintFilter.prototype.renderFrame = function(e) {
          if (e || this.filterManager._mdf) {
              var t = this.filterManager.effectElements[0].p.v
                , r = this.filterManager.effectElements[1].p.v
                , a = this.filterManager.effectElements[2].p.v / 100;
              this.linearFilter.setAttribute("values", linearFilterValue + " " + a + " 0"),
              this.matrixFilter.setAttribute("values", r[0] - t[0] + " 0 0 0 " + t[0] + " " + (r[1] - t[1]) + " 0 0 0 " + t[1] + " " + (r[2] - t[2]) + " 0 0 0 " + t[2] + " 0 0 0 1 0")
          }
      }
      ;
      function SVGFillFilter(e, t, r, a) {
          this.filterManager = t;
          var o = createNS("feColorMatrix");
          o.setAttribute("type", "matrix"),
          o.setAttribute("color-interpolation-filters", "sRGB"),
          o.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"),
          o.setAttribute("result", a),
          e.appendChild(o),
          this.matrixFilter = o
      }
      SVGFillFilter.prototype.renderFrame = function(e) {
          if (e || this.filterManager._mdf) {
              var t = this.filterManager.effectElements[2].p.v
                , r = this.filterManager.effectElements[6].p.v;
              this.matrixFilter.setAttribute("values", "0 0 0 0 " + t[0] + " 0 0 0 0 " + t[1] + " 0 0 0 0 " + t[2] + " 0 0 0 " + r + " 0")
          }
      }
      ;
      function SVGStrokeEffect(e, t, r) {
          this.initialized = !1,
          this.filterManager = t,
          this.elem = r,
          this.paths = []
      }
      SVGStrokeEffect.prototype.initialize = function() {
          var e = this.elem.layerElement.children || this.elem.layerElement.childNodes, t, r, a, o;
          for (this.filterManager.effectElements[1].p.v === 1 ? (o = this.elem.maskManager.masksProperties.length,
          a = 0) : (a = this.filterManager.effectElements[0].p.v - 1,
          o = a + 1),
          r = createNS("g"),
          r.setAttribute("fill", "none"),
          r.setAttribute("stroke-linecap", "round"),
          r.setAttribute("stroke-dashoffset", 1),
          a; a < o; a += 1)
              t = createNS("path"),
              r.appendChild(t),
              this.paths.push({
                  p: t,
                  m: a
              });
          if (this.filterManager.effectElements[10].p.v === 3) {
              var l = createNS("mask")
                , f = createElementID();
              l.setAttribute("id", f),
              l.setAttribute("mask-type", "alpha"),
              l.appendChild(r),
              this.elem.globalData.defs.appendChild(l);
              var d = createNS("g");
              for (d.setAttribute("mask", "url(" + getLocationHref() + "#" + f + ")"); e[0]; )
                  d.appendChild(e[0]);
              this.elem.layerElement.appendChild(d),
              this.masker = l,
              r.setAttribute("stroke", "#fff")
          } else if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {
              if (this.filterManager.effectElements[10].p.v === 2)
                  for (e = this.elem.layerElement.children || this.elem.layerElement.childNodes; e.length; )
                      this.elem.layerElement.removeChild(e[0]);
              this.elem.layerElement.appendChild(r),
              this.elem.layerElement.removeAttribute("mask"),
              r.setAttribute("stroke", "#fff")
          }
          this.initialized = !0,
          this.pathMasker = r
      }
      ,
      SVGStrokeEffect.prototype.renderFrame = function(e) {
          this.initialized || this.initialize();
          var t, r = this.paths.length, a, o;
          for (t = 0; t < r; t += 1)
              if (this.paths[t].m !== -1 && (a = this.elem.maskManager.viewData[this.paths[t].m],
              o = this.paths[t].p,
              (e || this.filterManager._mdf || a.prop._mdf) && o.setAttribute("d", a.lastPath),
              e || this.filterManager.effectElements[9].p._mdf || this.filterManager.effectElements[4].p._mdf || this.filterManager.effectElements[7].p._mdf || this.filterManager.effectElements[8].p._mdf || a.prop._mdf)) {
                  var l;
                  if (this.filterManager.effectElements[7].p.v !== 0 || this.filterManager.effectElements[8].p.v !== 100) {
                      var f = Math.min(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * .01
                        , d = Math.max(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * .01
                        , g = o.getTotalLength();
                      l = "0 0 0 " + g * f + " ";
                      var _ = g * (d - f), v = 1 + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * .01, S = Math.floor(_ / v), b;
                      for (b = 0; b < S; b += 1)
                          l += "1 " + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * .01 + " ";
                      l += "0 " + g * 10 + " 0 0"
                  } else
                      l = "1 " + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * .01;
                  o.setAttribute("stroke-dasharray", l)
              }
          if ((e || this.filterManager.effectElements[4].p._mdf) && this.pathMasker.setAttribute("stroke-width", this.filterManager.effectElements[4].p.v * 2),
          (e || this.filterManager.effectElements[6].p._mdf) && this.pathMasker.setAttribute("opacity", this.filterManager.effectElements[6].p.v),
          (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) && (e || this.filterManager.effectElements[3].p._mdf)) {
              var P = this.filterManager.effectElements[3].p.v;
              this.pathMasker.setAttribute("stroke", "rgb(" + bmFloor(P[0] * 255) + "," + bmFloor(P[1] * 255) + "," + bmFloor(P[2] * 255) + ")")
          }
      }
      ;
      function SVGTritoneFilter(e, t, r, a) {
          this.filterManager = t;
          var o = createNS("feColorMatrix");
          o.setAttribute("type", "matrix"),
          o.setAttribute("color-interpolation-filters", "linearRGB"),
          o.setAttribute("values", "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0"),
          e.appendChild(o);
          var l = createNS("feComponentTransfer");
          l.setAttribute("color-interpolation-filters", "sRGB"),
          l.setAttribute("result", a),
          this.matrixFilter = l;
          var f = createNS("feFuncR");
          f.setAttribute("type", "table"),
          l.appendChild(f),
          this.feFuncR = f;
          var d = createNS("feFuncG");
          d.setAttribute("type", "table"),
          l.appendChild(d),
          this.feFuncG = d;
          var g = createNS("feFuncB");
          g.setAttribute("type", "table"),
          l.appendChild(g),
          this.feFuncB = g,
          e.appendChild(l)
      }
      SVGTritoneFilter.prototype.renderFrame = function(e) {
          if (e || this.filterManager._mdf) {
              var t = this.filterManager.effectElements[0].p.v
                , r = this.filterManager.effectElements[1].p.v
                , a = this.filterManager.effectElements[2].p.v
                , o = a[0] + " " + r[0] + " " + t[0]
                , l = a[1] + " " + r[1] + " " + t[1]
                , f = a[2] + " " + r[2] + " " + t[2];
              this.feFuncR.setAttribute("tableValues", o),
              this.feFuncG.setAttribute("tableValues", l),
              this.feFuncB.setAttribute("tableValues", f)
          }
      }
      ;
      function SVGProLevelsFilter(e, t, r, a) {
          this.filterManager = t;
          var o = this.filterManager.effectElements
            , l = createNS("feComponentTransfer");
          (o[10].p.k || o[10].p.v !== 0 || o[11].p.k || o[11].p.v !== 1 || o[12].p.k || o[12].p.v !== 1 || o[13].p.k || o[13].p.v !== 0 || o[14].p.k || o[14].p.v !== 1) && (this.feFuncR = this.createFeFunc("feFuncR", l)),
          (o[17].p.k || o[17].p.v !== 0 || o[18].p.k || o[18].p.v !== 1 || o[19].p.k || o[19].p.v !== 1 || o[20].p.k || o[20].p.v !== 0 || o[21].p.k || o[21].p.v !== 1) && (this.feFuncG = this.createFeFunc("feFuncG", l)),
          (o[24].p.k || o[24].p.v !== 0 || o[25].p.k || o[25].p.v !== 1 || o[26].p.k || o[26].p.v !== 1 || o[27].p.k || o[27].p.v !== 0 || o[28].p.k || o[28].p.v !== 1) && (this.feFuncB = this.createFeFunc("feFuncB", l)),
          (o[31].p.k || o[31].p.v !== 0 || o[32].p.k || o[32].p.v !== 1 || o[33].p.k || o[33].p.v !== 1 || o[34].p.k || o[34].p.v !== 0 || o[35].p.k || o[35].p.v !== 1) && (this.feFuncA = this.createFeFunc("feFuncA", l)),
          (this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA) && (l.setAttribute("color-interpolation-filters", "sRGB"),
          e.appendChild(l)),
          (o[3].p.k || o[3].p.v !== 0 || o[4].p.k || o[4].p.v !== 1 || o[5].p.k || o[5].p.v !== 1 || o[6].p.k || o[6].p.v !== 0 || o[7].p.k || o[7].p.v !== 1) && (l = createNS("feComponentTransfer"),
          l.setAttribute("color-interpolation-filters", "sRGB"),
          l.setAttribute("result", a),
          e.appendChild(l),
          this.feFuncRComposed = this.createFeFunc("feFuncR", l),
          this.feFuncGComposed = this.createFeFunc("feFuncG", l),
          this.feFuncBComposed = this.createFeFunc("feFuncB", l))
      }
      SVGProLevelsFilter.prototype.createFeFunc = function(e, t) {
          var r = createNS(e);
          return r.setAttribute("type", "table"),
          t.appendChild(r),
          r
      }
      ,
      SVGProLevelsFilter.prototype.getTableValue = function(e, t, r, a, o) {
          for (var l = 0, f = 256, d, g = Math.min(e, t), _ = Math.max(e, t), v = Array.call(null, {
              length: f
          }), S, b = 0, P = o - a, x = t - e; l <= 256; )
              d = l / 256,
              d <= g ? S = x < 0 ? o : a : d >= _ ? S = x < 0 ? a : o : S = a + P * Math.pow((d - e) / x, 1 / r),
              v[b] = S,
              b += 1,
              l += 256 / (f - 1);
          return v.join(" ")
      }
      ,
      SVGProLevelsFilter.prototype.renderFrame = function(e) {
          if (e || this.filterManager._mdf) {
              var t, r = this.filterManager.effectElements;
              this.feFuncRComposed && (e || r[3].p._mdf || r[4].p._mdf || r[5].p._mdf || r[6].p._mdf || r[7].p._mdf) && (t = this.getTableValue(r[3].p.v, r[4].p.v, r[5].p.v, r[6].p.v, r[7].p.v),
              this.feFuncRComposed.setAttribute("tableValues", t),
              this.feFuncGComposed.setAttribute("tableValues", t),
              this.feFuncBComposed.setAttribute("tableValues", t)),
              this.feFuncR && (e || r[10].p._mdf || r[11].p._mdf || r[12].p._mdf || r[13].p._mdf || r[14].p._mdf) && (t = this.getTableValue(r[10].p.v, r[11].p.v, r[12].p.v, r[13].p.v, r[14].p.v),
              this.feFuncR.setAttribute("tableValues", t)),
              this.feFuncG && (e || r[17].p._mdf || r[18].p._mdf || r[19].p._mdf || r[20].p._mdf || r[21].p._mdf) && (t = this.getTableValue(r[17].p.v, r[18].p.v, r[19].p.v, r[20].p.v, r[21].p.v),
              this.feFuncG.setAttribute("tableValues", t)),
              this.feFuncB && (e || r[24].p._mdf || r[25].p._mdf || r[26].p._mdf || r[27].p._mdf || r[28].p._mdf) && (t = this.getTableValue(r[24].p.v, r[25].p.v, r[26].p.v, r[27].p.v, r[28].p.v),
              this.feFuncB.setAttribute("tableValues", t)),
              this.feFuncA && (e || r[31].p._mdf || r[32].p._mdf || r[33].p._mdf || r[34].p._mdf || r[35].p._mdf) && (t = this.getTableValue(r[31].p.v, r[32].p.v, r[33].p.v, r[34].p.v, r[35].p.v),
              this.feFuncA.setAttribute("tableValues", t))
          }
      }
      ;
      function SVGDropShadowEffect(e, t, r, a, o) {
          var l = t.container.globalData.renderConfig.filterSize
            , f = t.data.fs || l;
          e.setAttribute("x", f.x || l.x),
          e.setAttribute("y", f.y || l.y),
          e.setAttribute("width", f.width || l.width),
          e.setAttribute("height", f.height || l.height),
          this.filterManager = t;
          var d = createNS("feGaussianBlur");
          d.setAttribute("in", "SourceAlpha"),
          d.setAttribute("result", a + "_drop_shadow_1"),
          d.setAttribute("stdDeviation", "0"),
          this.feGaussianBlur = d,
          e.appendChild(d);
          var g = createNS("feOffset");
          g.setAttribute("dx", "25"),
          g.setAttribute("dy", "0"),
          g.setAttribute("in", a + "_drop_shadow_1"),
          g.setAttribute("result", a + "_drop_shadow_2"),
          this.feOffset = g,
          e.appendChild(g);
          var _ = createNS("feFlood");
          _.setAttribute("flood-color", "#00ff00"),
          _.setAttribute("flood-opacity", "1"),
          _.setAttribute("result", a + "_drop_shadow_3"),
          this.feFlood = _,
          e.appendChild(_);
          var v = createNS("feComposite");
          v.setAttribute("in", a + "_drop_shadow_3"),
          v.setAttribute("in2", a + "_drop_shadow_2"),
          v.setAttribute("operator", "in"),
          v.setAttribute("result", a + "_drop_shadow_4"),
          e.appendChild(v);
          var S = this.createMergeNode(a, [a + "_drop_shadow_4", o]);
          e.appendChild(S)
      }
      extendPrototype([SVGComposableEffect], SVGDropShadowEffect),
      SVGDropShadowEffect.prototype.renderFrame = function(e) {
          if (e || this.filterManager._mdf) {
              if ((e || this.filterManager.effectElements[4].p._mdf) && this.feGaussianBlur.setAttribute("stdDeviation", this.filterManager.effectElements[4].p.v / 4),
              e || this.filterManager.effectElements[0].p._mdf) {
                  var t = this.filterManager.effectElements[0].p.v;
                  this.feFlood.setAttribute("flood-color", rgbToHex(Math.round(t[0] * 255), Math.round(t[1] * 255), Math.round(t[2] * 255)))
              }
              if ((e || this.filterManager.effectElements[1].p._mdf) && this.feFlood.setAttribute("flood-opacity", this.filterManager.effectElements[1].p.v / 255),
              e || this.filterManager.effectElements[2].p._mdf || this.filterManager.effectElements[3].p._mdf) {
                  var r = this.filterManager.effectElements[3].p.v
                    , a = (this.filterManager.effectElements[2].p.v - 90) * degToRads
                    , o = r * Math.cos(a)
                    , l = r * Math.sin(a);
                  this.feOffset.setAttribute("dx", o),
                  this.feOffset.setAttribute("dy", l)
              }
          }
      }
      ;
      var _svgMatteSymbols = [];
      function SVGMatte3Effect(e, t, r) {
          this.initialized = !1,
          this.filterManager = t,
          this.filterElem = e,
          this.elem = r,
          r.matteElement = createNS("g"),
          r.matteElement.appendChild(r.layerElement),
          r.matteElement.appendChild(r.transformedElement),
          r.baseElement = r.matteElement
      }
      SVGMatte3Effect.prototype.findSymbol = function(e) {
          for (var t = 0, r = _svgMatteSymbols.length; t < r; ) {
              if (_svgMatteSymbols[t] === e)
                  return _svgMatteSymbols[t];
              t += 1
          }
          return null
      }
      ,
      SVGMatte3Effect.prototype.replaceInParent = function(e, t) {
          var r = e.layerElement.parentNode;
          if (r) {
              for (var a = r.children, o = 0, l = a.length; o < l && a[o] !== e.layerElement; )
                  o += 1;
              var f;
              o <= l - 2 && (f = a[o + 1]);
              var d = createNS("use");
              d.setAttribute("href", "#" + t),
              f ? r.insertBefore(d, f) : r.appendChild(d)
          }
      }
      ,
      SVGMatte3Effect.prototype.setElementAsMask = function(e, t) {
          if (!this.findSymbol(t)) {
              var r = createElementID()
                , a = createNS("mask");
              a.setAttribute("id", t.layerId),
              a.setAttribute("mask-type", "alpha"),
              _svgMatteSymbols.push(t);
              var o = e.globalData.defs;
              o.appendChild(a);
              var l = createNS("symbol");
              l.setAttribute("id", r),
              this.replaceInParent(t, r),
              l.appendChild(t.layerElement),
              o.appendChild(l);
              var f = createNS("use");
              f.setAttribute("href", "#" + r),
              a.appendChild(f),
              t.data.hd = !1,
              t.show()
          }
          e.setMatte(t.layerId)
      }
      ,
      SVGMatte3Effect.prototype.initialize = function() {
          for (var e = this.filterManager.effectElements[0].p.v, t = this.elem.comp.elements, r = 0, a = t.length; r < a; )
              t[r] && t[r].data.ind === e && this.setElementAsMask(this.elem, t[r]),
              r += 1;
          this.initialized = !0
      }
      ,
      SVGMatte3Effect.prototype.renderFrame = function() {
          this.initialized || this.initialize()
      }
      ;
      function SVGGaussianBlurEffect(e, t, r, a) {
          e.setAttribute("x", "-100%"),
          e.setAttribute("y", "-100%"),
          e.setAttribute("width", "300%"),
          e.setAttribute("height", "300%"),
          this.filterManager = t;
          var o = createNS("feGaussianBlur");
          o.setAttribute("result", a),
          e.appendChild(o),
          this.feGaussianBlur = o
      }
      SVGGaussianBlurEffect.prototype.renderFrame = function(e) {
          if (e || this.filterManager._mdf) {
              var t = .3
                , r = this.filterManager.effectElements[0].p.v * t
                , a = this.filterManager.effectElements[1].p.v
                , o = a == 3 ? 0 : r
                , l = a == 2 ? 0 : r;
              this.feGaussianBlur.setAttribute("stdDeviation", o + " " + l);
              var f = this.filterManager.effectElements[2].p.v == 1 ? "wrap" : "duplicate";
              this.feGaussianBlur.setAttribute("edgeMode", f)
          }
      }
      ;
      function TransformEffect() {}
      TransformEffect.prototype.init = function(e) {
          this.effectsManager = e,
          this.type = effectTypes.TRANSFORM_EFFECT,
          this.matrix = new Matrix,
          this.opacity = -1,
          this._mdf = !1,
          this._opMdf = !1
      }
      ,
      TransformEffect.prototype.renderFrame = function(e) {
          if (this._opMdf = !1,
          this._mdf = !1,
          e || this.effectsManager._mdf) {
              var t = this.effectsManager.effectElements
                , r = t[0].p.v
                , a = t[1].p.v
                , o = t[2].p.v === 1
                , l = t[3].p.v
                , f = o ? l : t[4].p.v
                , d = t[5].p.v
                , g = t[6].p.v
                , _ = t[7].p.v;
              this.matrix.reset(),
              this.matrix.translate(-r[0], -r[1], r[2]),
              this.matrix.scale(f * .01, l * .01, 1),
              this.matrix.rotate(-_ * degToRads),
              this.matrix.skewFromAxis(-d * degToRads, (g + 90) * degToRads),
              this.matrix.translate(a[0], a[1], 0),
              this._mdf = !0,
              this.opacity !== t[8].p.v && (this.opacity = t[8].p.v,
              this._opMdf = !0)
          }
      }
      ;
      function SVGTransformEffect(e, t) {
          this.init(t)
      }
      extendPrototype([TransformEffect], SVGTransformEffect);
      function CVTransformEffect(e) {
          this.init(e)
      }
      return extendPrototype([TransformEffect], CVTransformEffect),
      registerRenderer("canvas", CanvasRenderer),
      registerRenderer("html", HybridRenderer),
      registerRenderer("svg", SVGRenderer),
      ShapeModifiers.registerModifier("tm", TrimModifier),
      ShapeModifiers.registerModifier("pb", PuckerAndBloatModifier),
      ShapeModifiers.registerModifier("rp", RepeaterModifier),
      ShapeModifiers.registerModifier("rd", RoundCornersModifier),
      ShapeModifiers.registerModifier("zz", ZigZagModifier),
      ShapeModifiers.registerModifier("op", OffsetPathModifier),
      setExpressionsPlugin(Expressions),
      setExpressionInterfaces(getInterface),
      initialize$1(),
      initialize(),
      registerEffect$1(20, SVGTintFilter, !0),
      registerEffect$1(21, SVGFillFilter, !0),
      registerEffect$1(22, SVGStrokeEffect, !1),
      registerEffect$1(23, SVGTritoneFilter, !0),
      registerEffect$1(24, SVGProLevelsFilter, !0),
      registerEffect$1(25, SVGDropShadowEffect, !0),
      registerEffect$1(28, SVGMatte3Effect, !1),
      registerEffect$1(29, SVGGaussianBlurEffect, !0),
      registerEffect$1(35, SVGTransformEffect, !1),
      registerEffect(35, CVTransformEffect),
      lottie
  })
}
)(lottie$1, lottie$1.exports);
var lottieExports = lottie$1.exports;
const lottie = getDefaultExportFromCjs(lottieExports);
(function() {
  try {
      if (typeof document < "u") {
          var e = document.createElement("style");
          e.appendChild(document.createTextNode(".lottie-animation-container{width:var(--lottie-animation-container-width);height:var(--lottie-animation-container-height);background-color:var(--lottie-animation-container-background-color);overflow:hidden;margin:var(--lottie-animation-margin)}.lottie-animation-container svg{transform:scale(var(--lottie-animation-scale))}")),
          document.head.appendChild(e)
      }
  } catch (t) {
      console.error("vite-plugin-css-injected-by-js", t)
  }
}
)();
var __defProp = Object.defineProperty
, __defProps = Object.defineProperties
, __getOwnPropDescs = Object.getOwnPropertyDescriptors
, __getOwnPropSymbols = Object.getOwnPropertySymbols
, __hasOwnProp = Object.prototype.hasOwnProperty
, __propIsEnum = Object.prototype.propertyIsEnumerable
, __defNormalProp = (e,t,r)=>t in e ? __defProp(e, t, {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: r
}) : e[t] = r
, __spreadValues = (e,t)=>{
  for (var r in t || (t = {}))
      __hasOwnProp.call(t, r) && __defNormalProp(e, r, t[r]);
  if (__getOwnPropSymbols)
      for (var r of __getOwnPropSymbols(t))
          __propIsEnum.call(t, r) && __defNormalProp(e, r, t[r]);
  return e
}
, __spreadProps = (e,t)=>__defProps(e, __getOwnPropDescs(t))
, es6 = function e(t, r) {
  if (t === r)
      return !0;
  if (t && r && typeof t == "object" && typeof r == "object") {
      if (t.constructor !== r.constructor)
          return !1;
      var a, o, l;
      if (Array.isArray(t)) {
          if (a = t.length,
          a != r.length)
              return !1;
          for (o = a; o-- !== 0; )
              if (!e(t[o], r[o]))
                  return !1;
          return !0
      }
      if (t instanceof Map && r instanceof Map) {
          if (t.size !== r.size)
              return !1;
          for (o of t.entries())
              if (!r.has(o[0]))
                  return !1;
          for (o of t.entries())
              if (!e(o[1], r.get(o[0])))
                  return !1;
          return !0
      }
      if (t instanceof Set && r instanceof Set) {
          if (t.size !== r.size)
              return !1;
          for (o of t.entries())
              if (!r.has(o[0]))
                  return !1;
          return !0
      }
      if (ArrayBuffer.isView(t) && ArrayBuffer.isView(r)) {
          if (a = t.length,
          a != r.length)
              return !1;
          for (o = a; o-- !== 0; )
              if (t[o] !== r[o])
                  return !1;
          return !0
      }
      if (t.constructor === RegExp)
          return t.source === r.source && t.flags === r.flags;
      if (t.valueOf !== Object.prototype.valueOf)
          return t.valueOf() === r.valueOf();
      if (t.toString !== Object.prototype.toString)
          return t.toString() === r.toString();
      if (l = Object.keys(t),
      a = l.length,
      a !== Object.keys(r).length)
          return !1;
      for (o = a; o-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(r, l[o]))
              return !1;
      for (o = a; o-- !== 0; ) {
          var f = l[o];
          if (!e(t[f], r[f]))
              return !1
      }
      return !0
  }
  return t !== t && r !== r
};
function klona(e) {
  var t, r, a;
  if (Array.isArray(e)) {
      for (r = Array(t = e.length); t--; )
          r[t] = (a = e[t]) && typeof a == "object" ? klona(a) : a;
      return r
  }
  if (Object.prototype.toString.call(e) === "[object Object]") {
      r = {};
      for (t in e)
          t === "__proto__" ? Object.defineProperty(r, t, {
              value: klona(e[t]),
              configurable: !0,
              enumerable: !0,
              writable: !0
          }) : r[t] = (a = e[t]) && typeof a == "object" ? klona(a) : a;
      return r
  }
  return e
}
var _export_sfc$1 = (e,t)=>{
  const r = e.__vccOpts || e;
  for (const [a,o] of t)
      r[a] = o;
  return r
}
;
const _sfc_main$5 = defineComponent({
  props: {
      animationData: {
          type: Object,
          default: ()=>({})
      },
      animationLink: {
          type: String,
          default: ""
      },
      loop: {
          type: [Boolean, Number],
          default: !0
      },
      autoPlay: {
          type: Boolean,
          default: !0
      },
      width: {
          type: [Number, String],
          default: "100%"
      },
      height: {
          type: [Number, String],
          default: "100%"
      },
      speed: {
          type: Number,
          default: 1
      },
      delay: {
          type: Number,
          default: 0
      },
      direction: {
          type: String,
          default: "forward"
      },
      pauseOnHover: {
          type: Boolean,
          default: !1
      },
      playOnHover: {
          type: Boolean,
          default: !1
      },
      backgroundColor: {
          type: String,
          default: "transparent"
      },
      pauseAnimation: {
          type: Boolean,
          default: !1
      },
      noMargin: {
          type: Boolean,
          default: !1
      },
      scale: {
          type: Number,
          default: 1
      },
      renderer: {
          type: String,
          default: "svg"
      },
      rendererSettings: {
          type: Object,
          default: ()=>({})
      },
      assetsPath: {
          type: String,
          default: ""
      }
  },
  emits: {
      onComplete: null,
      onLoopComplete: null,
      onEnterFrame: null,
      onSegmentStart: null,
      onAnimationLoaded: null
  },
  setup(e, {emit: t}) {
      const r = ref();
      let a, o = null, l = 1;
      watchEffect(async()=>{
          if (r.value) {
              if (e.animationLink != "")
                  try {
                      a = await (await fetch(e.animationLink)).json()
                  } catch (F) {
                      console.error(F);
                      return
                  }
              else if (es6(e.animationData, {}) === !1)
                  a = klona(e.animationData);
              else
                  throw new Error("You must provide either animationLink or animationData");
              f()
          }
      }
      );
      const f = ()=>{
          if (!r.value || !a)
              return;
          o == null || o.destroy(),
          o = null;
          let F = e.autoPlay
            , O = e.loop;
          e.playOnHover && (F = !1),
          typeof O == "number" && O > 0 && (O = O - 1),
          e.delay > 0 && (F = !1);
          const $ = {
              container: r.value,
              renderer: e.renderer,
              loop: O,
              autoplay: F,
              animationData: a,
              assetsPath: e.assetsPath
          };
          es6(e.rendererSettings, {}) === !1 && ($.rendererSettings = e.rendererSettings),
          e.scale !== 1 && ($.rendererSettings = __spreadProps(__spreadValues({}, $.rendererSettings), {
              viewBoxOnly: !0
          })),
          o = lottie.loadAnimation($),
          setTimeout(()=>{
              F = e.autoPlay,
              e.playOnHover ? o == null || o.pause() : F ? o == null || o.play() : o == null || o.pause(),
              t("onAnimationLoaded")
          }
          , e.delay),
          o.setSpeed(e.speed),
          e.direction === "reverse" && o.setDirection(-1),
          e.direction === "normal" && o.setDirection(1),
          (e.pauseAnimation || e.playOnHover) && o.pause(),
          o.addEventListener("loopComplete", ()=>{
              e.direction === "alternate" && (o == null || o.stop(),
              l = l === -1 ? 1 : -1,
              o == null || o.setDirection(l),
              o == null || o.play()),
              t("onLoopComplete")
          }
          ),
          o.addEventListener("complete", ()=>{
              t("onComplete")
          }
          ),
          o.addEventListener("enterFrame", ()=>{
              t("onEnterFrame")
          }
          ),
          o.addEventListener("segmentStart", ()=>{
              t("onSegmentStart")
          }
          )
      }
        , d = computed(()=>{
          let F = e.width
            , O = e.height;
          return typeof e.width == "number" && (F = `${e.width}px`),
          typeof e.height == "number" && (O = `${e.height}px`),
          {
              "--lottie-animation-container-width": F,
              "--lottie-animation-container-height": O,
              "--lottie-animation-container-background-color": e.backgroundColor,
              "--lottie-animation-margin": e.noMargin ? "0" : "0 auto",
              "--lottie-animation-scale": e.scale != 1 ? e.scale : ""
          }
      }
      )
        , g = ()=>{
          o && e.pauseOnHover && o.pause(),
          o && e.playOnHover && o.play()
      }
        , _ = ()=>{
          o && e.pauseOnHover && o.play(),
          o && e.playOnHover && o.pause()
      }
      ;
      return watch(()=>e.pauseAnimation, ()=>{
          if ((e.pauseOnHover || e.playOnHover) && e.pauseAnimation) {
              console.error("If you are using pauseAnimation prop for Vue3-Lottie, please remove the props pauseOnHover and playOnHover");
              return
          }
          o && (e.pauseAnimation ? o.pause() : o.play())
      }
      ),
      {
          lottieAnimationContainer: r,
          hoverEnded: _,
          hoverStarted: g,
          getCurrentStyle: d,
          play: ()=>{
              o && o.play()
          }
          ,
          pause: ()=>{
              o && o.pause()
          }
          ,
          stop: ()=>{
              o && o.stop()
          }
          ,
          destroy: ()=>{
              o && o.destroy()
          }
          ,
          setSpeed: (F=1)=>{
              if (F <= 0)
                  throw new Error("Speed must be greater than 0");
              o && o.setSpeed(F)
          }
          ,
          setDirection: F=>{
              o && (F === "forward" ? o.setDirection(1) : F === "reverse" && o.setDirection(-1))
          }
          ,
          goToAndStop: (F,O=!0)=>{
              o && o.goToAndStop(F, O)
          }
          ,
          goToAndPlay: (F,O=!0)=>{
              o && o.goToAndPlay(F, O)
          }
          ,
          playSegments: (F,O=!1)=>{
              o && o.playSegments(F, O)
          }
          ,
          setSubFrame: (F=!0)=>{
              o && o.setSubframe(F)
          }
          ,
          getDuration: (F=!0)=>{
              if (o)
                  return o.getDuration(F)
          }
          ,
          updateDocumentData: (F,O=0)=>{
              o && o.renderer.elements[O].updateDocumentData(F)
          }
      }
  }
});
function _sfc_render(e, t, r, a, o, l) {
  return openBlock(),
  createElementBlock("div", {
      ref: "lottieAnimationContainer",
      class: "lottie-animation-container",
      style: normalizeStyle(e.getCurrentStyle),
      onMouseenter: t[0] || (t[0] = (...f)=>e.hoverStarted && e.hoverStarted(...f)),
      onMouseleave: t[1] || (t[1] = (...f)=>e.hoverEnded && e.hoverEnded(...f))
  }, null, 36)
}
var Vue3Lottie = _export_sfc$1(_sfc_main$5, [["render", _sfc_render]]);
const components_client_NynTgMti2N = defineNuxtPlugin(e=>{
  e.vueApp.component("Vue3Lottie", Vue3Lottie)
}
)
, directives_client_23ySUe5jkO = defineNuxtPlugin(()=>{}
)
, plugins = [revive_payload_client_UiS3SX29k8, unhead_ql6q2sxwsI, plugin, payload_client_b5dW29Gs9J, check_outdated_build_client_9zpfJQa9VH, components_plugin_KR1HBZs4kY, prefetch_client_n7DwbozCHE, plugin_KGfaXjLYE1, plugin_client_VfNkkwGPj6, chunk_reload_client_gju9pz4YE3, components_client_NynTgMti2N, directives_client_23ySUe5jkO]
, RouteProvider = defineComponent({
  props: {
      vnode: {
          type: Object,
          required: !0
      },
      route: {
          type: Object,
          required: !0
      },
      vnodeRef: Object,
      renderKey: String,
      trackRootNodes: Boolean
  },
  setup(e) {
      const t = e.renderKey
        , r = e.route
        , a = {};
      for (const o in e.route)
          Object.defineProperty(a, o, {
              get: ()=>t === e.renderKey ? e.route[o] : r[o]
          });
      return provide(PageRouteSymbol, shallowReactive(a)),
      ()=>h(e.vnode, {
          ref: e.vnodeRef
      })
  }
})
, __nuxt_component_1$1 = defineComponent({
  name: "NuxtPage",
  inheritAttrs: !1,
  props: {
      name: {
          type: String
      },
      transition: {
          type: [Boolean, Object],
          default: void 0
      },
      keepalive: {
          type: [Boolean, Object],
          default: void 0
      },
      route: {
          type: Object
      },
      pageKey: {
          type: [Function, String],
          default: null
      }
  },
  setup(e, {attrs: t, expose: r}) {
      const a = useNuxtApp()
        , o = ref()
        , l = inject(PageRouteSymbol, null);
      let f;
      r({
          pageRef: o
      });
      const d = inject(LayoutMetaSymbol, null);
      let g;
      const _ = a.deferHydration();
      if (a.isHydrating) {
          const v = a.hooks.hookOnce("app:error", _);
          useRouter().beforeEach(v)
      }
      return e.pageKey && watch(()=>e.pageKey, (v,S)=>{
          v !== S && a.callHook("page:loading:start")
      }
      ),
      ()=>h(RouterView, {
          name: e.name,
          route: e.route,
          ...t
      }, {
          default: v=>{
              const S = haveParentRoutesRendered(l, v.route, v.Component)
                , b = l && l.matched.length === v.route.matched.length;
              if (!v.Component) {
                  if (g && !b)
                      return g;
                  _();
                  return
              }
              if (g && d && !d.isCurrent(v.route))
                  return g;
              if (S && l && (!d || d != null && d.isCurrent(l)))
                  return b ? g : null;
              const P = generateRouteKey$1(v, e.pageKey);
              !a.isHydrating && !hasChildrenRoutes(l, v.route, v.Component) && f === P && a.callHook("page:loading:end"),
              f = P;
              const x = !!(e.transition ?? v.route.meta.pageTransition ?? appPageTransition)
                , E = x && _mergeTransitionProps([e.transition, v.route.meta.pageTransition, appPageTransition, {
                  onAfterLeave: ()=>{
                      a.callHook("page:transition:finish", v.Component)
                  }
              }].filter(Boolean))
                , I = e.keepalive ?? v.route.meta.keepalive ?? appKeepalive;
              return g = _wrapIf(Transition, x && E, wrapInKeepAlive(I, h(Suspense, {
                  suspensible: !0,
                  onPending: ()=>a.callHook("page:start", v.Component),
                  onResolve: ()=>{
                      nextTick(()=>a.callHook("page:finish", v.Component).then(()=>a.callHook("page:loading:end")).finally(_))
                  }
              }, {
                  default: ()=>{
                      const C = h(RouteProvider, {
                          key: P || void 0,
                          vnode: v.Component,
                          route: v.route,
                          renderKey: P || void 0,
                          trackRootNodes: x,
                          vnodeRef: o
                      });
                      return I && (C.type.name = v.Component.type.name || v.Component.type.__name || "RouteProvider"),
                      C
                  }
              }))).default(),
              g
          }
      })
  }
});
function _mergeTransitionProps(e) {
  const t = e.map(r=>({
      ...r,
      onAfterLeave: r.onAfterLeave ? toArray$1(r.onAfterLeave) : void 0
  }));
  return defu(...t)
}
function haveParentRoutesRendered(e, t, r) {
  if (!e)
      return !1;
  const a = t.matched.findIndex(o=>{
      var l;
      return ((l = o.components) == null ? void 0 : l.default) === (r == null ? void 0 : r.type)
  }
  );
  return !a || a === -1 ? !1 : t.matched.slice(0, a).some((o,l)=>{
      var f, d, g;
      return ((f = o.components) == null ? void 0 : f.default) !== ((g = (d = e.matched[l]) == null ? void 0 : d.components) == null ? void 0 : g.default)
  }
  ) || r && generateRouteKey$1({
      route: t,
      Component: r
  }) !== generateRouteKey$1({
      route: e,
      Component: r
  })
}
function hasChildrenRoutes(e, t, r) {
  return e ? t.matched.findIndex(o=>{
      var l;
      return ((l = o.components) == null ? void 0 : l.default) === (r == null ? void 0 : r.type)
  }
  ) < t.matched.length - 1 : !1
}
const LayoutLoader = defineComponent({
  name: "LayoutLoader",
  inheritAttrs: !1,
  props: {
      name: String,
      layoutProps: Object
  },
  async setup(e, t) {
      const r = await layouts[e.name]().then(a=>a.default || a);
      return ()=>h(r, e.layoutProps, t.slots)
  }
})
, __nuxt_component_1 = defineComponent({
  name: "NuxtLayout",
  inheritAttrs: !1,
  props: {
      name: {
          type: [String, Boolean, Object],
          default: null
      },
      fallback: {
          type: [String, Object],
          default: null
      }
  },
  setup(e, t) {
      const r = useNuxtApp()
        , a = inject(PageRouteSymbol)
        , o = a === useRoute$1() ? useRoute() : a
        , l = computed(()=>{
          let g = unref(e.name) ?? o.meta.layout ?? "default";
          return g && !(g in layouts) && e.fallback && (g = unref(e.fallback)),
          g
      }
      )
        , f = ref();
      t.expose({
          layoutRef: f
      });
      const d = r.deferHydration();
      if (r.isHydrating) {
          const g = r.hooks.hookOnce("app:error", d);
          useRouter().beforeEach(g)
      }
      return ()=>{
          const g = l.value && l.value in layouts
            , _ = o.meta.layoutTransition ?? appLayoutTransition;
          return _wrapIf(Transition, g && _, {
              default: ()=>h(Suspense, {
                  suspensible: !0,
                  onResolve: ()=>{
                      nextTick(d)
                  }
              }, {
                  default: ()=>h(LayoutProvider, {
                      layoutProps: mergeProps(t.attrs, {
                          ref: f
                      }),
                      key: l.value || void 0,
                      name: l.value,
                      shouldProvide: !e.name,
                      hasTransition: !!_
                  }, t.slots)
              })
          }).default()
      }
  }
})
, LayoutProvider = defineComponent({
  name: "NuxtLayoutProvider",
  inheritAttrs: !1,
  props: {
      name: {
          type: [String, Boolean]
      },
      layoutProps: {
          type: Object
      },
      hasTransition: {
          type: Boolean
      },
      shouldProvide: {
          type: Boolean
      }
  },
  setup(e, t) {
      const r = e.name;
      return e.shouldProvide && provide(LayoutMetaSymbol, {
          isCurrent: a=>r === (a.meta.layout ?? "default")
      }),
      ()=>{
          var a, o;
          return !r || typeof r == "string" && !(r in layouts) ? (o = (a = t.slots).default) == null ? void 0 : o.call(a) : h(LayoutLoader, {
              key: r,
              layoutProps: e.layoutProps,
              name: r
          }, t.slots)
      }
  }
})
, defaults = {
  empty: {},
  auth: {
      user: {},
      accessToken: null,
      isLoggedIn: !1
  },
  authOption: {
      preferCookie: !1
  },
  meta: {
      title: "Check | Unconventional Design Company",
      ogTitle: "Check | Unconventional Design Company",
      description: "We are a global design company creating unique experiences for brands and products through unconventional designs backed by design thinking and innovation.",
      ogDescription: "We are a global design company creating unique experiences for brands and products through unconventional designs backed by design thinking and innovation.",
      ogImage: "https://uploads-ssl.webflow.com/659fc484c5b7328dfbf6e436/65a52002b54dfea4a6d0aa81_checkwebsite-opengraph.jpg",
      twitterCard: "summary_large_image"
  },
  error: {
      statusCode: 418,
      statusMessage: "Something went wrong",
      message: "It's not you, it's us 😌",
      description: "I'm a teapot. Sorry, I can't make coffee. Have some tea instead! or Maybe be go home"
  },
  pagination: {
      limit: 12,
      offset: 0,
      total: 0
  }
}
, useDefault = e=>defaults[e]
, _sfc_main$4 = defineComponent({
  __name: "app",
  setup(e) {
      const t = useDefault("meta");
      useSeoMeta({
          ...t
      });
      const r = useRuntimeConfig().public.appENV.toLowerCase();
      return (r === "staging" || r === "local") && useHeadSafe({
          meta: [{
              name: "robots",
              content: "noindex, nofollow"
          }, {
              name: "googlebot",
              content: "noindex"
          }]
      }),
      (a,o)=>{
          const l = __nuxt_component_1$1
            , f = __nuxt_component_1;
          return openBlock(),
          createBlock(f, null, {
              default: withCtx(()=>[createVNode(l)]),
              _: 1
          })
      }
  }
})
, useFetchState = e=>useState(e, ()=>({
  url: e,
  isWorking: !1,
  error: null
}))
, _imports_0 = "" + new URL("check-logo.BIHwHPBz.svg",import.meta.url).href;
function _defineProperties(e, t) {
  for (var r = 0; r < t.length; r++) {
      var a = t[r];
      a.enumerable = a.enumerable || !1,
      a.configurable = !0,
      "value"in a && (a.writable = !0),
      Object.defineProperty(e, a.key, a)
  }
}
function _createClass(e, t, r) {
  return t && _defineProperties(e.prototype, t),
  r && _defineProperties(e, r),
  e
}
/*!
* Observer 3.11.5
* https://greensock.com
*
* @license Copyright 2008-2023, GreenSock. All rights reserved.
* Subject to the terms at https://greensock.com/standard-license or for
* Club GreenSock members, the agreement issued with that membership.
* @author: Jack Doyle, jack@greensock.com
*/
var gsap$1, _coreInitted$1, _win$1, _doc$1, _docEl$1, _body$1, _isTouch, _pointerType, ScrollTrigger$1, _root$1, _normalizer$1, _eventTypes, _context$1, _getGSAP$1 = function e() {
  return gsap$1 || typeof window < "u" && (gsap$1 = window.gsap) && gsap$1.registerPlugin && gsap$1
}, _startup$1 = 1, _observers = [], _scrollers = [], _proxies = [], _getTime$1 = Date.now, _bridge = function e(t, r) {
  return r
}, _integrate = function e() {
  var t = ScrollTrigger$1.core
    , r = t.bridge || {}
    , a = t._scrollers
    , o = t._proxies;
  a.push.apply(a, _scrollers),
  o.push.apply(o, _proxies),
  _scrollers = a,
  _proxies = o,
  _bridge = function(f, d) {
      return r[f](d)
  }
}, _getProxyProp = function e(t, r) {
  return ~_proxies.indexOf(t) && _proxies[_proxies.indexOf(t) + 1][r]
}, _isViewport$1 = function e(t) {
  return !!~_root$1.indexOf(t)
}, _addListener$1 = function e(t, r, a, o, l) {
  return t.addEventListener(r, a, {
      passive: !o,
      capture: !!l
  })
}, _removeListener$1 = function e(t, r, a, o) {
  return t.removeEventListener(r, a, !!o)
}, _scrollLeft = "scrollLeft", _scrollTop = "scrollTop", _onScroll$1 = function e() {
  return _normalizer$1 && _normalizer$1.isPressed || _scrollers.cache++
}, _scrollCacheFunc = function e(t, r) {
  var a = function o(l) {
      if (l || l === 0) {
          _startup$1 && (_win$1.history.scrollRestoration = "manual");
          var f = _normalizer$1 && _normalizer$1.isPressed;
          l = o.v = Math.round(l) || (_normalizer$1 && _normalizer$1.iOS ? 1 : 0),
          t(l),
          o.cacheID = _scrollers.cache,
          f && _bridge("ss", l)
      } else
          (r || _scrollers.cache !== o.cacheID || _bridge("ref")) && (o.cacheID = _scrollers.cache,
          o.v = t());
      return o.v + o.offset
  };
  return a.offset = 0,
  t && a
}, _horizontal = {
  s: _scrollLeft,
  p: "left",
  p2: "Left",
  os: "right",
  os2: "Right",
  d: "width",
  d2: "Width",
  a: "x",
  sc: _scrollCacheFunc(function(e) {
      return arguments.length ? _win$1.scrollTo(e, _vertical.sc()) : _win$1.pageXOffset || _doc$1[_scrollLeft] || _docEl$1[_scrollLeft] || _body$1[_scrollLeft] || 0
  })
}, _vertical = {
  s: _scrollTop,
  p: "top",
  p2: "Top",
  os: "bottom",
  os2: "Bottom",
  d: "height",
  d2: "Height",
  a: "y",
  op: _horizontal,
  sc: _scrollCacheFunc(function(e) {
      return arguments.length ? _win$1.scrollTo(_horizontal.sc(), e) : _win$1.pageYOffset || _doc$1[_scrollTop] || _docEl$1[_scrollTop] || _body$1[_scrollTop] || 0
  })
}, _getTarget = function e(t) {
  return gsap$1.utils.toArray(t)[0] || (typeof t == "string" && gsap$1.config().nullTargetWarn !== !1 ? console.warn("Element not found:", t) : null)
}, _getScrollFunc = function e(t, r) {
  var a = r.s
    , o = r.sc;
  _isViewport$1(t) && (t = _doc$1.scrollingElement || _docEl$1);
  var l = _scrollers.indexOf(t)
    , f = o === _vertical.sc ? 1 : 2;
  !~l && (l = _scrollers.push(t) - 1),
  _scrollers[l + f] || t.addEventListener("scroll", _onScroll$1);
  var d = _scrollers[l + f]
    , g = d || (_scrollers[l + f] = _scrollCacheFunc(_getProxyProp(t, a), !0) || (_isViewport$1(t) ? o : _scrollCacheFunc(function(_) {
      return arguments.length ? t[a] = _ : t[a]
  })));
  return g.target = t,
  d || (g.smooth = gsap$1.getProperty(t, "scrollBehavior") === "smooth"),
  g
}, _getVelocityProp = function e(t, r, a) {
  var o = t
    , l = t
    , f = _getTime$1()
    , d = f
    , g = r || 50
    , _ = Math.max(500, g * 3)
    , v = function(x, E) {
      var I = _getTime$1();
      E || I - f > g ? (l = o,
      o = x,
      d = f,
      f = I) : a ? o += x : o = l + (x - l) / (I - d) * (f - d)
  }
    , S = function() {
      l = o = a ? 0 : o,
      d = f = 0
  }
    , b = function(x) {
      var E = d
        , I = l
        , C = _getTime$1();
      return (x || x === 0) && x !== o && v(x),
      f === d || C - d > _ ? 0 : (o + (a ? I : -I)) / ((a ? C : f) - E) * 1e3
  };
  return {
      update: v,
      reset: S,
      getVelocity: b
  }
}, _getEvent = function e(t, r) {
  return r && !t._gsapAllow && t.preventDefault(),
  t.changedTouches ? t.changedTouches[0] : t
}, _getAbsoluteMax = function e(t) {
  var r = Math.max.apply(Math, t)
    , a = Math.min.apply(Math, t);
  return Math.abs(r) >= Math.abs(a) ? r : a
}, _setScrollTrigger = function e() {
  ScrollTrigger$1 = gsap$1.core.globals().ScrollTrigger,
  ScrollTrigger$1 && ScrollTrigger$1.core && _integrate()
}, _initCore = function e(t) {
  return gsap$1 = t || _getGSAP$1(),
  gsap$1 && typeof document < "u" && document.body && (_win$1 = window,
  _doc$1 = document,
  _docEl$1 = _doc$1.documentElement,
  _body$1 = _doc$1.body,
  _root$1 = [_win$1, _doc$1, _docEl$1, _body$1],
  gsap$1.utils.clamp,
  _context$1 = gsap$1.core.context || function() {}
  ,
  _pointerType = "onpointerenter"in _body$1 ? "pointer" : "mouse",
  _isTouch = Observer.isTouch = _win$1.matchMedia && _win$1.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart"in _win$1 || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0,
  _eventTypes = Observer.eventTypes = ("ontouchstart"in _docEl$1 ? "touchstart,touchmove,touchcancel,touchend" : "onpointerdown"in _docEl$1 ? "pointerdown,pointermove,pointercancel,pointerup" : "mousedown,mousemove,mouseup,mouseup").split(","),
  setTimeout(function() {
      return _startup$1 = 0
  }, 500),
  _setScrollTrigger(),
  _coreInitted$1 = 1),
  _coreInitted$1
};
_horizontal.op = _vertical;
_scrollers.cache = 0;
var Observer = function() {
  function e(r) {
      this.init(r)
  }
  var t = e.prototype;
  return t.init = function(a) {
      _coreInitted$1 || _initCore(gsap$1) || console.warn("Please gsap.registerPlugin(Observer)"),
      ScrollTrigger$1 || _setScrollTrigger();
      var o = a.tolerance
        , l = a.dragMinimum
        , f = a.type
        , d = a.target
        , g = a.lineHeight
        , _ = a.debounce
        , v = a.preventDefault
        , S = a.onStop
        , b = a.onStopDelay
        , P = a.ignore
        , x = a.wheelSpeed
        , E = a.event
        , I = a.onDragStart
        , C = a.onDragEnd
        , A = a.onDrag
        , T = a.onPress
        , w = a.onRelease
        , M = a.onRight
        , F = a.onLeft
        , O = a.onUp
        , $ = a.onDown
        , j = a.onChangeX
        , K = a.onChangeY
        , Y = a.onChange
        , W = a.onToggleX
        , Z = a.onToggleY
        , ee = a.onHover
        , X = a.onHoverEnd
        , D = a.onMove
        , B = a.ignoreCheck
        , R = a.isNormalizer
        , L = a.onGestureStart
        , V = a.onGestureEnd
        , q = a.onWheel
        , oe = a.onEnable
        , ye = a.onDisable
        , pe = a.onClick
        , Pe = a.scrollSpeed
        , me = a.capture
        , Q = a.allowClicks
        , le = a.lockAxis
        , fe = a.onLockAxis;
      this.target = d = _getTarget(d) || _docEl$1,
      this.vars = a,
      P && (P = gsap$1.utils.toArray(P)),
      o = o || 1e-9,
      l = l || 0,
      x = x || 1,
      Pe = Pe || 1,
      f = f || "wheel,touch,pointer",
      _ = _ !== !1,
      g || (g = parseFloat(_win$1.getComputedStyle(_body$1).lineHeight) || 22);
      var ue, be, ge, H, z, J, te, U = this, ne = 0, ie = 0, se = _getScrollFunc(d, _horizontal), ae = _getScrollFunc(d, _vertical), re = se(), ce = ae(), ve = ~f.indexOf("touch") && !~f.indexOf("pointer") && _eventTypes[0] === "pointerdown", _e = _isViewport$1(d), de = d.ownerDocument || _doc$1, Se = [0, 0, 0], Ee = [0, 0, 0], Re = 0, ke = function() {
          return Re = _getTime$1()
      }, Le = function(xe, he) {
          return (U.event = xe) && P && ~P.indexOf(xe.target) || he && ve && xe.pointerType !== "touch" || B && B(xe, he)
      }, Ke = function() {
          U._vx.reset(),
          U._vy.reset(),
          be.pause(),
          S && S(U)
      }, Ze = function() {
          var xe = U.deltaX = _getAbsoluteMax(Se)
            , he = U.deltaY = _getAbsoluteMax(Ee)
            , Te = Math.abs(xe) >= o
            , we = Math.abs(he) >= o;
          Y && (Te || we) && Y(U, xe, he, Se, Ee),
          Te && (M && U.deltaX > 0 && M(U),
          F && U.deltaX < 0 && F(U),
          j && j(U),
          W && U.deltaX < 0 != ne < 0 && W(U),
          ne = U.deltaX,
          Se[0] = Se[1] = Se[2] = 0),
          we && ($ && U.deltaY > 0 && $(U),
          O && U.deltaY < 0 && O(U),
          K && K(U),
          Z && U.deltaY < 0 != ie < 0 && Z(U),
          ie = U.deltaY,
          Ee[0] = Ee[1] = Ee[2] = 0),
          (H || ge) && (D && D(U),
          ge && (A(U),
          ge = !1),
          H = !1),
          J && !(J = !1) && fe && fe(U),
          z && (q(U),
          z = !1),
          ue = 0
      }, Ye = function(xe, he, Te) {
          Se[Te] += xe,
          Ee[Te] += he,
          U._vx.update(xe),
          U._vy.update(he),
          _ ? ue || (ue = requestAnimationFrame(Ze)) : Ze()
      }, rt = function(xe, he) {
          le && !te && (U.axis = te = Math.abs(xe) > Math.abs(he) ? "x" : "y",
          J = !0),
          te !== "y" && (Se[2] += xe,
          U._vx.update(xe, !0)),
          te !== "x" && (Ee[2] += he,
          U._vy.update(he, !0)),
          _ ? ue || (ue = requestAnimationFrame(Ze)) : Ze()
      }, Ne = function(xe) {
          if (!Le(xe, 1)) {
              xe = _getEvent(xe, v);
              var he = xe.clientX
                , Te = xe.clientY
                , we = he - U.x
                , Me = Te - U.y
                , Be = U.isDragging;
              U.x = he,
              U.y = Te,
              (Be || Math.abs(U.startX - he) >= l || Math.abs(U.startY - Te) >= l) && (A && (ge = !0),
              Be || (U.isDragging = !0),
              rt(we, Me),
              Be || I && I(U))
          }
      }, Ce = U.onPress = function(Ae) {
          Le(Ae, 1) || Ae && Ae.button || (U.axis = te = null,
          be.pause(),
          U.isPressed = !0,
          Ae = _getEvent(Ae),
          ne = ie = 0,
          U.startX = U.x = Ae.clientX,
          U.startY = U.y = Ae.clientY,
          U._vx.reset(),
          U._vy.reset(),
          _addListener$1(R ? d : de, _eventTypes[1], Ne, v, !0),
          U.deltaX = U.deltaY = 0,
          T && T(U))
      }
      , Xe = U.onRelease = function(Ae) {
          if (!Le(Ae, 1)) {
              _removeListener$1(R ? d : de, _eventTypes[1], Ne, !0);
              var xe = !isNaN(U.y - U.startY)
                , he = U.isDragging && (Math.abs(U.x - U.startX) > 3 || Math.abs(U.y - U.startY) > 3)
                , Te = _getEvent(Ae);
              !he && xe && (U._vx.reset(),
              U._vy.reset(),
              v && Q && gsap$1.delayedCall(.08, function() {
                  if (_getTime$1() - Re > 300 && !Ae.defaultPrevented) {
                      if (Ae.target.click)
                          Ae.target.click();
                      else if (de.createEvent) {
                          var we = de.createEvent("MouseEvents");
                          we.initMouseEvent("click", !0, !0, _win$1, 1, Te.screenX, Te.screenY, Te.clientX, Te.clientY, !1, !1, !1, !1, 0, null),
                          Ae.target.dispatchEvent(we)
                      }
                  }
              })),
              U.isDragging = U.isGesturing = U.isPressed = !1,
              S && !R && be.restart(!0),
              C && he && C(U),
              w && w(U, he)
          }
      }
      , Qe = function(xe) {
          return xe.touches && xe.touches.length > 1 && (U.isGesturing = !0) && L(xe, U.isDragging)
      }, et = function() {
          return (U.isGesturing = !1) || V(U)
      }, Je = function(xe) {
          if (!Le(xe)) {
              var he = se()
                , Te = ae();
              Ye((he - re) * Pe, (Te - ce) * Pe, 1),
              re = he,
              ce = Te,
              S && be.restart(!0)
          }
      }, tt = function(xe) {
          if (!Le(xe)) {
              xe = _getEvent(xe, v),
              q && (z = !0);
              var he = (xe.deltaMode === 1 ? g : xe.deltaMode === 2 ? _win$1.innerHeight : 1) * x;
              Ye(xe.deltaX * he, xe.deltaY * he, 0),
              S && !R && be.restart(!0)
          }
      }, at = function(xe) {
          if (!Le(xe)) {
              var he = xe.clientX
                , Te = xe.clientY
                , we = he - U.x
                , Me = Te - U.y;
              U.x = he,
              U.y = Te,
              H = !0,
              (we || Me) && rt(we, Me)
          }
      }, lt = function(xe) {
          U.event = xe,
          ee(U)
      }, st = function(xe) {
          U.event = xe,
          X(U)
      }, ft = function(xe) {
          return Le(xe) || _getEvent(xe, v) && pe(U)
      };
      be = U._dc = gsap$1.delayedCall(b || .25, Ke).pause(),
      U.deltaX = U.deltaY = 0,
      U._vx = _getVelocityProp(0, 50, !0),
      U._vy = _getVelocityProp(0, 50, !0),
      U.scrollX = se,
      U.scrollY = ae,
      U.isDragging = U.isGesturing = U.isPressed = !1,
      _context$1(this),
      U.enable = function(Ae) {
          return U.isEnabled || (_addListener$1(_e ? de : d, "scroll", _onScroll$1),
          f.indexOf("scroll") >= 0 && _addListener$1(_e ? de : d, "scroll", Je, v, me),
          f.indexOf("wheel") >= 0 && _addListener$1(d, "wheel", tt, v, me),
          (f.indexOf("touch") >= 0 && _isTouch || f.indexOf("pointer") >= 0) && (_addListener$1(d, _eventTypes[0], Ce, v, me),
          _addListener$1(de, _eventTypes[2], Xe),
          _addListener$1(de, _eventTypes[3], Xe),
          Q && _addListener$1(d, "click", ke, !1, !0),
          pe && _addListener$1(d, "click", ft),
          L && _addListener$1(de, "gesturestart", Qe),
          V && _addListener$1(de, "gestureend", et),
          ee && _addListener$1(d, _pointerType + "enter", lt),
          X && _addListener$1(d, _pointerType + "leave", st),
          D && _addListener$1(d, _pointerType + "move", at)),
          U.isEnabled = !0,
          Ae && Ae.type && Ce(Ae),
          oe && oe(U)),
          U
      }
      ,
      U.disable = function() {
          U.isEnabled && (_observers.filter(function(Ae) {
              return Ae !== U && _isViewport$1(Ae.target)
          }).length || _removeListener$1(_e ? de : d, "scroll", _onScroll$1),
          U.isPressed && (U._vx.reset(),
          U._vy.reset(),
          _removeListener$1(R ? d : de, _eventTypes[1], Ne, !0)),
          _removeListener$1(_e ? de : d, "scroll", Je, me),
          _removeListener$1(d, "wheel", tt, me),
          _removeListener$1(d, _eventTypes[0], Ce, me),
          _removeListener$1(de, _eventTypes[2], Xe),
          _removeListener$1(de, _eventTypes[3], Xe),
          _removeListener$1(d, "click", ke, !0),
          _removeListener$1(d, "click", ft),
          _removeListener$1(de, "gesturestart", Qe),
          _removeListener$1(de, "gestureend", et),
          _removeListener$1(d, _pointerType + "enter", lt),
          _removeListener$1(d, _pointerType + "leave", st),
          _removeListener$1(d, _pointerType + "move", at),
          U.isEnabled = U.isPressed = U.isDragging = !1,
          ye && ye(U))
      }
      ,
      U.kill = U.revert = function() {
          U.disable();
          var Ae = _observers.indexOf(U);
          Ae >= 0 && _observers.splice(Ae, 1),
          _normalizer$1 === U && (_normalizer$1 = 0)
      }
      ,
      _observers.push(U),
      R && _isViewport$1(d) && (_normalizer$1 = U),
      U.enable(E)
  }
  ,
  _createClass(e, [{
      key: "velocityX",
      get: function() {
          return this._vx.getVelocity()
      }
  }, {
      key: "velocityY",
      get: function() {
          return this._vy.getVelocity()
      }
  }]),
  e
}();
Observer.version = "3.11.5";
Observer.create = function(e) {
  return new Observer(e)
}
;
Observer.register = _initCore;
Observer.getAll = function() {
  return _observers.slice()
}
;
Observer.getById = function(e) {
  return _observers.filter(function(t) {
      return t.vars.id === e
  })[0]
}
;
_getGSAP$1() && gsap$1.registerPlugin(Observer);
/*!
* ScrollTrigger 3.11.5
* https://greensock.com
*
* @license Copyright 2008-2023, GreenSock. All rights reserved.
* Subject to the terms at https://greensock.com/standard-license or for
* Club GreenSock members, the agreement issued with that membership.
* @author: Jack Doyle, jack@greensock.com
*/
var gsap, _coreInitted, _win, _doc, _docEl, _body, _root, _resizeDelay, _toArray, _clamp, _time2, _syncInterval, _refreshing, _pointerIsDown, _transformProp, _i, _prevWidth, _prevHeight, _autoRefresh, _sort, _suppressOverwrites, _ignoreResize, _normalizer, _ignoreMobileResize, _baseScreenHeight, _baseScreenWidth, _fixIOSBug, _context, _scrollRestoration, _limitCallbacks, _startup = 1, _getTime = Date.now, _time1 = _getTime(), _lastScrollTime = 0, _enabled = 0, _rafBugFix = function e() {
  return _enabled && requestAnimationFrame(e)
}, _pointerDownHandler = function e() {
  return _pointerIsDown = 1
}, _pointerUpHandler = function e() {
  return _pointerIsDown = 0
}, _passThrough = function e(t) {
  return t
}, _round = function e(t) {
  return Math.round(t * 1e5) / 1e5 || 0
}, _windowExists = function e() {
  return typeof window < "u"
}, _getGSAP = function e() {
  return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap
}, _isViewport = function e(t) {
  return !!~_root.indexOf(t)
}, _getBoundsFunc = function e(t) {
  return _getProxyProp(t, "getBoundingClientRect") || (_isViewport(t) ? function() {
      return _winOffsets.width = _win.innerWidth,
      _winOffsets.height = _win.innerHeight,
      _winOffsets
  }
  : function() {
      return _getBounds(t)
  }
  )
}, _getSizeFunc = function e(t, r, a) {
  var o = a.d
    , l = a.d2
    , f = a.a;
  return (f = _getProxyProp(t, "getBoundingClientRect")) ? function() {
      return f()[o]
  }
  : function() {
      return (r ? _win["inner" + l] : t["client" + l]) || 0
  }
}, _getOffsetsFunc = function e(t, r) {
  return !r || ~_proxies.indexOf(t) ? _getBoundsFunc(t) : function() {
      return _winOffsets
  }
}, _maxScroll = function e(t, r) {
  var a = r.s
    , o = r.d2
    , l = r.d
    , f = r.a;
  return Math.max(0, (a = "scroll" + o) && (f = _getProxyProp(t, a)) ? f() - _getBoundsFunc(t)()[l] : _isViewport(t) ? (_docEl[a] || _body[a]) - (_win["inner" + o] || _docEl["client" + o] || _body["client" + o]) : t[a] - t["offset" + o])
}, _iterateAutoRefresh = function e(t, r) {
  for (var a = 0; a < _autoRefresh.length; a += 3)
      (!r || ~r.indexOf(_autoRefresh[a + 1])) && t(_autoRefresh[a], _autoRefresh[a + 1], _autoRefresh[a + 2])
}, _isString = function e(t) {
  return typeof t == "string"
}, _isFunction = function e(t) {
  return typeof t == "function"
}, _isNumber = function e(t) {
  return typeof t == "number"
}, _isObject = function e(t) {
  return typeof t == "object"
}, _endAnimation = function e(t, r, a) {
  return t && t.progress(r ? 0 : 1) && a && t.pause()
}, _callback = function e(t, r) {
  if (t.enabled) {
      var a = r(t);
      a && a.totalTime && (t.callbackAnimation = a)
  }
}, _abs = Math.abs, _left = "left", _top = "top", _right = "right", _bottom = "bottom", _width = "width", _height = "height", _Right = "Right", _Left = "Left", _Top = "Top", _Bottom = "Bottom", _padding = "padding", _margin = "margin", _Width = "Width", _Height = "Height", _px = "px", _getComputedStyle = function e(t) {
  return _win.getComputedStyle(t)
}, _makePositionable = function e(t) {
  var r = _getComputedStyle(t).position;
  t.style.position = r === "absolute" || r === "fixed" ? r : "relative"
}, _setDefaults = function e(t, r) {
  for (var a in r)
      a in t || (t[a] = r[a]);
  return t
}, _getBounds = function e(t, r) {
  var a = r && _getComputedStyle(t)[_transformProp] !== "matrix(1, 0, 0, 1, 0, 0)" && gsap.to(t, {
      x: 0,
      y: 0,
      xPercent: 0,
      yPercent: 0,
      rotation: 0,
      rotationX: 0,
      rotationY: 0,
      scale: 1,
      skewX: 0,
      skewY: 0
  }).progress(1)
    , o = t.getBoundingClientRect();
  return a && a.progress(0).kill(),
  o
}, _getSize = function e(t, r) {
  var a = r.d2;
  return t["offset" + a] || t["client" + a] || 0
}, _getLabelRatioArray = function e(t) {
  var r = [], a = t.labels, o = t.duration(), l;
  for (l in a)
      r.push(a[l] / o);
  return r
}, _getClosestLabel = function e(t) {
  return function(r) {
      return gsap.utils.snap(_getLabelRatioArray(t), r)
  }
}, _snapDirectional = function e(t) {
  var r = gsap.utils.snap(t)
    , a = Array.isArray(t) && t.slice(0).sort(function(o, l) {
      return o - l
  });
  return a ? function(o, l, f) {
      f === void 0 && (f = .001);
      var d;
      if (!l)
          return r(o);
      if (l > 0) {
          for (o -= f,
          d = 0; d < a.length; d++)
              if (a[d] >= o)
                  return a[d];
          return a[d - 1]
      } else
          for (d = a.length,
          o += f; d--; )
              if (a[d] <= o)
                  return a[d];
      return a[0]
  }
  : function(o, l, f) {
      f === void 0 && (f = .001);
      var d = r(o);
      return !l || Math.abs(d - o) < f || d - o < 0 == l < 0 ? d : r(l < 0 ? o - t : o + t)
  }
}, _getLabelAtDirection = function e(t) {
  return function(r, a) {
      return _snapDirectional(_getLabelRatioArray(t))(r, a.direction)
  }
}, _multiListener = function e(t, r, a, o) {
  return a.split(",").forEach(function(l) {
      return t(r, l, o)
  })
}, _addListener = function e(t, r, a, o, l) {
  return t.addEventListener(r, a, {
      passive: !o,
      capture: !!l
  })
}, _removeListener = function e(t, r, a, o) {
  return t.removeEventListener(r, a, !!o)
}, _wheelListener = function e(t, r, a) {
  a = a && a.wheelHandler,
  a && (t(r, "wheel", a),
  t(r, "touchmove", a))
}, _markerDefaults = {
  startColor: "green",
  endColor: "red",
  indent: 0,
  fontSize: "16px",
  fontWeight: "normal"
}, _defaults = {
  toggleActions: "play",
  anticipatePin: 0
}, _keywords = {
  top: 0,
  left: 0,
  center: .5,
  bottom: 1,
  right: 1
}, _offsetToPx = function e(t, r) {
  if (_isString(t)) {
      var a = t.indexOf("=")
        , o = ~a ? +(t.charAt(a - 1) + 1) * parseFloat(t.substr(a + 1)) : 0;
      ~a && (t.indexOf("%") > a && (o *= r / 100),
      t = t.substr(0, a - 1)),
      t = o + (t in _keywords ? _keywords[t] * r : ~t.indexOf("%") ? parseFloat(t) * r / 100 : parseFloat(t) || 0)
  }
  return t
}, _createMarker = function e(t, r, a, o, l, f, d, g) {
  var _ = l.startColor
    , v = l.endColor
    , S = l.fontSize
    , b = l.indent
    , P = l.fontWeight
    , x = _doc.createElement("div")
    , E = _isViewport(a) || _getProxyProp(a, "pinType") === "fixed"
    , I = t.indexOf("scroller") !== -1
    , C = E ? _body : a
    , A = t.indexOf("start") !== -1
    , T = A ? _ : v
    , w = "border-color:" + T + ";font-size:" + S + ";color:" + T + ";font-weight:" + P + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
  return w += "position:" + ((I || g) && E ? "fixed;" : "absolute;"),
  (I || g || !E) && (w += (o === _vertical ? _right : _bottom) + ":" + (f + parseFloat(b)) + "px;"),
  d && (w += "box-sizing:border-box;text-align:left;width:" + d.offsetWidth + "px;"),
  x._isStart = A,
  x.setAttribute("class", "gsap-marker-" + t + (r ? " marker-" + r : "")),
  x.style.cssText = w,
  x.innerText = r || r === 0 ? t + "-" + r : t,
  C.children[0] ? C.insertBefore(x, C.children[0]) : C.appendChild(x),
  x._offset = x["offset" + o.op.d2],
  _positionMarker(x, 0, o, A),
  x
}, _positionMarker = function e(t, r, a, o) {
  var l = {
      display: "block"
  }
    , f = a[o ? "os2" : "p2"]
    , d = a[o ? "p2" : "os2"];
  t._isFlipped = o,
  l[a.a + "Percent"] = o ? -100 : 0,
  l[a.a] = o ? "1px" : 0,
  l["border" + f + _Width] = 1,
  l["border" + d + _Width] = 0,
  l[a.p] = r + "px",
  gsap.set(t, l)
}, _triggers = [], _ids = {}, _rafID, _sync = function e() {
  return _getTime() - _lastScrollTime > 34 && (_rafID || (_rafID = requestAnimationFrame(_updateAll)))
}, _onScroll = function e() {
  (!_normalizer || !_normalizer.isPressed || _normalizer.startX > _body.clientWidth) && (_scrollers.cache++,
  _normalizer ? _rafID || (_rafID = requestAnimationFrame(_updateAll)) : _updateAll(),
  _lastScrollTime || _dispatch("scrollStart"),
  _lastScrollTime = _getTime())
}, _setBaseDimensions = function e() {
  _baseScreenWidth = _win.innerWidth,
  _baseScreenHeight = _win.innerHeight
}, _onResize = function e() {
  _scrollers.cache++,
  !_refreshing && !_ignoreResize && !_doc.fullscreenElement && !_doc.webkitFullscreenElement && (!_ignoreMobileResize || _baseScreenWidth !== _win.innerWidth || Math.abs(_win.innerHeight - _baseScreenHeight) > _win.innerHeight * .25) && _resizeDelay.restart(!0)
}, _listeners = {}, _emptyArray = [], _softRefresh = function e() {
  return _removeListener(ScrollTrigger, "scrollEnd", e) || _refreshAll(!0)
}, _dispatch = function e(t) {
  return _listeners[t] && _listeners[t].map(function(r) {
      return r()
  }) || _emptyArray
}, _savedStyles = [], _revertRecorded = function e(t) {
  for (var r = 0; r < _savedStyles.length; r += 5)
      (!t || _savedStyles[r + 4] && _savedStyles[r + 4].query === t) && (_savedStyles[r].style.cssText = _savedStyles[r + 1],
      _savedStyles[r].getBBox && _savedStyles[r].setAttribute("transform", _savedStyles[r + 2] || ""),
      _savedStyles[r + 3].uncache = 1)
}, _revertAll = function e(t, r) {
  var a;
  for (_i = 0; _i < _triggers.length; _i++)
      a = _triggers[_i],
      a && (!r || a._ctx === r) && (t ? a.kill(1) : a.revert(!0, !0));
  r && _revertRecorded(r),
  r || _dispatch("revert")
}, _clearScrollMemory = function e(t, r) {
  _scrollers.cache++,
  (r || !_refreshingAll) && _scrollers.forEach(function(a) {
      return _isFunction(a) && a.cacheID++ && (a.rec = 0)
  }),
  _isString(t) && (_win.history.scrollRestoration = _scrollRestoration = t)
}, _refreshingAll, _refreshID = 0, _queueRefreshID, _queueRefreshAll = function e() {
  if (_queueRefreshID !== _refreshID) {
      var t = _queueRefreshID = _refreshID;
      requestAnimationFrame(function() {
          return t === _refreshID && _refreshAll(!0)
      })
  }
}, _refreshAll = function e(t, r) {
  if (_lastScrollTime && !t) {
      _addListener(ScrollTrigger, "scrollEnd", _softRefresh);
      return
  }
  _refreshingAll = ScrollTrigger.isRefreshing = !0,
  _scrollers.forEach(function(o) {
      return _isFunction(o) && o.cacheID++ && (o.rec = o())
  });
  var a = _dispatch("refreshInit");
  _sort && ScrollTrigger.sort(),
  r || _revertAll(),
  _scrollers.forEach(function(o) {
      _isFunction(o) && (o.smooth && (o.target.style.scrollBehavior = "auto"),
      o(0))
  }),
  _triggers.slice(0).forEach(function(o) {
      return o.refresh()
  }),
  _triggers.forEach(function(o, l) {
      if (o._subPinOffset && o.pin) {
          var f = o.vars.horizontal ? "offsetWidth" : "offsetHeight"
            , d = o.pin[f];
          o.revert(!0, 1),
          o.adjustPinSpacing(o.pin[f] - d),
          o.refresh()
      }
  }),
  _triggers.forEach(function(o) {
      return o.vars.end === "max" && o.setPositions(o.start, Math.max(o.start + 1, _maxScroll(o.scroller, o._dir)))
  }),
  a.forEach(function(o) {
      return o && o.render && o.render(-1)
  }),
  _scrollers.forEach(function(o) {
      _isFunction(o) && (o.smooth && requestAnimationFrame(function() {
          return o.target.style.scrollBehavior = "smooth"
      }),
      o.rec && o(o.rec))
  }),
  _clearScrollMemory(_scrollRestoration, 1),
  _resizeDelay.pause(),
  _refreshID++,
  _refreshingAll = 2,
  _updateAll(2),
  _triggers.forEach(function(o) {
      return _isFunction(o.vars.onRefresh) && o.vars.onRefresh(o)
  }),
  _refreshingAll = ScrollTrigger.isRefreshing = !1,
  _dispatch("refresh")
}, _lastScroll = 0, _direction = 1, _primary, _updateAll = function e(t) {
  if (!_refreshingAll || t === 2) {
      ScrollTrigger.isUpdating = !0,
      _primary && _primary.update(0);
      var r = _triggers.length
        , a = _getTime()
        , o = a - _time1 >= 50
        , l = r && _triggers[0].scroll();
      if (_direction = _lastScroll > l ? -1 : 1,
      _refreshingAll || (_lastScroll = l),
      o && (_lastScrollTime && !_pointerIsDown && a - _lastScrollTime > 200 && (_lastScrollTime = 0,
      _dispatch("scrollEnd")),
      _time2 = _time1,
      _time1 = a),
      _direction < 0) {
          for (_i = r; _i-- > 0; )
              _triggers[_i] && _triggers[_i].update(0, o);
          _direction = 1
      } else
          for (_i = 0; _i < r; _i++)
              _triggers[_i] && _triggers[_i].update(0, o);
      ScrollTrigger.isUpdating = !1
  }
  _rafID = 0
}, _propNamesToCopy = [_left, _top, _bottom, _right, _margin + _Bottom, _margin + _Right, _margin + _Top, _margin + _Left, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"], _stateProps = _propNamesToCopy.concat([_width, _height, "boxSizing", "max" + _Width, "max" + _Height, "position", _margin, _padding, _padding + _Top, _padding + _Right, _padding + _Bottom, _padding + _Left]), _swapPinOut = function e(t, r, a) {
  _setState(a);
  var o = t._gsap;
  if (o.spacerIsNative)
      _setState(o.spacerState);
  else if (t._gsap.swappedIn) {
      var l = r.parentNode;
      l && (l.insertBefore(t, r),
      l.removeChild(r))
  }
  t._gsap.swappedIn = !1
}, _swapPinIn = function e(t, r, a, o) {
  if (!t._gsap.swappedIn) {
      for (var l = _propNamesToCopy.length, f = r.style, d = t.style, g; l--; )
          g = _propNamesToCopy[l],
          f[g] = a[g];
      f.position = a.position === "absolute" ? "absolute" : "relative",
      a.display === "inline" && (f.display = "inline-block"),
      d[_bottom] = d[_right] = "auto",
      f.flexBasis = a.flexBasis || "auto",
      f.overflow = "visible",
      f.boxSizing = "border-box",
      f[_width] = _getSize(t, _horizontal) + _px,
      f[_height] = _getSize(t, _vertical) + _px,
      f[_padding] = d[_margin] = d[_top] = d[_left] = "0",
      _setState(o),
      d[_width] = d["max" + _Width] = a[_width],
      d[_height] = d["max" + _Height] = a[_height],
      d[_padding] = a[_padding],
      t.parentNode !== r && (t.parentNode.insertBefore(r, t),
      r.appendChild(t)),
      t._gsap.swappedIn = !0
  }
}, _capsExp = /([A-Z])/g, _setState = function e(t) {
  if (t) {
      var r = t.t.style, a = t.length, o = 0, l, f;
      for ((t.t._gsap || gsap.core.getCache(t.t)).uncache = 1; o < a; o += 2)
          f = t[o + 1],
          l = t[o],
          f ? r[l] = f : r[l] && r.removeProperty(l.replace(_capsExp, "-$1").toLowerCase())
  }
}, _getState = function e(t) {
  for (var r = _stateProps.length, a = t.style, o = [], l = 0; l < r; l++)
      o.push(_stateProps[l], a[_stateProps[l]]);
  return o.t = t,
  o
}, _copyState = function e(t, r, a) {
  for (var o = [], l = t.length, f = a ? 8 : 0, d; f < l; f += 2)
      d = t[f],
      o.push(d, d in r ? r[d] : t[f + 1]);
  return o.t = t.t,
  o
}, _winOffsets = {
  left: 0,
  top: 0
}, _parsePosition = function e(t, r, a, o, l, f, d, g, _, v, S, b, P) {
  _isFunction(t) && (t = t(g)),
  _isString(t) && t.substr(0, 3) === "max" && (t = b + (t.charAt(4) === "=" ? _offsetToPx("0" + t.substr(3), a) : 0));
  var x = P ? P.time() : 0, E, I, C;
  if (P && P.seek(0),
  _isNumber(t))
      P && (t = gsap.utils.mapRange(P.scrollTrigger.start, P.scrollTrigger.end, 0, b, t)),
      d && _positionMarker(d, a, o, !0);
  else {
      _isFunction(r) && (r = r(g));
      var A = (t || "0").split(" "), T, w, M, F;
      C = _getTarget(r) || _body,
      T = _getBounds(C) || {},
      (!T || !T.left && !T.top) && _getComputedStyle(C).display === "none" && (F = C.style.display,
      C.style.display = "block",
      T = _getBounds(C),
      F ? C.style.display = F : C.style.removeProperty("display")),
      w = _offsetToPx(A[0], T[o.d]),
      M = _offsetToPx(A[1] || "0", a),
      t = T[o.p] - _[o.p] - v + w + l - M,
      d && _positionMarker(d, M, o, a - M < 20 || d._isStart && M > 20),
      a -= a - M
  }
  if (f) {
      var O = t + a
        , $ = f._isStart;
      E = "scroll" + o.d2,
      _positionMarker(f, O, o, $ && O > 20 || !$ && (S ? Math.max(_body[E], _docEl[E]) : f.parentNode[E]) <= O + 1),
      S && (_ = _getBounds(d),
      S && (f.style[o.op.p] = _[o.op.p] - o.op.m - f._offset + _px))
  }
  return P && C && (E = _getBounds(C),
  P.seek(b),
  I = _getBounds(C),
  P._caScrollDist = E[o.p] - I[o.p],
  t = t / P._caScrollDist * b),
  P && P.seek(x),
  P ? t : Math.round(t)
}, _prefixExp = /(webkit|moz|length|cssText|inset)/i, _reparent = function e(t, r, a, o) {
  if (t.parentNode !== r) {
      var l = t.style, f, d;
      if (r === _body) {
          t._stOrig = l.cssText,
          d = _getComputedStyle(t);
          for (f in d)
              !+f && !_prefixExp.test(f) && d[f] && typeof l[f] == "string" && f !== "0" && (l[f] = d[f]);
          l.top = a,
          l.left = o
      } else
          l.cssText = t._stOrig;
      gsap.core.getCache(t).uncache = 1,
      r.appendChild(t)
  }
}, _interruptionTracker = function e(t, r, a) {
  var o = r
    , l = o;
  return function(f) {
      var d = Math.round(t());
      return d !== o && d !== l && Math.abs(d - o) > 3 && Math.abs(d - l) > 3 && (f = d,
      a && a()),
      l = o,
      o = f,
      f
  }
}, _getTweenCreator = function e(t, r) {
  var a = _getScrollFunc(t, r)
    , o = "_scroll" + r.p2
    , l = function f(d, g, _, v, S) {
      var b = f.tween
        , P = g.onComplete
        , x = {};
      _ = _ || a();
      var E = _interruptionTracker(a, _, function() {
          b.kill(),
          f.tween = 0
      });
      return S = v && S || 0,
      v = v || d - _,
      b && b.kill(),
      g[o] = d,
      g.modifiers = x,
      x[o] = function() {
          return E(_ + v * b.ratio + S * b.ratio * b.ratio)
      }
      ,
      g.onUpdate = function() {
          _scrollers.cache++,
          _updateAll()
      }
      ,
      g.onComplete = function() {
          f.tween = 0,
          P && P.call(b)
      }
      ,
      b = f.tween = gsap.to(t, g),
      b
  };
  return t[o] = a,
  a.wheelHandler = function() {
      return l.tween && l.tween.kill() && (l.tween = 0)
  }
  ,
  _addListener(t, "wheel", a.wheelHandler),
  ScrollTrigger.isTouch && _addListener(t, "touchmove", a.wheelHandler),
  l
}, ScrollTrigger = function() {
  function e(r, a) {
      _coreInitted || e.register(gsap) || console.warn("Please gsap.registerPlugin(ScrollTrigger)"),
      this.init(r, a)
  }
  var t = e.prototype;
  return t.init = function(a, o) {
      if (this.progress = this.start = 0,
      this.vars && this.kill(!0, !0),
      !_enabled) {
          this.update = this.refresh = this.kill = _passThrough;
          return
      }
      a = _setDefaults(_isString(a) || _isNumber(a) || a.nodeType ? {
          trigger: a
      } : a, _defaults);
      var l = a, f = l.onUpdate, d = l.toggleClass, g = l.id, _ = l.onToggle, v = l.onRefresh, S = l.scrub, b = l.trigger, P = l.pin, x = l.pinSpacing, E = l.invalidateOnRefresh, I = l.anticipatePin, C = l.onScrubComplete, A = l.onSnapComplete, T = l.once, w = l.snap, M = l.pinReparent, F = l.pinSpacer, O = l.containerAnimation, $ = l.fastScrollEnd, j = l.preventOverlaps, K = a.horizontal || a.containerAnimation && a.horizontal !== !1 ? _horizontal : _vertical, Y = !S && S !== 0, W = _getTarget(a.scroller || _win), Z = gsap.core.getCache(W), ee = _isViewport(W), X = ("pinType"in a ? a.pinType : _getProxyProp(W, "pinType") || ee && "fixed") === "fixed", D = [a.onEnter, a.onLeave, a.onEnterBack, a.onLeaveBack], B = Y && a.toggleActions.split(" "), R = "markers"in a ? a.markers : _defaults.markers, L = ee ? 0 : parseFloat(_getComputedStyle(W)["border" + K.p2 + _Width]) || 0, V = this, q = a.onRefreshInit && function() {
          return a.onRefreshInit(V)
      }
      , oe = _getSizeFunc(W, ee, K), ye = _getOffsetsFunc(W, ee), pe = 0, Pe = 0, me = _getScrollFunc(W, K), Q, le, fe, ue, be, ge, H, z, J, te, U, ne, ie, se, ae, re, ce, ve, _e, de, Se, Ee, Re, ke, Le, Ke, Ze, Ye, rt, Ne, Ce, Xe, Qe, et, Je, tt, at, lt, st;
      if (_context(V),
      V._dir = K,
      I *= 45,
      V.scroller = W,
      V.scroll = O ? O.time.bind(O) : me,
      ue = me(),
      V.vars = a,
      o = o || a.animation,
      "refreshPriority"in a && (_sort = 1,
      a.refreshPriority === -9999 && (_primary = V)),
      Z.tweenScroll = Z.tweenScroll || {
          top: _getTweenCreator(W, _vertical),
          left: _getTweenCreator(W, _horizontal)
      },
      V.tweenTo = Q = Z.tweenScroll[K.p],
      V.scrubDuration = function(he) {
          Xe = _isNumber(he) && he,
          Xe ? Ce ? Ce.duration(he) : Ce = gsap.to(o, {
              ease: "expo",
              totalProgress: "+=0.001",
              duration: Xe,
              paused: !0,
              onComplete: function() {
                  return C && C(V)
              }
          }) : (Ce && Ce.progress(1).kill(),
          Ce = 0)
      }
      ,
      o && (o.vars.lazy = !1,
      o._initted || o.vars.immediateRender !== !1 && a.immediateRender !== !1 && o.duration() && o.render(0, !0, !0),
      V.animation = o.pause(),
      o.scrollTrigger = V,
      V.scrubDuration(S),
      Ce && Ce.resetTo && Ce.resetTo("totalProgress", 0),
      rt = 0,
      g || (g = o.vars.id)),
      _triggers.push(V),
      w && ((!_isObject(w) || w.push) && (w = {
          snapTo: w
      }),
      "scrollBehavior"in _body.style && gsap.set(ee ? [_body, _docEl] : W, {
          scrollBehavior: "auto"
      }),
      _scrollers.forEach(function(he) {
          return _isFunction(he) && he.target === (ee ? _doc.scrollingElement || _docEl : W) && (he.smooth = !1)
      }),
      fe = _isFunction(w.snapTo) ? w.snapTo : w.snapTo === "labels" ? _getClosestLabel(o) : w.snapTo === "labelsDirectional" ? _getLabelAtDirection(o) : w.directional !== !1 ? function(he, Te) {
          return _snapDirectional(w.snapTo)(he, _getTime() - Pe < 500 ? 0 : Te.direction)
      }
      : gsap.utils.snap(w.snapTo),
      Qe = w.duration || {
          min: .1,
          max: 2
      },
      Qe = _isObject(Qe) ? _clamp(Qe.min, Qe.max) : _clamp(Qe, Qe),
      et = gsap.delayedCall(w.delay || Xe / 2 || .1, function() {
          var he = me()
            , Te = _getTime() - Pe < 500
            , we = Q.tween;
          if ((Te || Math.abs(V.getVelocity()) < 10) && !we && !_pointerIsDown && pe !== he) {
              var Me = (he - ge) / ie
                , Be = o && !Y ? o.totalProgress() : Me
                , Ie = Te ? 0 : (Be - Ne) / (_getTime() - _time2) * 1e3 || 0
                , Fe = gsap.utils.clamp(-Me, 1 - Me, _abs(Ie / 2) * Ie / .185)
                , je = Me + (w.inertia === !1 ? 0 : Fe)
                , He = _clamp(0, 1, fe(je, V))
                , $e = Math.round(ge + He * ie)
                , Oe = w
                , qe = Oe.onStart
                , Ue = Oe.onInterrupt
                , ze = Oe.onComplete;
              if (he <= H && he >= ge && $e !== he) {
                  if (we && !we._initted && we.data <= _abs($e - he))
                      return;
                  w.inertia === !1 && (Fe = He - Me),
                  Q($e, {
                      duration: Qe(_abs(Math.max(_abs(je - Be), _abs(He - Be)) * .185 / Ie / .05 || 0)),
                      ease: w.ease || "power3",
                      data: _abs($e - he),
                      onInterrupt: function() {
                          return et.restart(!0) && Ue && Ue(V)
                      },
                      onComplete: function() {
                          V.update(),
                          pe = me(),
                          rt = Ne = o && !Y ? o.totalProgress() : V.progress,
                          A && A(V),
                          ze && ze(V)
                      }
                  }, he, Fe * ie, $e - he - Fe * ie),
                  qe && qe(V, Q.tween)
              }
          } else
              V.isActive && pe !== he && et.restart(!0)
      }).pause()),
      g && (_ids[g] = V),
      b = V.trigger = _getTarget(b || P),
      st = b && b._gsap && b._gsap.stRevert,
      st && (st = st(V)),
      P = P === !0 ? b : _getTarget(P),
      _isString(d) && (d = {
          targets: b,
          className: d
      }),
      P && (x === !1 || x === _margin || (x = !x && P.parentNode && P.parentNode.style && _getComputedStyle(P.parentNode).display === "flex" ? !1 : _padding),
      V.pin = P,
      le = gsap.core.getCache(P),
      le.spacer ? se = le.pinState : (F && (F = _getTarget(F),
      F && !F.nodeType && (F = F.current || F.nativeElement),
      le.spacerIsNative = !!F,
      F && (le.spacerState = _getState(F))),
      le.spacer = ce = F || _doc.createElement("div"),
      ce.classList.add("pin-spacer"),
      g && ce.classList.add("pin-spacer-" + g),
      le.pinState = se = _getState(P)),
      a.force3D !== !1 && gsap.set(P, {
          force3D: !0
      }),
      V.spacer = ce = le.spacer,
      Ye = _getComputedStyle(P),
      Re = Ye[x + K.os2],
      _e = gsap.getProperty(P),
      de = gsap.quickSetter(P, K.a, _px),
      _swapPinIn(P, ce, Ye),
      re = _getState(P)),
      R) {
          ne = _isObject(R) ? _setDefaults(R, _markerDefaults) : _markerDefaults,
          te = _createMarker("scroller-start", g, W, K, ne, 0),
          U = _createMarker("scroller-end", g, W, K, ne, 0, te),
          ve = te["offset" + K.op.d2];
          var ft = _getTarget(_getProxyProp(W, "content") || W);
          z = this.markerStart = _createMarker("start", g, ft, K, ne, ve, 0, O),
          J = this.markerEnd = _createMarker("end", g, ft, K, ne, ve, 0, O),
          O && (lt = gsap.quickSetter([z, J], K.a, _px)),
          !X && !(_proxies.length && _getProxyProp(W, "fixedMarkers") === !0) && (_makePositionable(ee ? _body : W),
          gsap.set([te, U], {
              force3D: !0
          }),
          Le = gsap.quickSetter(te, K.a, _px),
          Ze = gsap.quickSetter(U, K.a, _px))
      }
      if (O) {
          var Ae = O.vars.onUpdate
            , xe = O.vars.onUpdateParams;
          O.eventCallback("onUpdate", function() {
              V.update(0, 0, 1),
              Ae && Ae.apply(O, xe || [])
          })
      }
      V.previous = function() {
          return _triggers[_triggers.indexOf(V) - 1]
      }
      ,
      V.next = function() {
          return _triggers[_triggers.indexOf(V) + 1]
      }
      ,
      V.revert = function(he, Te) {
          if (!Te)
              return V.kill(!0);
          var we = he !== !1 || !V.enabled
            , Me = _refreshing;
          we !== V.isReverted && (we && (tt = Math.max(me(), V.scroll.rec || 0),
          Je = V.progress,
          at = o && o.progress()),
          z && [z, J, te, U].forEach(function(Be) {
              return Be.style.display = we ? "none" : "block"
          }),
          we && (_refreshing = V,
          V.update(we)),
          P && (!M || !V.isActive) && (we ? _swapPinOut(P, ce, se) : _swapPinIn(P, ce, _getComputedStyle(P), ke)),
          we || V.update(we),
          _refreshing = Me,
          V.isReverted = we)
      }
      ,
      V.refresh = function(he, Te) {
          if (!((_refreshing || !V.enabled) && !Te)) {
              if (P && he && _lastScrollTime) {
                  _addListener(e, "scrollEnd", _softRefresh);
                  return
              }
              !_refreshingAll && q && q(V),
              _refreshing = V,
              Pe = _getTime(),
              Q.tween && (Q.tween.kill(),
              Q.tween = 0),
              Ce && Ce.pause(),
              E && o && o.revert({
                  kill: !1
              }).invalidate(),
              V.isReverted || V.revert(!0, !0),
              V._subPinOffset = !1;
              for (var we = oe(), Me = ye(), Be = O ? O.duration() : _maxScroll(W, K), Ie = ie <= .01, Fe = 0, je = 0, He = a.end, $e = a.endTrigger || b, Oe = a.start || (a.start === 0 || !b ? 0 : P ? "0 0" : "0 100%"), qe = V.pinnedContainer = a.pinnedContainer && _getTarget(a.pinnedContainer), Ue = b && Math.max(0, _triggers.indexOf(V)) || 0, ze = Ue, De, We, ct, ot, Ve, Ge, it, dt, mt, ut, nt; ze--; )
                  Ge = _triggers[ze],
                  Ge.end || Ge.refresh(0, 1) || (_refreshing = V),
                  it = Ge.pin,
                  it && (it === b || it === P || it === qe) && !Ge.isReverted && (ut || (ut = []),
                  ut.unshift(Ge),
                  Ge.revert(!0, !0)),
                  Ge !== _triggers[ze] && (Ue--,
                  ze--);
              for (_isFunction(Oe) && (Oe = Oe(V)),
              ge = _parsePosition(Oe, b, we, K, me(), z, te, V, Me, L, X, Be, O) || (P ? -.001 : 0),
              _isFunction(He) && (He = He(V)),
              _isString(He) && !He.indexOf("+=") && (~He.indexOf(" ") ? He = (_isString(Oe) ? Oe.split(" ")[0] : "") + He : (Fe = _offsetToPx(He.substr(2), we),
              He = _isString(Oe) ? Oe : (O ? gsap.utils.mapRange(0, O.duration(), O.scrollTrigger.start, O.scrollTrigger.end, ge) : ge) + Fe,
              $e = b)),
              H = Math.max(ge, _parsePosition(He || ($e ? "100% 0" : Be), $e, we, K, me() + Fe, J, U, V, Me, L, X, Be, O)) || -.001,
              ie = H - ge || (ge -= .01) && .001,
              Fe = 0,
              ze = Ue; ze--; )
                  Ge = _triggers[ze],
                  it = Ge.pin,
                  it && Ge.start - Ge._pinPush <= ge && !O && Ge.end > 0 && (De = Ge.end - Ge.start,
                  (it === b && Ge.start - Ge._pinPush < ge || it === qe) && !_isNumber(Oe) && (Fe += De * (1 - Ge.progress)),
                  it === P && (je += De));
              if (ge += Fe,
              H += Fe,
              Ie && (Je = gsap.utils.clamp(0, 1, gsap.utils.normalize(ge, H, tt))),
              V._pinPush = je,
              z && Fe && (De = {},
              De[K.a] = "+=" + Fe,
              qe && (De[K.p] = "-=" + me()),
              gsap.set([z, J], De)),
              P)
                  De = _getComputedStyle(P),
                  ot = K === _vertical,
                  ct = me(),
                  Se = parseFloat(_e(K.a)) + je,
                  !Be && H > 1 && (nt = (ee ? _doc.scrollingElement || _docEl : W).style,
                  nt = {
                      style: nt,
                      value: nt["overflow" + K.a.toUpperCase()]
                  },
                  nt.style["overflow" + K.a.toUpperCase()] = "scroll"),
                  _swapPinIn(P, ce, De),
                  re = _getState(P),
                  We = _getBounds(P, !0),
                  dt = X && _getScrollFunc(W, ot ? _horizontal : _vertical)(),
                  x && (ke = [x + K.os2, ie + je + _px],
                  ke.t = ce,
                  ze = x === _padding ? _getSize(P, K) + ie + je : 0,
                  ze && ke.push(K.d, ze + _px),
                  _setState(ke),
                  qe && _triggers.forEach(function(ht) {
                      ht.pin === qe && ht.vars.pinSpacing !== !1 && (ht._subPinOffset = !0)
                  }),
                  X && me(tt)),
                  X && (Ve = {
                      top: We.top + (ot ? ct - ge : dt) + _px,
                      left: We.left + (ot ? dt : ct - ge) + _px,
                      boxSizing: "border-box",
                      position: "fixed"
                  },
                  Ve[_width] = Ve["max" + _Width] = Math.ceil(We.width) + _px,
                  Ve[_height] = Ve["max" + _Height] = Math.ceil(We.height) + _px,
                  Ve[_margin] = Ve[_margin + _Top] = Ve[_margin + _Right] = Ve[_margin + _Bottom] = Ve[_margin + _Left] = "0",
                  Ve[_padding] = De[_padding],
                  Ve[_padding + _Top] = De[_padding + _Top],
                  Ve[_padding + _Right] = De[_padding + _Right],
                  Ve[_padding + _Bottom] = De[_padding + _Bottom],
                  Ve[_padding + _Left] = De[_padding + _Left],
                  ae = _copyState(se, Ve, M),
                  _refreshingAll && me(0)),
                  o ? (mt = o._initted,
                  _suppressOverwrites(1),
                  o.render(o.duration(), !0, !0),
                  Ee = _e(K.a) - Se + ie + je,
                  Ke = Math.abs(ie - Ee) > 1,
                  X && Ke && ae.splice(ae.length - 2, 2),
                  o.render(0, !0, !0),
                  mt || o.invalidate(!0),
                  o.parent || o.totalTime(o.totalTime()),
                  _suppressOverwrites(0)) : Ee = ie,
                  nt && (nt.value ? nt.style["overflow" + K.a.toUpperCase()] = nt.value : nt.style.removeProperty("overflow-" + K.a));
              else if (b && me() && !O)
                  for (We = b.parentNode; We && We !== _body; )
                      We._pinOffset && (ge -= We._pinOffset,
                      H -= We._pinOffset),
                      We = We.parentNode;
              ut && ut.forEach(function(ht) {
                  return ht.revert(!1, !0)
              }),
              V.start = ge,
              V.end = H,
              ue = be = _refreshingAll ? tt : me(),
              !O && !_refreshingAll && (ue < tt && me(tt),
              V.scroll.rec = 0),
              V.revert(!1, !0),
              et && (pe = -1,
              V.isActive && me(ge + ie * Je),
              et.restart(!0)),
              _refreshing = 0,
              o && Y && (o._initted || at) && o.progress() !== at && o.progress(at, !0).render(o.time(), !0, !0),
              (Ie || Je !== V.progress || O) && (o && !Y && o.totalProgress(O && ge < -.001 && !Je ? gsap.utils.normalize(ge, H, 0) : Je, !0),
              V.progress = (ue - ge) / ie === Je ? 0 : Je),
              P && x && (ce._pinOffset = Math.round(V.progress * Ee)),
              Ce && Ce.invalidate(),
              v && !_refreshingAll && v(V)
          }
      }
      ,
      V.getVelocity = function() {
          return (me() - be) / (_getTime() - _time2) * 1e3 || 0
      }
      ,
      V.endAnimation = function() {
          _endAnimation(V.callbackAnimation),
          o && (Ce ? Ce.progress(1) : o.paused() ? Y || _endAnimation(o, V.direction < 0, 1) : _endAnimation(o, o.reversed()))
      }
      ,
      V.labelToScroll = function(he) {
          return o && o.labels && (ge || V.refresh() || ge) + o.labels[he] / o.duration() * ie || 0
      }
      ,
      V.getTrailing = function(he) {
          var Te = _triggers.indexOf(V)
            , we = V.direction > 0 ? _triggers.slice(0, Te).reverse() : _triggers.slice(Te + 1);
          return (_isString(he) ? we.filter(function(Me) {
              return Me.vars.preventOverlaps === he
          }) : we).filter(function(Me) {
              return V.direction > 0 ? Me.end <= ge : Me.start >= H
          })
      }
      ,
      V.update = function(he, Te, we) {
          if (!(O && !we && !he)) {
              var Me = _refreshingAll === !0 ? tt : V.scroll(), Be = he ? 0 : (Me - ge) / ie, Ie = Be < 0 ? 0 : Be > 1 ? 1 : Be || 0, Fe = V.progress, je, He, $e, Oe, qe, Ue, ze, De;
              if (Te && (be = ue,
              ue = O ? me() : Me,
              w && (Ne = rt,
              rt = o && !Y ? o.totalProgress() : Ie)),
              I && !Ie && P && !_refreshing && !_startup && _lastScrollTime && ge < Me + (Me - be) / (_getTime() - _time2) * I && (Ie = 1e-4),
              Ie !== Fe && V.enabled) {
                  if (je = V.isActive = !!Ie && Ie < 1,
                  He = !!Fe && Fe < 1,
                  Ue = je !== He,
                  qe = Ue || !!Ie != !!Fe,
                  V.direction = Ie > Fe ? 1 : -1,
                  V.progress = Ie,
                  qe && !_refreshing && ($e = Ie && !Fe ? 0 : Ie === 1 ? 1 : Fe === 1 ? 2 : 3,
                  Y && (Oe = !Ue && B[$e + 1] !== "none" && B[$e + 1] || B[$e],
                  De = o && (Oe === "complete" || Oe === "reset" || Oe in o))),
                  j && (Ue || De) && (De || S || !o) && (_isFunction(j) ? j(V) : V.getTrailing(j).forEach(function(Ve) {
                      return Ve.endAnimation()
                  })),
                  Y || (Ce && !_refreshing && !_startup ? (Ce._dp._time - Ce._start !== Ce._time && Ce.render(Ce._dp._time - Ce._start),
                  Ce.resetTo ? Ce.resetTo("totalProgress", Ie, o._tTime / o._tDur) : (Ce.vars.totalProgress = Ie,
                  Ce.invalidate().restart())) : o && o.totalProgress(Ie, !!_refreshing)),
                  P) {
                      if (he && x && (ce.style[x + K.os2] = Re),
                      !X)
                          de(_round(Se + Ee * Ie));
                      else if (qe) {
                          if (ze = !he && Ie > Fe && H + 1 > Me && Me + 1 >= _maxScroll(W, K),
                          M)
                              if (!he && (je || ze)) {
                                  var We = _getBounds(P, !0)
                                    , ct = Me - ge;
                                  _reparent(P, _body, We.top + (K === _vertical ? ct : 0) + _px, We.left + (K === _vertical ? 0 : ct) + _px)
                              } else
                                  _reparent(P, ce);
                          _setState(je || ze ? ae : re),
                          Ke && Ie < 1 && je || de(Se + (Ie === 1 && !ze ? Ee : 0))
                      }
                  }
                  w && !Q.tween && !_refreshing && !_startup && et.restart(!0),
                  d && (Ue || T && Ie && (Ie < 1 || !_limitCallbacks)) && _toArray(d.targets).forEach(function(Ve) {
                      return Ve.classList[je || T ? "add" : "remove"](d.className)
                  }),
                  f && !Y && !he && f(V),
                  qe && !_refreshing ? (Y && (De && (Oe === "complete" ? o.pause().totalProgress(1) : Oe === "reset" ? o.restart(!0).pause() : Oe === "restart" ? o.restart(!0) : o[Oe]()),
                  f && f(V)),
                  (Ue || !_limitCallbacks) && (_ && Ue && _callback(V, _),
                  D[$e] && _callback(V, D[$e]),
                  T && (Ie === 1 ? V.kill(!1, 1) : D[$e] = 0),
                  Ue || ($e = Ie === 1 ? 1 : 3,
                  D[$e] && _callback(V, D[$e]))),
                  $ && !je && Math.abs(V.getVelocity()) > (_isNumber($) ? $ : 2500) && (_endAnimation(V.callbackAnimation),
                  Ce ? Ce.progress(1) : _endAnimation(o, Oe === "reverse" ? 1 : !Ie, 1))) : Y && f && !_refreshing && f(V)
              }
              if (Ze) {
                  var ot = O ? Me / O.duration() * (O._caScrollDist || 0) : Me;
                  Le(ot + (te._isFlipped ? 1 : 0)),
                  Ze(ot)
              }
              lt && lt(-Me / O.duration() * (O._caScrollDist || 0))
          }
      }
      ,
      V.enable = function(he, Te) {
          V.enabled || (V.enabled = !0,
          _addListener(W, "resize", _onResize),
          _addListener(ee ? _doc : W, "scroll", _onScroll),
          q && _addListener(e, "refreshInit", q),
          he !== !1 && (V.progress = Je = 0,
          ue = be = pe = me()),
          Te !== !1 && V.refresh())
      }
      ,
      V.getTween = function(he) {
          return he && Q ? Q.tween : Ce
      }
      ,
      V.setPositions = function(he, Te) {
          P && (Se += he - ge,
          Ee += Te - he - ie,
          x === _padding && V.adjustPinSpacing(Te - he - ie)),
          V.start = ge = he,
          V.end = H = Te,
          ie = Te - he,
          V.update()
      }
      ,
      V.adjustPinSpacing = function(he) {
          if (ke && he) {
              var Te = ke.indexOf(K.d) + 1;
              ke[Te] = parseFloat(ke[Te]) + he + _px,
              ke[1] = parseFloat(ke[1]) + he + _px,
              _setState(ke)
          }
      }
      ,
      V.disable = function(he, Te) {
          if (V.enabled && (he !== !1 && V.revert(!0, !0),
          V.enabled = V.isActive = !1,
          Te || Ce && Ce.pause(),
          tt = 0,
          le && (le.uncache = 1),
          q && _removeListener(e, "refreshInit", q),
          et && (et.pause(),
          Q.tween && Q.tween.kill() && (Q.tween = 0)),
          !ee)) {
              for (var we = _triggers.length; we--; )
                  if (_triggers[we].scroller === W && _triggers[we] !== V)
                      return;
              _removeListener(W, "resize", _onResize),
              _removeListener(W, "scroll", _onScroll)
          }
      }
      ,
      V.kill = function(he, Te) {
          V.disable(he, Te),
          Ce && !Te && Ce.kill(),
          g && delete _ids[g];
          var we = _triggers.indexOf(V);
          we >= 0 && _triggers.splice(we, 1),
          we === _i && _direction > 0 && _i--,
          we = 0,
          _triggers.forEach(function(Me) {
              return Me.scroller === V.scroller && (we = 1)
          }),
          we || _refreshingAll || (V.scroll.rec = 0),
          o && (o.scrollTrigger = null,
          he && o.revert({
              kill: !1
          }),
          Te || o.kill()),
          z && [z, J, te, U].forEach(function(Me) {
              return Me.parentNode && Me.parentNode.removeChild(Me)
          }),
          _primary === V && (_primary = 0),
          P && (le && (le.uncache = 1),
          we = 0,
          _triggers.forEach(function(Me) {
              return Me.pin === P && we++
          }),
          we || (le.spacer = 0)),
          a.onKill && a.onKill(V)
      }
      ,
      V.enable(!1, !1),
      st && st(V),
      !o || !o.add || ie ? V.refresh() : gsap.delayedCall(.01, function() {
          return ge || H || V.refresh()
      }) && (ie = .01) && (ge = H = 0),
      P && _queueRefreshAll()
  }
  ,
  e.register = function(a) {
      return _coreInitted || (gsap = a || _getGSAP(),
      _windowExists() && window.document && e.enable(),
      _coreInitted = _enabled),
      _coreInitted
  }
  ,
  e.defaults = function(a) {
      if (a)
          for (var o in a)
              _defaults[o] = a[o];
      return _defaults
  }
  ,
  e.disable = function(a, o) {
      _enabled = 0,
      _triggers.forEach(function(f) {
          return f[o ? "kill" : "disable"](a)
      }),
      _removeListener(_win, "wheel", _onScroll),
      _removeListener(_doc, "scroll", _onScroll),
      clearInterval(_syncInterval),
      _removeListener(_doc, "touchcancel", _passThrough),
      _removeListener(_body, "touchstart", _passThrough),
      _multiListener(_removeListener, _doc, "pointerdown,touchstart,mousedown", _pointerDownHandler),
      _multiListener(_removeListener, _doc, "pointerup,touchend,mouseup", _pointerUpHandler),
      _resizeDelay.kill(),
      _iterateAutoRefresh(_removeListener);
      for (var l = 0; l < _scrollers.length; l += 3)
          _wheelListener(_removeListener, _scrollers[l], _scrollers[l + 1]),
          _wheelListener(_removeListener, _scrollers[l], _scrollers[l + 2])
  }
  ,
  e.enable = function() {
      if (_win = window,
      _doc = document,
      _docEl = _doc.documentElement,
      _body = _doc.body,
      gsap && (_toArray = gsap.utils.toArray,
      _clamp = gsap.utils.clamp,
      _context = gsap.core.context || _passThrough,
      _suppressOverwrites = gsap.core.suppressOverwrites || _passThrough,
      _scrollRestoration = _win.history.scrollRestoration || "auto",
      _lastScroll = _win.pageYOffset,
      gsap.core.globals("ScrollTrigger", e),
      _body)) {
          _enabled = 1,
          _rafBugFix(),
          Observer.register(gsap),
          e.isTouch = Observer.isTouch,
          _fixIOSBug = Observer.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent),
          _addListener(_win, "wheel", _onScroll),
          _root = [_win, _doc, _docEl, _body],
          gsap.matchMedia ? (e.matchMedia = function(g) {
              var _ = gsap.matchMedia(), v;
              for (v in g)
                  _.add(v, g[v]);
              return _
          }
          ,
          gsap.addEventListener("matchMediaInit", function() {
              return _revertAll()
          }),
          gsap.addEventListener("matchMediaRevert", function() {
              return _revertRecorded()
          }),
          gsap.addEventListener("matchMedia", function() {
              _refreshAll(0, 1),
              _dispatch("matchMedia")
          }),
          gsap.matchMedia("(orientation: portrait)", function() {
              return _setBaseDimensions(),
              _setBaseDimensions
          })) : console.warn("Requires GSAP 3.11.0 or later"),
          _setBaseDimensions(),
          _addListener(_doc, "scroll", _onScroll);
          var a = _body.style, o = a.borderTopStyle, l = gsap.core.Animation.prototype, f, d;
          for (l.revert || Object.defineProperty(l, "revert", {
              value: function() {
                  return this.time(-.01, !0)
              }
          }),
          a.borderTopStyle = "solid",
          f = _getBounds(_body),
          _vertical.m = Math.round(f.top + _vertical.sc()) || 0,
          _horizontal.m = Math.round(f.left + _horizontal.sc()) || 0,
          o ? a.borderTopStyle = o : a.removeProperty("border-top-style"),
          _syncInterval = setInterval(_sync, 250),
          gsap.delayedCall(.5, function() {
              return _startup = 0
          }),
          _addListener(_doc, "touchcancel", _passThrough),
          _addListener(_body, "touchstart", _passThrough),
          _multiListener(_addListener, _doc, "pointerdown,touchstart,mousedown", _pointerDownHandler),
          _multiListener(_addListener, _doc, "pointerup,touchend,mouseup", _pointerUpHandler),
          _transformProp = gsap.utils.checkPrefix("transform"),
          _stateProps.push(_transformProp),
          _coreInitted = _getTime(),
          _resizeDelay = gsap.delayedCall(.2, _refreshAll).pause(),
          _autoRefresh = [_doc, "visibilitychange", function() {
              var g = _win.innerWidth
                , _ = _win.innerHeight;
              _doc.hidden ? (_prevWidth = g,
              _prevHeight = _) : (_prevWidth !== g || _prevHeight !== _) && _onResize()
          }
          , _doc, "DOMContentLoaded", _refreshAll, _win, "load", _refreshAll, _win, "resize", _onResize],
          _iterateAutoRefresh(_addListener),
          _triggers.forEach(function(g) {
              return g.enable(0, 1)
          }),
          d = 0; d < _scrollers.length; d += 3)
              _wheelListener(_removeListener, _scrollers[d], _scrollers[d + 1]),
              _wheelListener(_removeListener, _scrollers[d], _scrollers[d + 2])
      }
  }
  ,
  e.config = function(a) {
      "limitCallbacks"in a && (_limitCallbacks = !!a.limitCallbacks);
      var o = a.syncInterval;
      o && clearInterval(_syncInterval) || (_syncInterval = o) && setInterval(_sync, o),
      "ignoreMobileResize"in a && (_ignoreMobileResize = e.isTouch === 1 && a.ignoreMobileResize),
      "autoRefreshEvents"in a && (_iterateAutoRefresh(_removeListener) || _iterateAutoRefresh(_addListener, a.autoRefreshEvents || "none"),
      _ignoreResize = (a.autoRefreshEvents + "").indexOf("resize") === -1)
  }
  ,
  e.scrollerProxy = function(a, o) {
      var l = _getTarget(a)
        , f = _scrollers.indexOf(l)
        , d = _isViewport(l);
      ~f && _scrollers.splice(f, d ? 6 : 2),
      o && (d ? _proxies.unshift(_win, o, _body, o, _docEl, o) : _proxies.unshift(l, o))
  }
  ,
  e.clearMatchMedia = function(a) {
      _triggers.forEach(function(o) {
          return o._ctx && o._ctx.query === a && o._ctx.kill(!0, !0)
      })
  }
  ,
  e.isInViewport = function(a, o, l) {
      var f = (_isString(a) ? _getTarget(a) : a).getBoundingClientRect()
        , d = f[l ? _width : _height] * o || 0;
      return l ? f.right - d > 0 && f.left + d < _win.innerWidth : f.bottom - d > 0 && f.top + d < _win.innerHeight
  }
  ,
  e.positionInViewport = function(a, o, l) {
      _isString(a) && (a = _getTarget(a));
      var f = a.getBoundingClientRect()
        , d = f[l ? _width : _height]
        , g = o == null ? d / 2 : o in _keywords ? _keywords[o] * d : ~o.indexOf("%") ? parseFloat(o) * d / 100 : parseFloat(o) || 0;
      return l ? (f.left + g) / _win.innerWidth : (f.top + g) / _win.innerHeight
  }
  ,
  e.killAll = function(a) {
      if (_triggers.slice(0).forEach(function(l) {
          return l.vars.id !== "ScrollSmoother" && l.kill()
      }),
      a !== !0) {
          var o = _listeners.killAll || [];
          _listeners = {},
          o.forEach(function(l) {
              return l()
          })
      }
  }
  ,
  e
}();
ScrollTrigger.version = "3.11.5";
ScrollTrigger.saveStyles = function(e) {
  return e ? _toArray(e).forEach(function(t) {
      if (t && t.style) {
          var r = _savedStyles.indexOf(t);
          r >= 0 && _savedStyles.splice(r, 5),
          _savedStyles.push(t, t.style.cssText, t.getBBox && t.getAttribute("transform"), gsap.core.getCache(t), _context())
      }
  }) : _savedStyles
}
;
ScrollTrigger.revert = function(e, t) {
  return _revertAll(!e, t)
}
;
ScrollTrigger.create = function(e, t) {
  return new ScrollTrigger(e,t)
}
;
ScrollTrigger.refresh = function(e) {
  return e ? _onResize() : (_coreInitted || ScrollTrigger.register()) && _refreshAll(!0)
}
;
ScrollTrigger.update = function(e) {
  return ++_scrollers.cache && _updateAll(e === !0 ? 2 : 0)
}
;
ScrollTrigger.clearScrollMemory = _clearScrollMemory;
ScrollTrigger.maxScroll = function(e, t) {
  return _maxScroll(e, t ? _horizontal : _vertical)
}
;
ScrollTrigger.getScrollFunc = function(e, t) {
  return _getScrollFunc(_getTarget(e), t ? _horizontal : _vertical)
}
;
ScrollTrigger.getById = function(e) {
  return _ids[e]
}
;
ScrollTrigger.getAll = function() {
  return _triggers.filter(function(e) {
      return e.vars.id !== "ScrollSmoother"
  })
}
;
ScrollTrigger.isScrolling = function() {
  return !!_lastScrollTime
}
;
ScrollTrigger.snapDirectional = _snapDirectional;
ScrollTrigger.addEventListener = function(e, t) {
  var r = _listeners[e] || (_listeners[e] = []);
  ~r.indexOf(t) || r.push(t)
}
;
ScrollTrigger.removeEventListener = function(e, t) {
  var r = _listeners[e]
    , a = r && r.indexOf(t);
  a >= 0 && r.splice(a, 1)
}
;
ScrollTrigger.batch = function(e, t) {
  var r = [], a = {}, o = t.interval || .016, l = t.batchMax || 1e9, f = function(_, v) {
      var S = []
        , b = []
        , P = gsap.delayedCall(o, function() {
          v(S, b),
          S = [],
          b = []
      }).pause();
      return function(x) {
          S.length || P.restart(!0),
          S.push(x.trigger),
          b.push(x),
          l <= S.length && P.progress(1)
      }
  }, d;
  for (d in t)
      a[d] = d.substr(0, 2) === "on" && _isFunction(t[d]) && d !== "onRefreshInit" ? f(d, t[d]) : t[d];
  return _isFunction(l) && (l = l(),
  _addListener(ScrollTrigger, "refresh", function() {
      return l = t.batchMax()
  })),
  _toArray(e).forEach(function(g) {
      var _ = {};
      for (d in a)
          _[d] = a[d];
      _.trigger = g,
      r.push(ScrollTrigger.create(_))
  }),
  r
}
;
var _clampScrollAndGetDurationMultiplier = function e(t, r, a, o) {
  return r > o ? t(o) : r < 0 && t(0),
  a > o ? (o - r) / (a - r) : a < 0 ? r / (r - a) : 1
}, _allowNativePanning = function e(t, r) {
  r === !0 ? t.style.removeProperty("touch-action") : t.style.touchAction = r === !0 ? "auto" : r ? "pan-" + r + (Observer.isTouch ? " pinch-zoom" : "") : "none",
  t === _docEl && e(_body, r)
}, _overflow = {
  auto: 1,
  scroll: 1
}, _nestedScroll = function e(t) {
  var r = t.event, a = t.target, o = t.axis, l = (r.changedTouches ? r.changedTouches[0] : r).target, f = l._gsap || gsap.core.getCache(l), d = _getTime(), g;
  if (!f._isScrollT || d - f._isScrollT > 2e3) {
      for (; l && l !== _body && (l.scrollHeight <= l.clientHeight && l.scrollWidth <= l.clientWidth || !(_overflow[(g = _getComputedStyle(l)).overflowY] || _overflow[g.overflowX])); )
          l = l.parentNode;
      f._isScroll = l && l !== a && !_isViewport(l) && (_overflow[(g = _getComputedStyle(l)).overflowY] || _overflow[g.overflowX]),
      f._isScrollT = d
  }
  (f._isScroll || o === "x") && (r.stopPropagation(),
  r._gsapAllow = !0)
}, _inputObserver = function e(t, r, a, o) {
  return Observer.create({
      target: t,
      capture: !0,
      debounce: !1,
      lockAxis: !0,
      type: r,
      onWheel: o = o && _nestedScroll,
      onPress: o,
      onDrag: o,
      onScroll: o,
      onEnable: function() {
          return a && _addListener(_doc, Observer.eventTypes[0], _captureInputs, !1, !0)
      },
      onDisable: function() {
          return _removeListener(_doc, Observer.eventTypes[0], _captureInputs, !0)
      }
  })
}, _inputExp = /(input|label|select|textarea)/i, _inputIsFocused, _captureInputs = function e(t) {
  var r = _inputExp.test(t.target.tagName);
  (r || _inputIsFocused) && (t._gsapAllow = !0,
  _inputIsFocused = r)
}, _getScrollNormalizer = function e(t) {
  _isObject(t) || (t = {}),
  t.preventDefault = t.isNormalizer = t.allowClicks = !0,
  t.type || (t.type = "wheel,touch"),
  t.debounce = !!t.debounce,
  t.id = t.id || "normalizer";
  var r = t, a = r.normalizeScrollX, o = r.momentum, l = r.allowNestedScroll, f = r.onRelease, d, g, _ = _getTarget(t.target) || _docEl, v = gsap.core.globals().ScrollSmoother, S = v && v.get(), b = _fixIOSBug && (t.content && _getTarget(t.content) || S && t.content !== !1 && !S.smooth() && S.content()), P = _getScrollFunc(_, _vertical), x = _getScrollFunc(_, _horizontal), E = 1, I = (Observer.isTouch && _win.visualViewport ? _win.visualViewport.scale * _win.visualViewport.width : _win.outerWidth) / _win.innerWidth, C = 0, A = _isFunction(o) ? function() {
      return o(d)
  }
  : function() {
      return o || 2.8
  }
  , T, w, M = _inputObserver(_, t.type, !0, l), F = function() {
      return w = !1
  }, O = _passThrough, $ = _passThrough, j = function() {
      g = _maxScroll(_, _vertical),
      $ = _clamp(_fixIOSBug ? 1 : 0, g),
      a && (O = _clamp(0, _maxScroll(_, _horizontal))),
      T = _refreshID
  }, K = function() {
      b._gsap.y = _round(parseFloat(b._gsap.y) + P.offset) + "px",
      b.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(b._gsap.y) + ", 0, 1)",
      P.offset = P.cacheID = 0
  }, Y = function() {
      if (w) {
          requestAnimationFrame(F);
          var R = _round(d.deltaY / 2)
            , L = $(P.v - R);
          if (b && L !== P.v + P.offset) {
              P.offset = L - P.v;
              var V = _round((parseFloat(b && b._gsap.y) || 0) - P.offset);
              b.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + V + ", 0, 1)",
              b._gsap.y = V + "px",
              P.cacheID = _scrollers.cache,
              _updateAll()
          }
          return !0
      }
      P.offset && K(),
      w = !0
  }, W, Z, ee, X, D = function() {
      j(),
      W.isActive() && W.vars.scrollY > g && (P() > g ? W.progress(1) && P(g) : W.resetTo("scrollY", g))
  };
  return b && gsap.set(b, {
      y: "+=0"
  }),
  t.ignoreCheck = function(B) {
      return _fixIOSBug && B.type === "touchmove" && Y() || E > 1.05 && B.type !== "touchstart" || d.isGesturing || B.touches && B.touches.length > 1
  }
  ,
  t.onPress = function() {
      w = !1;
      var B = E;
      E = _round((_win.visualViewport && _win.visualViewport.scale || 1) / I),
      W.pause(),
      B !== E && _allowNativePanning(_, E > 1.01 ? !0 : a ? !1 : "x"),
      Z = x(),
      ee = P(),
      j(),
      T = _refreshID
  }
  ,
  t.onRelease = t.onGestureStart = function(B, R) {
      if (P.offset && K(),
      !R)
          X.restart(!0);
      else {
          _scrollers.cache++;
          var L = A(), V, q;
          a && (V = x(),
          q = V + L * .05 * -B.velocityX / .227,
          L *= _clampScrollAndGetDurationMultiplier(x, V, q, _maxScroll(_, _horizontal)),
          W.vars.scrollX = O(q)),
          V = P(),
          q = V + L * .05 * -B.velocityY / .227,
          L *= _clampScrollAndGetDurationMultiplier(P, V, q, _maxScroll(_, _vertical)),
          W.vars.scrollY = $(q),
          W.invalidate().duration(L).play(.01),
          (_fixIOSBug && W.vars.scrollY >= g || V >= g - 1) && gsap.to({}, {
              onUpdate: D,
              duration: L
          })
      }
      f && f(B)
  }
  ,
  t.onWheel = function() {
      W._ts && W.pause(),
      _getTime() - C > 1e3 && (T = 0,
      C = _getTime())
  }
  ,
  t.onChange = function(B, R, L, V, q) {
      if (_refreshID !== T && j(),
      R && a && x(O(V[2] === R ? Z + (B.startX - B.x) : x() + R - V[1])),
      L) {
          P.offset && K();
          var oe = q[2] === L
            , ye = oe ? ee + B.startY - B.y : P() + L - q[1]
            , pe = $(ye);
          oe && ye !== pe && (ee += pe - ye),
          P(pe)
      }
      (L || R) && _updateAll()
  }
  ,
  t.onEnable = function() {
      _allowNativePanning(_, a ? !1 : "x"),
      ScrollTrigger.addEventListener("refresh", D),
      _addListener(_win, "resize", D),
      P.smooth && (P.target.style.scrollBehavior = "auto",
      P.smooth = x.smooth = !1),
      M.enable()
  }
  ,
  t.onDisable = function() {
      _allowNativePanning(_, !0),
      _removeListener(_win, "resize", D),
      ScrollTrigger.removeEventListener("refresh", D),
      M.kill()
  }
  ,
  t.lockAxis = t.lockAxis !== !1,
  d = new Observer(t),
  d.iOS = _fixIOSBug,
  _fixIOSBug && !P() && P(1),
  _fixIOSBug && gsap.ticker.add(_passThrough),
  X = d._dc,
  W = gsap.to(d, {
      ease: "power4",
      paused: !0,
      scrollX: a ? "+=0.1" : "+=0",
      scrollY: "+=0.1",
      modifiers: {
          scrollY: _interruptionTracker(P, P(), function() {
              return W.pause()
          })
      },
      onUpdate: _updateAll,
      onComplete: X.vars.onComplete
  }),
  d
};
ScrollTrigger.sort = function(e) {
  return _triggers.sort(e || function(t, r) {
      return (t.vars.refreshPriority || 0) * -1e6 + t.start - (r.start + (r.vars.refreshPriority || 0) * -1e6)
  }
  )
}
;
ScrollTrigger.observe = function(e) {
  return new Observer(e)
}
;
ScrollTrigger.normalizeScroll = function(e) {
  if (typeof e > "u")
      return _normalizer;
  if (e === !0 && _normalizer)
      return _normalizer.enable();
  if (e === !1)
      return _normalizer && _normalizer.kill();
  var t = e instanceof Observer ? e : _getScrollNormalizer(e);
  return _normalizer && _normalizer.target === t.target && _normalizer.kill(),
  _isViewport(t.target) && (_normalizer = t),
  t
}
;
ScrollTrigger.core = {
  _getVelocityProp,
  _inputObserver,
  _scrollers,
  _proxies,
  bridge: {
      ss: function e() {
          _lastScrollTime || _dispatch("scrollStart"),
          _lastScrollTime = _getTime()
      },
      ref: function e() {
          return _refreshing
      }
  }
};
_getGSAP() && gsap.registerPlugin(ScrollTrigger);
const _hoisted_1$2 = {
  class: "c-nav"
}
, _hoisted_2$2 = {
  class: "c-container"
}
, _hoisted_3$2 = {
  class: "padding-global"
}
, _hoisted_4$2 = {
  class: "nav-inner"
}
, _hoisted_5$2 = createBaseVNode("img", {
  alt: "",
  class: "c-img",
  src: _imports_0
}, null, -1)
, _hoisted_6$2 = createBaseVNode("div", null, "Menu", -1)
, _hoisted_7$2 = createBaseVNode("div", {
  class: "menu-icon"
}, null, -1)
, _hoisted_8$2 = [_hoisted_6$2, _hoisted_7$2]
, _hoisted_9$1 = {
  key: 0,
  class: "page-progress"
}
, _hoisted_10$1 = {
  class: "section-name"
}
, _hoisted_11 = createBaseVNode("div", {
  class: "page-progress_fill"
}, null, -1)
, _sfc_main$3 = defineComponent({
  __name: "HeaderNav",
  props: {
      showSection: {
          type: Boolean,
          default: !0
      },
      showBg: {
          type: Boolean,
          default: !0
      },
      sections: {
          default: void 0
      }
  },
  setup(e) {
      gsapWithCSS.registerPlugin(ScrollTrigger);
      const t = e
        , r = useState("menu", ()=>!1)
        , a = useState("loader")
        , o = useRoute$1()
        , f = useFetchState(`/collections/${useRuntimeConfig().public.projectsID}/items/${o.query.id}`)
        , d = ()=>{
          r.value = !0
      }
        , g = ()=>{
          var v;
          if ((v = t.sections) != null && v.length) {
              const S = document.querySelectorAll(".page-progress_fill")
                , b = document.getElementsByTagName("section");
              b.length && S.forEach((P,x)=>{
                  gsapWithCSS.to(P, {
                      width: "100%",
                      ease: "none",
                      scrollTrigger: {
                          trigger: b[x],
                          start: x === 0 ? `top ${b[0].offsetTop}` : "top 86px",
                          end: "bottom 86px",
                          scrub: !0
                      }
                  })
              }
              )
          }
      }
        , _ = v=>{
          var I, C;
          const b = (C = (I = v.currentTarget.firstElementChild) == null ? void 0 : I.textContent) == null ? void 0 : C.toLowerCase().replace(/\s/g, "-")
            , P = document.querySelector(`#${b}`)
            , x = P.style.position
            , E = P.style.top;
          P.style.position = "relative",
          P.style.top = "-90px",
          P.scrollIntoView({
              behavior: "smooth",
              block: "start"
          }),
          P.style.top = E,
          P.style.position = x
      }
      ;
      return onMounted(()=>{
          nextTick(()=>{
              g()
          }
          )
      }
      ),
      watch(()=>f.value.isWorking, v=>{
          v === !1 && a.value === !0 && setTimeout(()=>{
              g()
          }
          , 100)
      }
      ),
      (v,S)=>{
          var P;
          const b = __nuxt_component_0$1;
          return openBlock(),
          createElementBlock("nav", _hoisted_1$2, [createBaseVNode("div", _hoisted_2$2, [createBaseVNode("div", _hoisted_3$2, [createBaseVNode("div", _hoisted_4$2, [createVNode(b, {
              "aria-current": "page",
              "aria-label": "Go to home page",
              class: "nav-logo w-inline-block w--current",
              to: "/"
          }, {
              default: withCtx(()=>[_hoisted_5$2]),
              _: 1
          }), createBaseVNode("button", {
              class: "menu-button",
              onClick: d
          }, _hoisted_8$2), (P = v.sections) != null && P.length ? (openBlock(),
          createElementBlock("div", _hoisted_9$1, [(openBlock(!0),
          createElementBlock(Fragment, null, renderList(v.sections, (x,E)=>(openBlock(),
          createElementBlock("div", {
              key: E,
              class: "page-section",
              onClick: S[0] || (S[0] = I=>_(I))
          }, [createBaseVNode("div", _hoisted_10$1, toDisplayString(x), 1), _hoisted_11]))), 128))])) : createCommentVNode("", !0)])])]), createBaseVNode("div", {
              class: normalizeClass(["nav-bg", v.showBg ? "" : "cc-hide"])
          }, null, 2)])
      }
  }
})
, _hoisted_1$1 = {
  class: "c-button_inner"
}
, _hoisted_2$1 = {
  class: "button-mask"
}
, _hoisted_3$1 = {
  class: "button-text cc-top",
  "data-button": ""
}
, _hoisted_4$1 = {
  class: "button-text cc-bottom",
  "data-button": ""
}
, _hoisted_5$1 = {
  class: "c-button_inner"
}
, _hoisted_6$1 = {
  class: "button-mask"
}
, _hoisted_7$1 = {
  class: "button-text cc-top",
  "data-button": ""
}
, _hoisted_8$1 = {
  class: "button-text cc-bottom",
  "data-button": ""
}
, _sfc_main$2 = defineComponent({
  __name: "CButton",
  props: {
      href: {
          default: void 0
      },
      iconClass: {
          default: void 0
      },
      reversed: {
          type: Boolean,
          default: !1
      }
  },
  emits: ["click"],
  setup(e) {
      const t = (r,a)=>{
          const l = a.currentTarget.querySelectorAll(".button-text");
          gsapWithCSS.registerPlugin(CustomEase);
          const f = gsapWithCSS.timeline({});
          f.to(l, {
              transform: "translate(0%, -100%)",
              duration: .8,
              ease: CustomEase.create("hover", ".17, .17, 0, 1")
          });
          const d = gsapWithCSS.timeline({
              paused: !0
          });
          d.to(l, {
              transform: "translate(0%, 0%)",
              duration: .8,
              ease: CustomEase.create("hover", ".17, .17, 0, 1")
          }),
          r === "in" ? f.play() : r === "out" && d.play()
      }
      ;
      return (r,a)=>r.reversed ? (openBlock(),
      createBlock(resolveDynamicComponent(r.href ? ("defineNuxtLink"in r ? r.defineNuxtLink : unref(defineNuxtLink))({}) : "button"), {
          key: 1,
          class: "c-button w-inline-block",
          to: r.href,
          onClick: a[3] || (a[3] = o=>r.$emit("click", o)),
          onMouseenter: a[4] || (a[4] = o=>t("in", o)),
          onMouseleave: a[5] || (a[5] = o=>t("out", o))
      }, {
          default: withCtx(()=>[createBaseVNode("div", _hoisted_5$1, [createBaseVNode("div", {
              class: normalizeClass(["button-icon", r.iconClass])
          }, null, 2), createBaseVNode("div", _hoisted_6$1, [createBaseVNode("div", _hoisted_7$1, [renderSlot(r.$slots, "default", {}, void 0, !0)]), createBaseVNode("div", _hoisted_8$1, [renderSlot(r.$slots, "default", {}, void 0, !0)])])])]),
          _: 3
      }, 40, ["to"])) : (openBlock(),
      createBlock(resolveDynamicComponent(r.href ? ("defineNuxtLink"in r ? r.defineNuxtLink : unref(defineNuxtLink))({}) : "button"), {
          key: 0,
          class: "c-button w-inline-block",
          to: r.href,
          onClick: a[0] || (a[0] = o=>r.$emit("click", o)),
          onMouseenter: a[1] || (a[1] = o=>t("in", o)),
          onMouseleave: a[2] || (a[2] = o=>t("out", o))
      }, {
          default: withCtx(()=>[createBaseVNode("div", _hoisted_1$1, [createBaseVNode("div", _hoisted_2$1, [createBaseVNode("div", _hoisted_3$1, [renderSlot(r.$slots, "default", {}, void 0, !0)]), createBaseVNode("div", _hoisted_4$1, [renderSlot(r.$slots, "default", {}, void 0, !0)])]), createBaseVNode("div", {
              class: normalizeClass(["button-icon", r.iconClass])
          }, null, 2)])]),
          _: 3
      }, 40, ["to"]))
  }
})
, _export_sfc = (e,t)=>{
  const r = e.__vccOpts || e;
  for (const [a,o] of t)
      r[a] = o;
  return r
}
, __nuxt_component_0 = _export_sfc(_sfc_main$2, [["__scopeId", "data-v-50808a10"]])
, _hoisted_1 = {
  class: "page-wrapper"
}
, _hoisted_2 = {
  class: "main-wrapper"
}
, _hoisted_3 = {
  class: "section-404"
}
, _hoisted_4 = {
  class: "c-container"
}
, _hoisted_5 = {
  class: "padding-global"
}
, _hoisted_6 = {
  class: "error-inner"
}
, _hoisted_7 = {
  key: 0
}
, _hoisted_8 = {
  key: 1,
  class: "error-subtext"
}
, _hoisted_9 = {
  key: 2
}
, _hoisted_10 = createStaticVNode('<div class="relative-block cc-error" data-v-a58d8d28><div class="error-title" data-v-a58d8d28>Let&#39;s make it happen together.</div><div class="error-line" data-v-a58d8d28></div><div class="error-line cc-two" data-v-a58d8d28></div><div class="error-line cc-three" data-v-a58d8d28></div><div class="error-line cc-four" data-v-a58d8d28></div><div class="error-tag cc-branding" data-v-a58d8d28>Branding</div><div class="error-tag cc-digital" data-v-a58d8d28>Digital</div><div class="error-tag cc-visuals" data-v-a58d8d28>Visuals</div><div class="error-tag cc-strategy" data-v-a58d8d28>Strategy</div></div>', 1)
, _sfc_main$1 = defineComponent({
  __name: "error",
  props: {
      error: {
          default: ()=>new Error("An error message"),
          type: Object
      }
  },
  setup(e) {
      const t = ()=>clearError({
          redirect: "/about"
      });
      return (r,a)=>{
          const o = _sfc_main$3
            , l = __nuxt_component_0;
          return openBlock(),
          createElementBlock("div", _hoisted_1, [createVNode(o), createBaseVNode("main", _hoisted_2, [createBaseVNode("section", _hoisted_3, [createBaseVNode("div", _hoisted_4, [createBaseVNode("div", _hoisted_5, [createBaseVNode("div", _hoisted_6, [e.error.statusCode !== 404 ? (openBlock(),
          createElementBlock("div", _hoisted_7, "Error " + toDisplayString(e.error.statusCode), 1)) : createCommentVNode("", !0), e.error.statusCode === 404 ? (openBlock(),
          createElementBlock("div", _hoisted_8, " Are you lost? ")) : (openBlock(),
          createElementBlock("div", _hoisted_9, toDisplayString(e.error.message), 1)), _hoisted_10, createVNode(l, {
              onClick: t
          }, {
              default: withCtx(()=>[createTextVNode("About us")]),
              _: 1
          })])])])])])])
      }
  }
})
, ErrorComponent = _export_sfc(_sfc_main$1, [["__scopeId", "data-v-a58d8d28"]])
, _sfc_main = {
  __name: "nuxt-root",
  setup(e) {
      const t = ()=>null
        , r = useNuxtApp()
        , a = r.deferHydration();
      if (r.isHydrating) {
          const d = r.hooks.hookOnce("app:error", a);
          useRouter().beforeEach(d)
      }
      const o = !1;
      provide(PageRouteSymbol, useRoute$1()),
      r.hooks.callHookWith(d=>d.map(g=>g()), "vue:setup");
      const l = useError();
      onErrorCaptured((d,g,_)=>{
          if (r.hooks.callHook("vue:error", d, g, _).catch(v=>console.error("[nuxt] Error in `vue:error` hook", v)),
          isNuxtError(d) && (d.fatal || d.unhandled))
              return r.runWithContext(()=>showError(d)),
              !1
      }
      );
      const f = !1;
      return (d,g)=>(openBlock(),
      createBlock(Suspense, {
          onResolve: unref(a)
      }, {
          default: withCtx(()=>[unref(l) ? (openBlock(),
          createBlock(unref(ErrorComponent), {
              key: 0,
              error: unref(l)
          }, null, 8, ["error"])) : unref(f) ? (openBlock(),
          createBlock(unref(t), {
              key: 1,
              context: unref(f)
          }, null, 8, ["context"])) : unref(o) ? (openBlock(),
          createBlock(resolveDynamicComponent(unref(o)), {
              key: 2
          })) : (openBlock(),
          createBlock(unref(_sfc_main$4), {
              key: 3
          }))]),
          _: 1
      }, 8, ["onResolve"]))
  }
}
, RootComponent = _sfc_main;
let entry;
{
  let e;
  entry = async function() {
      var f, d;
      if (e)
          return e;
      const a = !!((f = window.__NUXT__) != null && f.serverRendered || ((d = document.getElementById("__NUXT_DATA__")) == null ? void 0 : d.dataset.ssr) === "true") ? createSSRApp(RootComponent) : createApp(RootComponent)
        , o = createNuxtApp({
          vueApp: a
      });
      async function l(g) {
          await o.callHook("app:error", g),
          o.payload.error = o.payload.error || createError(g)
      }
      a.config.errorHandler = l;
      try {
          await applyPlugins(o, plugins)
      } catch (g) {
          l(g)
      }
      try {
          await o.hooks.callHook("app:created", a),
          await o.hooks.callHook("app:beforeMount", a),
          a.mount(vueAppRootContainer),
          await o.hooks.callHook("app:mounted", a),
          await nextTick()
      } catch (g) {
          l(g)
      }
      return a.config.errorHandler === l && (a.config.errorHandler = void 0),
      a
  }
  ,
  e = entry().catch(t=>{
      throw console.error("Error while mounting app:", t),
      t
  }
  )
}
export {_imports_0 as $, renderList as A, useRuntimeConfig as B, toDisplayString as C, withModifiers as D, withDirectives as E, Fragment as F, vModelText as G, vModelCheckbox as H, createBlock as I, onUpdated as J, provide as K, nextTick as L, onBeforeUnmount as M, h as N, Observer as O, onBeforeUpdate as P, normalizeClass as Q, useRoute$1 as R, ScrollTrigger as S, normalizeStyle as T, __nuxt_component_0$1 as U, Vue3Lottie as V, isRef as W, resolveDynamicComponent as X, defineNuxtLink as Y, lottie as Z, _sfc_main$3 as _, onUnmounted as a, defineNuxtRouteMiddleware as a0, navigateTo as a1, executeAsync as a2, __nuxt_component_1$1 as a3, asyncDataDefaults as a4, shallowRef as a5, toRef as a6, onBeforeMount as a7, useNuxtApp as a8, createError as a9, getCurrentInstance as aa, toValue as ab, fetchDefaults as ac, defu as ad, getCurrentScope as ae, onScopeDispose as af, customRef as ag, destr as ah, useSeoMeta as b, openBlock as c, defineComponent as d, createElementBlock as e, createVNode as f, gsapWithCSS as g, unref as h, createBaseVNode as i, createCommentVNode as j, withCtx as k, createTextVNode as l, createStaticVNode as m, useDefault as n, onMounted as o, __nuxt_component_0 as p, pushScopeId as q, ref as r, popScopeId as s, _export_sfc as t, useState as u, reactive as v, watch as w, useFetchState as x, withAsyncContext as y, computed as z};